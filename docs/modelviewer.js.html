<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modelviewer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modelviewer.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @class The main model viewer object.
 * @name ModelViewer
 * @param {HTMLCanvasElement} canvas A canvas element.
 * @param {object} urls An object with the necessary methods to get urls from the viewer.
 * @param {function} onmessage A callback function, which the viewer will call with messages.
 * @param {boolean} debugMode If true, the viewer will log the loaded models and their parser to the console.
 */
window["ModelViewer"] = function (canvas, urls, onmessage, debugMode) {
  var grassPath = urls.localFile("grass.png");
  var waterPath = urls.localFile("water.png");
  var bedrockPath = urls.localFile("bedrock.png");
  var skyPath = urls.localFile("sky.png");
  
  // This function is used to filter out reports for internal textures (e.g. ground, sky, team colors beside 00, etc.).
  function noReport(path) {
    if (path === grassPath || path === waterPath || path === bedrockPath || path === skyPath) {
      return true;
    }
    
    return false;
  }
  
  function sendMessage(e) {
    if (typeof onmessage === "function") {
      onmessage(e);
    }
  }
  
  function objectTypeName(object) {
    if (object.isModel) {
      return "model";
    } else if (object.isInstance) {
      return "instance";
    } else if (object.isHeader) {
      return "header";
    } else if (object.isTexture) {
      return "texture";
    } else if (object.isWebGL) {
      return "webgl";
    } else if (object.isShader) {
      return "shader";
    }
  }
  
  function onloadstart(object) {
    var source = object.source;
    
    if (!noReport(source)) {
      sendMessage({type: "loadstart", objectType: objectTypeName(object), source: source});
    }
  }
  
  function onload(object) {
    var source = object.source,
          message;
    
    if (!noReport(source) ){
      message = {type: "load", objectType: objectTypeName(object), source: source};
      
      if (object.isModel || object.isInstance) {
        message.id = object.id;
      }
      
      sendMessage(message);
    }
  }
  
  function onerror(object, error) {
    sendMessage({type: "error", objectType: objectTypeName(object), source: object.source, error: error});
  }
  
  function onprogress(object, e) {
    var source = object.source,
          progress = e.loaded / e.total;
    
    if (e.target.status === 200) {
      if (!noReport(source)) {
        if (progress === Infinity) {
          progress = 0;
        }
      
        sendMessage({type: "progress", objectType: objectTypeName(object), source: source, progress: progress});
      }
    }
  }
  
  function onunload(object) {
    var message = {type: "unload", objectType: objectTypeName(object), source: object.source};
    
    if (object.isModel || object.isInstance) {
      message.id = object.id;
    }
      
    sendMessage(message);
  }
  
  var gl = GL(canvas, onload, onerror, onprogress, onloadstart, onunload);
  
  if (!gl) {
    return;
  }
  
  var ctx = gl.ctx;
  var cameraMatrix = mat4.create();
  var inverseCamera = mat4.create();
  var inverseCameraRotation = mat4.create();
  var lightPosition = [0, 0, 10000];
  var cameraPosition = vec3.create();
  var grass_water;
  var bedrock;
  var sky;
  var uvOffset = [0, 0];
  var uvSpeed = [Math.randomRange(-0.004, 0.004), Math.randomRange(-0.004, 0.004)];
  
  var idFactory = -1;
  var modelArray = []; // All models
  var instanceArray = []; // All instances
  var modelInstanceMap = {}; // Referebce by ID. This is a map to support deletions.
  var modelMap = {}; // Reference by source
  var instanceMap = {}; // Reference by color
  
  var supportedFileTypes = {"png":1, "gif":1, "jpg":1};
  var supportedModelFileTypes = {};
  var supportedTextureFileTypes = {"png":1, "gif":1, "jpg":1};
  
  var teamColors = [
    [255, 3, 3],
    [0, 66, 255],
    [28, 230, 185],
    [84, 0, 129],
    [255, 252, 1],
    [254, 138, 14],
    [32, 192, 0],
    [229, 91, 176],
    [149, 150, 151],
    [126, 191, 241],
    [16, 98, 70],
    [78, 42, 4],
    [40, 40, 40],
    [0, 0, 0]
  ];
  
  var shaders = [
    "standard",
    "diffuse",
    "normals",
    "uvs",
    "normalmap",
    "specular",
    "specular_normalmap",
    "emissive",
    "unshaded",
    "unshaded_normalmap",
    "decal",
    "white"
  ];
  
  // Used by Mdx.ParticleEmitter since they don't need to be automatically updated and rendered
  function loadInternalResource(source) {
    if (!modelMap[source]) {
      modelMap[source] = new AsyncModel(source);
      onloadstart(modelMap[source]);
    }
    
    var instance = new AsyncModelInstance(modelMap[source]);
    
    onloadstart(instance);
    
    // Avoid reporting this instance since it's internal
    instance.delayOnload = true;
    
    return instance;
  }
  
  var context = {
    frameTime: 1000 / 60,
    camera: [[0, 0, 0], [0, 0]],
    instanceCamera: [-1, -1],
    worldMode: 2,
    groundSize: 256,
    meshesMode: true,
    emittersMode: true,
    polygonMode: true,
    teamColorsMode: true,
    boundingShapesMode: false,
    texturesMode: true,
    shader: 0,
    particleRect: [vec3.fromValues(-1, -1, 0), vec3.fromValues(-1, 1, 0), vec3.fromValues(1, 1, 0), vec3.fromValues(1, -1, 0), vec3.fromValues(1, 0, 0), vec3.fromValues(0, 1, 0), vec3.fromValues(0, 0, 1)],
    particleBillboardedRect: [vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create()],
    gl: gl,
    debugMode: debugMode,
    teamColors: teamColors,
    shaders: shaders,
    cameraPosition: cameraPosition,
    lightPosition: lightPosition,
    loadInternalResource: loadInternalResource
  };
  
  function saveContext() {
    var camera = context.camera,
          translation = Array.setFloatPrecision(camera[0], 0),
          rotation = Array.setFloatPrecision(Array.toDeg(camera[1]), 0);
    
    return [
      context.frameTime / 1000 * 60,
      [translation, rotation],
      context.instanceCamera,
      context.worldMode,
      context.groundSize,
      context.meshesMode &amp; 1,
      context.polygonMode &amp; 1,
      context.teamColorsMode &amp; 1,
      context.boundingShapesMode &amp; 1,
      context.texturesMode &amp; 1,
      context.shader
    ];
  }
  
  function loadContext(object) {
    var camera = object[1],
          translation = camera[0],
          rotation = Array.toRad(camera[1]);
    
    context.frameTime = object[0] / 60 * 1000;
    context.camera = [translation, rotation],
    context.instanceCamera = object[2];
    context.worldMode = object[3];
    setGroundSize(object[4] * 2);
    context.meshesMode = !!object[5];
    context.polygonMode = !!object[6];
    context.teamColorsMode = !!object[7];
    context.boundingShapesMode = !!object[8];
    context.texturesMode = !!object[9];
    context.shader = object[10];
  }/**
 * Creates a new AsyncModel.
 *
 * @class The parent of {@link BaseModel}. Takes care of all the asynchronous aspects of loading models.
 * @name AsyncModel
 * @mixes Async
 * @param {string} source The source url that this model will be loaded from.
 * @param {number} id The id of this model.
 * @param {object} textureMap An object with texture path -> absolute urls mapping.
 */
function AsyncModel(source, id, textureMap) {
  this.ready = false;
  this.fileType = getFileExtension(source).toLowerCase();
  this.isModel = true;
  this.id = id;
  this.source = source;
  
  // All the instances owned by this model
  this.instances = [];
  
  this.setupAsync();
  
  getFile(source, !!AsyncModel.handlers[this.fileType][1], this.setup.bind(this, textureMap || {}), onerror.bind(undefined, this), onprogress.bind(undefined, this));
}

AsyncModel.handlers = {};

AsyncModel.prototype = {
  /**
    * Setup a model once it finishes loading.
    *
    * @memberof AsyncModel
    * @instance
    * @param {object} textureMap An object with texture path -> absolute urls mapping.
    * @param {XMLHttpRequestProgressEvent} e The XHR event.
    */
  setup: function (textureMap, e) {
    var status = e.target.status;
    
    if (status === 200) {
      var model = new AsyncModel.handlers[this.fileType][0](e.target.response, textureMap, context, onerror.bind(undefined, {isModel: 1, source: this.source, id: this.id}));
      
      if (context.debugMode) {
          console.log(model);
      }
      
      if (model.ready) {
        this.model = model;
        this.ready = true;
      
        this.runActions();
        
        onload(this);
      }
    } else {
      onerror(this, "" + status);
    }
  },
 
  /**
    * Request a model to setup a model instance.
    *
    * @memberof AsyncModel
    * @instance
    * @param {AsyncModelInstance} instance The requester.
    * @param {object} textureMap The requester's texture map.
    */
  setupInstance: function (instance, textureMap) {
    if (this.ready) {
      this.instances.push(instance);
      
      instance.setup(this.model, textureMap);
    } else {
      this.addAction("setupInstance", arguments);
    }
  },
  
  /**
    * Gets the name of a model.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {string} The model's name.
    */
  getName: function () {
    if (this.ready) {
      return this.model.getName();
    }
  },
  
  /**
    * Gets the source that a model was loaded from.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {string} The model's source.
    */
  getSource: function () {
    return this.source;
  },
  
  /**
    * Gets a model's attachment.
    *
    * @memberof AsyncModel
    * @instance
    * @param {number} id The id of the attachment.
    * @returns {Node} The attachment.
    */
  getAttachment: function (id) {
    if (this.ready) {
      return this.model.getAttachment(id);
    }
  },
  
  /**
    * Gets a model's camera.
    *
    * @memberof AsyncModel
    * @instance
    * @param {number} id The id of the camera.
    * @returns {Camera} The camera.
    */
  getCamera: function (id) {
    if (this.ready) {
      return this.model.getCamera(id);
    }
  },
  
  /**
    * Overrides a texture used by a model.
    *
    * @memberof AsyncModel
    * @instance
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  overrideTexture: function (path, override) {
    if (this.ready) {
      this.model.overrideTexture(path, override);
    } else {
      this.addAction("overrideTexture", arguments);
    }
  },
  
  /**
    * Gets a model's texture map.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {object} The texture map.
    */
  getTextureMap: function () {
    if (this.ready) {
      return this.model.getTextureMap();
    }
  },
  
  /**
    * Gets a model's sequences list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of sequence names.
    */
  getSequences: function () {
    if (this.ready) {
      return this.model.getSequences();
    }
  },
  
  /**
    * Gets a model's attachments list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of attachment names.
    */
  getAttachments: function () {
    if (this.ready) {
      return this.model.getAttachments();
    }
  },
  
  /**
    * Gets a model's bounding shapes list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of bounding shape names.
    */
  getBoundingShapes: function () {
    if (this.ready) {
      return this.model.getBoundingShapes();
    }
  },
  
  /**
    * Gets a model's cameras list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of camera names.
    */
  getCameras: function () {
    if (this.ready) {
      return this.model.getCameras();
    }
  },
  
  /**
    * Gets a model's number of meshes.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {number} The number of meshes.
    */
  getMeshCount: function () {
    if (this.ready) {
      return this.model.getMeshCount();
    }
  },
  
  /**
    * Gets a list of instances that a model owns.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The instance list.
    */
  getInstances: function () {
    if (this.ready) {
      var i,
            l,
            instances = this.instances,
            instance,
            ids = [];
      
      for (i = 0, l = instances.length; i &lt; l; i++) {
        instance = instances[i];
        
        if (instance.ready) {
          ids.push(instance.id);
        }
      }
      
      return ids;
    }
  },
  
  /**
    * Gets a model's information. This includes most of the getters.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {object} The model information.
    */
  getInfo: function () {
    if (this.ready) {
      var model = this.model;
      
      return {
        name: model.getName(),
        source: this.source,
        attachments: model.getAttachments(),
        sequences: model.getSequences(),
        cameras: model.getCameras(),
        textureMap: model.getTextureMap(),
        boundingShapes: model.getBoundingShapes(),
        meshCount: model.getMeshCount(),
        instances: this.getInstances()
      };
    }
  },
  
  /**
    * Gets a model's representation as an object that will be converted to JSON.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {object} The JSON representation.
    */
  toJSON: function () {
    var textureMap = {},
          localTextureMap = this.getTextureMap(),
          keys = Object.keys(localTextureMap),
          key,
          i,
          l;
    
    // This code avoids saving redundant texture paths.
    // Only textures that have been overriden are saved.
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      if (urls.mpqFile(key) !== localTextureMap[key]) {
        textureMap[key] = localTextureMap[key];
      }
    }
    
    return [
      this.id,
      this.source,
      textureMap
    ];
  },
  
  fromJSON: function (object) {
    
  }
};

mixin(Async, AsyncModel.prototype);/**
 * Creates a new AsyncModelInstance.
 *
 * @class The parent of {@link BaseModelInstance}. Takes care of all the asynchronous aspects of loading model instances. 
 * @name AsyncModelInstance
 * @mixes Async
 * @mixes Spatial
 * @param {AsyncModel} model The model this instance points to.
 * @param {number} id The id of this instance.
 * @param {vec3} color The color this instance uses for {@link AsyncModelInstance.renderColor}.
 * @param {object} textureMap An object with texture path -> absolute urls mapping.
 */
function AsyncModelInstance(asyncModel, id, color, textureMap) {
  this.ready = false;
  this.fileType = asyncModel.fileType;
  this.isInstance = true;
  this.asyncModel = asyncModel;
  this.id = id;
  
  this.source = asyncModel.source;
  this.visible = 1;
  
  // Used for color picking
  this.color = color;
  
  // If the model is already ready, the onload message from setup() must be delayed, since this instance wouldn't be added to the cache yet.
  if (asyncModel.ready) {
    this.delayOnload = true;
  }
  
  this.setupAsync();
  this.setupSpatial();
  
  // Request the setup function to be called by the model when it can.
  // If the model is loaded, setup runs instantly, otherwise it runs when the model finishes loading.
  asyncModel.setupInstance(this, textureMap || {});
}

AsyncModelInstance.handlers = {};

AsyncModelInstance.prototype = {
  /**
    * Setup a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {BaseModel} model The model implementation this instance points to.
    * @param {object} textureMap An object with texture path -> absolute urls mapping.
    */
  setup: function (model, textureMap) {
    this.instance = new AsyncModelInstance.handlers[this.fileType](model, textureMap, context);
    
    this.ready = true;
    
    this.runActions();
    
    this.recalculateTransformation();
    
    if (!this.delayOnload) {
      onload(this);
    }
    
    if (context.debugMode) {
      console.log(this.instance);
    }
  },
  
  /**
    * Updates a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  update: function (context) {
    if (this.ready) {
      this.instance.update(this.getTransformation(), context);
    }
  },
  
  /**
    * Render a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  render: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.render(context);
    }
  },
  
  /**
    * Render the particle emitters of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderEmitters: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderEmitters(context);
    }
  },
  
  /**
    * Render the bounding shapes of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderBoundingShapes: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderBoundingShapes(context);
    }
  },
  
  /**
    * Render a model instance with a specific color.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderColor: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderColor(this.color, context);
    }
  },
  
  /**
    * Gets the name of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {string} The instance's name.
    */
  getName: function () {
    if (this.ready) {
      return this.instance.getName() + "[" + this.id + "]";
    }
  },
  
  /**
    * Gets the source of the model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {string} The model's source.
    */
  getSource: function () {
    return this.asyncModel.source;
  },
  
  // Sets the parent value of a requesting Spatial.
  setRequestedAttachment: function (requester, attachment) {
    requester.setParentNode(this.instance.getAttachment(attachment));
  },
  
  requestAttachment: function (requester, attachment) {
    if (this.ready) {
      return this.setRequestedAttachment(requester, attachment);
    } else {
      this.addAction("setRequestedAttachment", [requester, attachment]);
    }
  },
  
  /**
    * Overrides a texture used by a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  overrideTexture: function (path, override) {
    if (this.ready) {
      this.instance.overrideTexture(path, override);
    } else {
      this.addAction("overrideTexture", [path, override]);
    }
  },
  
  /**
    * Gets a model instance's texture map.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The texture map.
    */
  getTextureMap: function () {
    if (this.ready) {
      return this.instance.getTextureMap();
    }
  },
  
  /**
    * Set the team color of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The team color.
    */
  setTeamColor: function (id) {
    if (this.ready) {
      this.instance.setTeamColor(id);
    } else {
      this.addAction("setTeamColor", [id]);
    }
  },
  
  /**
    * Gets the team color of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The team.
    */
  getTeamColor: function () {
    if (this.ready) {
      return this.instance.getTeamColor();
    }
  },
  
  /**
    * Set the sequence of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The sequence.
    */
  setSequence: function (id) {
    if (this.ready) {
      this.instance.setSequence(id);
    } else {
      this.addAction("setSequence", [id]);
    }
  },
  
  /**
    * Gets the sequence of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The sequence.
    */
  getSequence: function () {
    if (this.ready) {
      return this.instance.getSequence();
    }
  },
  
  /**
    * Set the sequence loop mode of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} mode The sequence loop mode.
    */
  setSequenceLoopMode: function (mode) {
    if (this.ready) {
      this.instance.setSequenceLoopMode(mode);
    } else {
      this.addAction("setSequenceLoopMode", [mode]);
    }
  },
  
  /**
    * Gets the sequence loop mode of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The sequence loop mode.
    */
  getSequenceLoopMode: function () {
    if (this.ready) {
      return this.instance.getSequenceLoopMode();
    }
  },
  
  /**
    * Gets a model instance's attachment.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The id of the attachment.
    * @returns {Node} The attachment.
    */
  getAttachment: function (id) {
    if (this.ready) {
      return this.instance.getAttachment(id);
    }
  },
  
  /**
    * Gets a model instance's camera.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The id of the camera.
    * @returns {Camera} The camera.
    */
  getCamera: function (id) {
    if (this.ready) {
      return this.instance.getCamera(id);
    }
  },
  
  /**
    * Set a model instance's mesh's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @param {boolean} mode The visibility mode
    */
  setMeshVisibility: function (id, mode) {
    if (this.ready) {
      this.instance.setMeshVisibility(id, mode);
    } else {
      this.addAction("setMeshVisibility", [id, mode]);
    }
  },
  
  /**
    * Gets a model instance's mesh's visibility
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @returns {boolean} The mesh's visiblity.
    */
  getMeshVisibility: function (id) {
    if (this.ready) {
      return this.instance.getMeshVisibility(id);
    }
  },
  
  /**
    * Gets a model instance's mesh's visibility
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @returns {boolean} The mesh's visiblity.
    */
  getMeshVisibilities: function () {
    if (this.ready) {
      return this.instance.getMeshVisibilities();
    }
  },
  
  /**
    * Gets the sequences of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of sequence names.
    */
  getSequences: function () {
    if (this.ready) {
      return this.asyncModel.getSequences();
    }
  },
  
  /**
    * Gets the attachments of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of attachment names.
    */
  getAttachments: function () {
    if (this.ready) {
      return this.asyncModel.getAttachments();
    }
  },
  
  /**
    * Gets the bounding shapes of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of bounding shape names.
    */
  getBoundingShapes: function() {
    if (this.ready) {
      return this.asyncModel.getBoundingShapes();
    }
  },
  
  /**
    * Gets the cameras of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of camera names.
    */
  getCameras: function () {
    if (this.ready) {
      return this.asyncModel.getCameras();
    }
  },
  
  /**
    * Gets the number of meshes of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The number of meshes.
    */
  getMeshCount: function () {
    if (this.ready) {
      return this.asyncModel.getMeshCount();
    }
  },
  
  /**
    * Sets a model instance's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {boolean} mode The visibility.
    */
  setVisibility: function (mode) {
    this.visible = mode;
  },
  
  /**
    * Gets a model instance's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {boolean} The visibility.
    */
  getVisibility: function () {
    return this.visible;
  },
  
  /**
    * Gets a model instance's information. This includes most of the getters, and also the information from {@link AsyncModel.getInfo}.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The model instance information.
    */
  getInfo: function () {
    return {
      modelInfo: this.asyncModel.getInfo(),
      visible: this.getVisibility(),
      sequence: this.getSequence(),
      sequenceLoopMode: this.getSequenceLoopMode(),
      location: this.getLocation(),
      rotation: this.getRotation(),
      rotationQuat: this.getRotationQuat(),
      scale: this.getScale(),
      parent: this.getParent(),
      teamColor: this.getTeamColor(),
      textureMap: this.getTextureMap(),
      meshVisibilities: this.getMeshVisibilities(),
      name: this.getName()
    };
  },
  
  /**
    * Gets a model instance's representation as an object that will be converted to JSON.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The JSON representation.
    */
  toJSON: function () {
    // For some reason, when typed arrays are JSON stringified they change to object notation rather than array notation.
    // This is why I don't bother to access the location and rotation directly.
    var location = this.getLocation(),
          rotation = Array.toDeg(this.getRotation()),
          scale = this.getScale(),
          textureMap = {},
          localTextureMap = this.getTextureMap(),
          modelTextureMap = this.asyncModel.getTextureMap(),
          keys = Object.keys(localTextureMap),
          key,
          i,
          l,
          visibilities = this.getMeshVisibilities();
          
    // This code avoids saving instance overrides that match the model's texture map.
    // For example, when the client overrides a texture and then sets it back to the original value.
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      if (localTextureMap[key] !== modelTextureMap[key]) {
        textureMap[key] = localTextureMap[key];
      }
    }
    
    // To avoid silly numbers like 1.0000000000000002
    location = Array.setFloatPrecision(location, 2);
    rotation = Array.setFloatPrecision(rotation, 0);
    scale = Math.setFloatPrecision(scale, 2);
    
    // Turn booleans to numbers to shorten the string.
    for (i = 0, l = visibilities.length; i &lt; l; i++) {
      visibilities[i] = visibilities[i] &amp; 1;
    }
    
    return [
      this.id,
      this.asyncModel.id,
      this.getVisibility() &amp; 1,
      this.getSequence(),
      this.getSequenceLoopMode(),
      location,
      rotation,
      scale,
      this.getParent(),
      this.getTeamColor(),
      textureMap,
      visibilities
    ];
  },
  
  /**
    * Applies the settings of a JSON representation to a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @object {object} The JSON representation.
    */
  fromJSON: function (object) {
    var textureMap = object[10],
          visibilities = object[11],
          keys = Object.keys(textureMap),
          key,
          i,
          l;
          
    this.setVisibility(!!object[2]);
    this.setSequence(object[3]);
    this.setSequenceLoopMode(object[4]);
    this.setLocation(object[5]);
    this.rotate(Array.toRad(object[6]));
    this.setScale(object[7]);
    this.setTeamColor(object[9]);
    
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      this.overrideTexture(key, textureMap[key]);
    }
    
    for (i = 0, l = visibilities.length; i &lt; l; i++) {
      this.setMeshVisibility(i, visibilities[i]);
    }
  }
};

mixin(Async, AsyncModelInstance.prototype);
mixin(Spatial, AsyncModelInstance.prototype);function setupColor(width, height) {
    // Color texture
    var color = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, color);
    gl.textureOptions(ctx.REPEAT, ctx.REPEAT, ctx.NEAREST, ctx.NEAREST);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, width, height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    
    // Depth render buffer
    var depth = ctx.createRenderbuffer();
    ctx.bindRenderbuffer(ctx.RENDERBUFFER, depth);
    ctx.renderbufferStorage(ctx.RENDERBUFFER, ctx.DEPTH_COMPONENT16, width, height);
    
    // FBO
    var fbo = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, fbo);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, color, 0);
    ctx.framebufferRenderbuffer(ctx.FRAMEBUFFER, ctx.DEPTH_ATTACHMENT, ctx.RENDERBUFFER, depth);
  
    ctx.bindTexture(ctx.TEXTURE_2D, null);
    ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
    
    return fbo;
  }
  
  // Used for color picking
  //var colorFBO = setupColor(512, 512);
  
  function resetViewport() {
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    
    ctx.viewport(0, 0, width, height);
    gl.setPerspective(45, width / height, 0.1, 5E4);
  }
  
  resetViewport();
  
  addEvent(window, "resize", resetViewport);
  
  resetCamera();
      
  gl.createShader("world", SHADERS.vsworld, SHADERS.psworld);
  gl.createShader("white", SHADERS.vswhite, SHADERS.pswhite);
  
  gl.loadTexture(grassPath);
  gl.loadTexture(waterPath);
  gl.loadTexture(bedrockPath);
  gl.loadTexture(skyPath);
  
  grass_water = gl.createRect(0, 0, -3, context.groundSize, context.groundSize, 6);
  bedrock = gl.createRect(0, 0, -35, context.groundSize, context.groundSize, 6);
  sky = gl.createSphere(0, 0, 0, 5, 40, 2E3);
  
  function updateParticleRect() {
    for (var i = 0; i &lt; 7; i++) {
      vec3.transformMat4(context.particleBillboardedRect[i], context.particleRect[i], inverseCameraRotation);
    }
  }
  
  function transformCamera() {
    mat4.identity(cameraMatrix);
    mat4.identity(inverseCameraRotation);
    
    if (context.instanceCamera[1] === -1) {
      var z = context.camera[1][1];
      var x = context.camera[1][0];

      mat4.translate(cameraMatrix, cameraMatrix, context.camera[0]);
      mat4.rotate(cameraMatrix, cameraMatrix, x, vec3.UNIT_X);
      mat4.rotate(cameraMatrix, cameraMatrix, z, vec3.UNIT_Z);
      
      mat4.rotate(inverseCameraRotation, inverseCameraRotation, -z, vec3.UNIT_Z);
      mat4.rotate(inverseCameraRotation, inverseCameraRotation, -x, vec3.UNIT_X);
      
      mat4.invert(inverseCamera, cameraMatrix);
      vec3.transformMat4(cameraPosition, vec3.UNIT_Z, inverseCamera);
    } else {
      var instance = modelInstanceMap[context.instanceCamera[0]];
      
      if (instance) {
        var cam = instance.getCamera(context.instanceCamera[1]);
        
        if (cam) {
          var targetPosition = cam.targetPosition;
          
          mat4.lookAt(cameraMatrix, cam.position, targetPosition, upDir);
          mat4.toRotationMat4(inverseCameraRotation, cameraMatrix);
          
          cameraPosition[0] = targetPosition[0];
          cameraPosition[1] = targetPosition[1];
          cameraPosition[2] = targetPosition[2];
        }
      }
    }
    
    gl.loadIdentity();
    gl.multMat(cameraMatrix);
  }
  
  function update() {
    for (var i = 0, l = instanceArray.length; i &lt; l; i++) {
      instanceArray[i].update(context);
    }
    
    transformCamera();
    
    updateParticleRect();
  }
  
  function renderGround(isWater) {
    if (context.worldMode > 1 &amp;&amp; gl.shaderStatus("world")) {
      var shader = gl.bindShader("world");
      
      ctx.disable(ctx.CULL_FACE);
      
      ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
      
      if (isWater) {
        uvOffset[0] += uvSpeed[0];
        uvOffset[1] += uvSpeed[1];
        
        ctx.uniform2fv(shader.variables.u_uv_offset, uvOffset);
        ctx.uniform1f(shader.variables.u_a, 0.6);
      } else {
        ctx.uniform2fv(shader.variables.u_uv_offset, [0, 0]);
        ctx.uniform1f(shader.variables.u_a, 1);
      }
      
      if (context.worldMode > 2) {
        if (isWater) {
          ctx.enable(ctx.BLEND);
          ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
          
          gl.bindTexture(waterPath, 0);
          grass_water.render(shader);
          
          ctx.disable(ctx.BLEND);
        } else {
          gl.bindTexture(bedrockPath, 0);
          bedrock.render(shader);
        }
      } else {
        gl.bindTexture(grassPath, 0);
        grass_water.render(shader);
      }
    }
  }
  
  function renderSky() {
    if (context.worldMode > 0 &amp;&amp; gl.shaderStatus("world")) {
      var shader = gl.bindShader("world");
      
      ctx.uniform2fv(shader.variables.u_uv_offset, [0, 0]);
      ctx.uniform1f(shader.variables.u_a, 1);
      ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getProjectionMatrix());
      
      gl.bindTexture(skyPath, 0);
      sky.render(shader);
    }
  }
  
  function render() {
    var i,
          l = instanceArray.length;
    
    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
    
    renderSky();
    renderGround();
    
    // Render geometry
    if (context.meshesMode) {
      for (i = 0; i &lt; l; i++) {
        instanceArray[i].render(context);
      }
    }
    
    // Render particles
    if (context.emittersMode) {
      for (i = 0; i &lt; l; i++) {
        instanceArray[i].renderEmitters(context);
      }
    }
    
    // Render bounding shapes
    if (context.boundingShapesMode) {
      for (i = 0; i &lt; l; i++) {
        instanceArray[i].renderBoundingShapes(context);
      }
    }
    
    if (context.worldMode > 2) {
      renderGround(true);
    }
  }
  
  function renderColor() {
    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
    
    ctx.disable(ctx.CULL_FACE);
    
    for (var i = 0, l = instanceArray.length; i &lt; l; i++) {
      instanceArray[i].renderColor(context);
    }
    
    ctx.enable(ctx.CULL_FACE);
  }
  
  // The main loop of the viewer
  function step() {
    update();
    render();
    
    requestAnimationFrame(step);
  }

  step();
  
  // Generate a unique color
  var generateColor = (function () {
    var index = 1;
    
    return function () {
      var a = index % 10;
      var b = Math.floor(index / 10) % 10;
      var c = Math.floor(index / 100) % 10;
      
      index += 1;
      
      return [a / 10, b / 10, c / 10];
    };
  }());
  
  function colorString(color) {
    var r = Math.floor(color[0] * 255);
    var g = Math.floor(color[1] * 255);
    var b = Math.floor(color[2] * 255);
    
    return "" + r + g + b;
  }
  
  function loadModel(source, textureMap) {
    if (!modelMap[source]) {
      var object;
      
      idFactory += 1;
      object = new AsyncModel(source, idFactory, textureMap);
      
      modelMap[source] = object;
      modelArray.push(object);
      modelInstanceMap[idFactory] = object;
      
      onloadstart(object);
    }
    
    return modelMap[source];
  }
  
  function loadInstance(source, hidden) {
    var object,
          color = generateColor();
    
    idFactory += 1;
    object = new AsyncModelInstance(modelMap[source], idFactory, color);
    
    if (hidden) {
      object.setVisibility(false);
    }
    
    modelInstanceMap[idFactory] = object;
    instanceArray.push(object);
    instanceMap[colorString(color)] = object;
    
    if (object.delayOnload) {
      onload(object);
    }
    
    return object;
  }
  
  // Load a model or texture from an absolute url, with an optional texture map, and an optional hidden parameter
  function loadResourceImpl(source, textureMap, hidden) {
    var fileType = getFileExtension(source).toLowerCase();
    
    if (supportedModelFileTypes[fileType]) {
      loadModel(source, textureMap);
      loadInstance(source, hidden);
    } else {
      gl.loadTexture(source);
    }
  }
  
  function loadResourceFromId(e) {
    var status = e.target.status;
    
    if (status === 200) {
      onload(this);
      
      var i, l;
      var object = JSON.parse(e.target.responseText);
      var keys = Object.keys(object.textures);
      var textureMap = {};
      
      if (context.debugMode) {
        console.log(object);
      }
      
      for (i = 0, l = keys.length; i &lt; l; i++) {
        var key = keys[i];
        var texture = object.textures[key];
        
        textureMap[key] = texture.url;
        
        gl.loadTexture(textureMap[key]);
      }
      
      var models = object.models;
      
      for (i = 0, l = object.models.length; i &lt; l; i++) {
        loadResourceImpl(models[i].url, textureMap, models[i].hidden);
      }
    }
  }
  
  function unloadInstance(instance, unloadingModel) {
    var i,
          l,
          instances = instance.asyncModel.instances;
    
    // Remove from the instance array
    for (i = 0, l = instanceArray.length; i &lt; l; i++) {
      if (instanceArray[i] === instance) {
        instanceArray.splice(i, 1);
      }
    }
    
    // Remove from the instance map
    delete instanceMap[colorString(instance.color)];
    
    // Remove from the model-instance map
    delete modelInstanceMap[instance.id];
    
    // Don't remove from the model if the model itself is unloaded
    if (!unloadingModel) {
      // Remove from the instances list of the owning model
      for (i = 0, l = instances.length; i &lt; l; i++) {
        if (instances[i] === instance) {
          instances.splice(i, 1);
        }
      }
    }
    
    onunload(instance);
  }
  
  function unloadModel(model) {
    var i,
          l,
          instances = model.instances;
    
    // Remove all instances owned by this model
    for (i = 0, l = instances.length; i &lt; l; i++) {
      unloadInstance(instances[i], true);
    }
    
    // Remove from the model array
    for (i = 0, l = modelArray.length; i &lt; l; i++) {
      if (modelArray[i] === model) {
        modelArray.splice(i, 1);
      }
    }
    
    // Remove from the model-instance map
    delete modelInstanceMap[model.id];
    
    onunload(model);
  }
  
  // ---------------------
  // Model loading API
  // ---------------------
  
  /**
    * Loads a resource.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} source The source to load from. Can be an absolute url, a path to a file in the MPQ files of Warcraft 3 and Starcraft 2, or a form of identifier to be used for headers.
    */
  function loadResource(source) {
    var isSupported = supportedFileTypes[getFileExtension(source).toLowerCase()];
    
    if (source.startsWith("http://") &amp;&amp; isSupported) {
      loadResourceImpl(source);
    } else if (isSupported) {
      loadResourceImpl(urls.mpqFile(source));
    } else {
      var object = {isHeader: 1, source: source};
      
      onloadstart(object);
      
      getFile(urls.header(source), false, loadResourceFromId.bind(object), onerror.bind(undefined, object), onprogress.bind(undefined, object));
    }
  }
  
  /**
    * Unloads a resource.
    *
    * @memberof ModelViewer
    * @instance
    * @param {(string|number)} source The source to unload from. Can be the source of a previously loaded resource, or a valid model or instance ID.
    */
  function unloadResource(source) {
    var object;
    
    if (typeof source === "number") {
      object = modelInstanceMap[source];
      
      if (object &amp;&amp; object.ready) {
        if (object.isModel) {
          unloadModel(object);
        } else {
          unloadInstance(object);
        }
      }
    } else {
      object = modelMap[source];
      
      if (object) {
        if (object.ready) {
          unloadModel(object);
        }
      } else {
        gl.unloadTexture(source);
      }
    }
  }
  
  // ------------------
  // Instance visibility
  // ------------------
  
  /**
    * Sets the visiblity of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {boolean} mode The visibility mode.
    */
  function setVisibility(objectId, mode) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setVisibility(mode);
    }
  }
  
  /**
    * Gets the visiblity of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {boolean} The visibility mode.
    */
  function getVisibility(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getVisibility();
    }
  }
  
  /**
    * Sets the visiblity of a model instance's mesh.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} meshId The ID of the mesh.
    * @param {boolean} mode The visibility mode.
    */
  function setMeshVisibility(objectId, meshId, mode) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.setMeshVisibility(meshId, mode);
    }
  }
  
  /**
    * Gets the visiblity of a model instance's mesh.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} meshId The ID of the mesh.
    * @return {boolean} The visibility mode.
    */
  function getMeshVisibility(objectId, meshId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getMeshVisibility(meshId);
    }
  }
  
  // ------------------
  // Transform API
  // ------------------
  
  /**
    * Sets the location of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v The location.
    */
  function setLocation(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setLocation(v);
    }
  }
  
  /**
    * Moves a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v The displacement.
    */
  function move(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.move(v);
    }
  }
  
  /**
    * Gets the location of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {vec3} The location.
    */
  function getLocation(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getLocation();
    }
  }
  
  /**
    * Sets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v A vector of euler angles.
    */
  function setRotation(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setRotation(v);
    }
  }
  
  /**
    * Rotates a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v A vector of euler angles.
    */
  function rotate(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.rotate(v);
    }
  }
  
  /**
    * Gets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {vec3} A vector of euler angles.
    */
  function getRotation(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getRotation();
    }
  }
  
  /**
    * Sets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {quat} v A quaternion.
    */
  function setRotationQuat(objectId, q) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setRotationQuat(quat.normalize(q, q));
    }
  }
  
  /**
    * Rotates a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {quat} v A quaternion.
    */
  function rotateQuat(objectId, q) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.rotate(quat.normalize(q, q));
    }
  }
  
  /**
    * Gets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {quat} A quaternion.
    */
  function getRotationQuat(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getRotationQuat();
    }
  }
  
  /**
    * Sets the scale of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} n The scale factor.
    */
  function setScale(objectId, n) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setScale(n);
    }
  }
  
  /**
    * Scales a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} n The scale factor.
    */
  function scale(objectId, n) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.scale(n);
    }
  }
  
  /**
    * Gets the scale of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} The scale factor.
    */
  function getScale(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getScale();
    }
  }
  
  /**
    * Sets the parent of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} parentId The ID of the parent model instance.
    * @param {number} [attachmentId] The ID of an attachment owned by the parent.
    */
  function setParent(objectId, parentId, attachmentId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      if (parentId === -1) {
        object.setParent();
      } else {
        var parent = modelInstanceMap[parentId];
        
        if (parent &amp;&amp; parent.isInstance) {
          object.setParent(parent, attachmentId);
        }
      }
    }
  }
  
  /**
    * Gets the parent of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {array} The parent and attachment IDs as an array.
    */
  function getParent(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getParent();
    }
  }
  
  // -----------------------------
  // Team colors and textures
  // -----------------------------
  
  /**
    * Sets the team color of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} teamID The team color.
    */
  function setTeamColor(objectId, teamId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setTeamColor(teamId);
    }
  }
  
  /**
    * Gets the team color of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} The team color.
    */
  function getTeamColor(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getTeamColor();
    }
  }
  
  /**
    * Overrides a texture of a model or model instance.
    * If overriding the texture of a model, it will affect all of its instances who don't explicitly override this texture too.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  function overrideTexture(objectId, path, override) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      object.overrideTexture(path, override);
    }
  }
  
  /**
    * Gets the texture map of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {object} The texture map.
    */
  function getTextureMap(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getTextureMap();
    }
  }
  
  // ------------
  // Sequences
  // ------------
  
  /**
    * Sets the sequence of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} sequenceId The sequence.
    */
  function setSequence(objectId, sequenceId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setSequence(sequenceId);
    }
  }
  
  /**
    * Stops the sequence of a model instance.
    * Equivalent to setSequence(objectId, -1).
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    */
  function stopSequence(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setSequence(-1);
    }
  }
  
  /**
    * Gets the sequence of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} The sequence.
    */
  function getSequence(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getSequence();
    }
  }
  
  /**
    * Sets the sequence loop mode of a model instance.
    * Possible values are 0 for default, 1 for never loop, and 2 for always loop.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} mode The loop mode.
    */
  function setSequenceLoopMode(objectId, mode) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setSequenceLoopMode(mode);
    }
  }
  
  /**
    * Gets the sequence loop mode of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} sequenceId The loop mode.
    */
  function getSequenceLoopMode(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getSequenceLoopMode();
    }
  }
  
  // ----------
  // Getters
  // ----------
  
  /**
    * Gets all the information of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {object} The information.
    */
  function getInfo(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getInfo();
    }
  }
  
  /**
    * Gets a model ID from a valid source or model instance ID.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} source The source.
    * @returns {number} The model ID.
    */
  function getModel(source) {
    var object;
    
    if (typeof source === "string") {
      object = modelMap[source];
    
      if (object) {
        return object.id;
      }
    } else {
      object = modelInstanceMap[source];
      
      if (object) {
        if (object.isInstance) {
          return object.asyncModel.id;
        }
        
        return source;
      }
    }
  }
  
  /**
    * Gets the source of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The source.
    */
  function getSource(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getSource();
    }
  }
  
  /**
    * Gets the sequence list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getSequences(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getSequences();
    }
  }
  
  /**
    * Gets the attachment list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getAttachments(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getAttachments();
    }
  }
  
  /**
    * Gets the camera list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getCameras(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getCameras();
    }
  }
  
  /**
    * Gets the bounding shape list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getBoundingShapes(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getBoundingShapes();
    }
  }
  
  /**
    * Gets the number of meshes a model or a model instance owns.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The number of meshes.
    */
  function getMeshCount(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getMeshCount();
    }
  }
  
  /**
    * Gets a list of all model instances that a model owns.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model.
    * @returns {number} The list.
    */
  function getInstances(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isModel) {
      return object.getInstances();
    }
  }
  
  // -------------------
  // General settings
  // -------------------
  
  /**
    * Sets the animation speed.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} ratio The speed.
    */
  function setAnimationSpeed(ratio) {
    context.frameTime = ratio / 60 * 1000;
  }
  
  /**
    * Gets the animation speed.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {number} The speed.
    */
  function getAnimationSpeed() {
    return context.frameTime / 1000 * 60;
  }
  
  /**
    * Sets the world mode.
    * Possible values are 0 for nothing, 1 for sky, 2 for sky and ground, and 3 for sky and water.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} mode The world mode.
    */
  function setWorldMode(mode) {
    context.worldMode = mode;
  }
  
  /**
    * Gets the world mode.
    * Possible values are 0 for nothing, 1 for sky, 2 for sky and ground, and 3 for sky and water.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} The world mode.
    */
  function getWorldMode() {
    return context.worldMode;
  }
  
  /**
    * Sets the ground size.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} size The ground size.
    */
  function setGroundSize(size) {
    size /= 2;
    
    context.groundSize = size;
    
    grass_water.resize(size, size);
    bedrock.resize(size, size);
  }
  
  /**
    * Gets the ground size.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {number} The ground size.
    */
  function getGroundSize() {
    return context.groundSize * 2;
  }
  
  /**
    * Sets the mesh mode. If false, no meshes will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setMeshesMode(mode) {
    context.meshesMode = mode;
  }
  
  /**
    * Gets the mesh mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getMeshesMode() {
    return context.meshesMode;
  }
  
  /**
    * Sets the particle emitters mode. If false, no particle emitters will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setEmittersMode(b) {
    context.emittersMode = b;
  }
  
  /**
    * Gets the particle emitters mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getEmittersMode() {
    return context.emittersMode;
  }
  
  /**
    * Sets the bounding shapes mode. If false, no bounding shapes will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setBoundingShapesMode(b) {
    context.boundingShapesMode = b;
  }
  
  /**
    * Gets the bounding shapes mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getBoundingShapesMode() {
    return context.boundingShapesMode;
  }
  
  /**
    * Sets the team colors mode. If false, no team colors will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setTeamColorsMode(b) {
    context.teamColorsMode = b;
  }
  
  /**
    * Gets the team colors mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getTeamColorsMode() {
    return context.teamColorsMode;
  }
  
  /**
    * Sets the polygon mode. If false, models will render as wireframe.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setPolygonMode(b) {
    context.polygonMode = b;
  }
  
  /**
    * Gets the polygon mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getPolygonMode() {
    return context.polygonMode;
  }
  
  /**
    * Sets the shader.
    * Possible values are 0 for `standard`, 1 for `diffuse`, 2 for `normals`, 3 for `uvs`, 4 for `normal map`, 5 for `specular map`, 6 for `specular map + normal map`, 7 for `emissive`, 8 for `unshaded`, 9 for `unshaded + normal map`, 10 for `decal`, and finally 11 for `white`.
    * Note: only the normals, uvs, and white shaders affect Warcraft 3 models, the rest only affect Starcraft 2 models.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} id The shader.
    */
  function setShader(id) {
    context.shader = id;
  }
  
  /**
    * Gets the shader.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {number} The shader.
    */
  function getShader() {
    return context.shader;
  }
  
  // -------------------
  // Camera settings
  // -------------------
  
  /**
    * Sets the camera.
    * If either of the arguments is -1, the normal free form camera is used.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} cameraId The camera.
    */
  function setCamera(objectId, cameraId) {
    context.instanceCamera[0] = objectId;
    context.instanceCamera[1] = cameraId;
  }
  
  /**
    * Gets the camera.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {array} The model instance ID and camera. If the free form camera is used, both will be -1.
    */
  function getCamera() {
    return [context.instanceCamera[0], context.instanceCamera[1]];
  }
  
  /**
    * Pans the camera on the x and y axes.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} x Amount to pan on the X axis.
    * @param {number} y Amount to pan on the Y axis.
    */
  function panCamera(x, y) {
    context.instanceCamera[1] = -1;
    context.camera[0][0] += x;
    context.camera[0][1] -= y;
  }
  
  /**
    * Rotates the camera on the x and y axes.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} x Amount to rotate on the X axis.
    * @param {number} y Amount to rotate on the Y axis.
    */
  function rotateCamera(x, y) {
    context.instanceCamera[1] = -1;
    context.camera[1][0] += Math.toRad(x);
    context.camera[1][1] += Math.toRad(y);
  }
  
  /**
    * Zooms the camera by a factor.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} n Zoom factor.
    */
  function zoomCamera(n) {
    context.instanceCamera[1] = -1;
    context.camera[0][2] = Math.floor(context.camera[0][2] * n);
  }
  
  /**
    * Resets the camera to the initial state.
    *
    * @memberof ModelViewer
    * @instance
    */
  function resetCamera() {
    context.instanceCamera[1] = -1;
    context.camera[0][0] = 0;
    context.camera[0][1] = 0;
    context.camera[0][2] = -300;
    context.camera[1] = [Math.toRad(315), Math.toRad(225)];
  }
  
  // ------
  // Misc
  // ------
  
  /**
    * Selects a model instance given a screen-space position.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} x X coordinate.
    * @param {number} y Y coordinate.
    * @returns {number} The ID of the selected model instance, or -1 if no model instance was selected.
    */
  function selectInstance(x, y) {
    //var date = new Date();
    var pixel = new Uint8Array(4);
    
    //var dx = canvas.clientWidth / 512;
    //var dy = canvas.clientHeight / 512;
    
    //console.log(x, y);
    //x = Math.round(x / dx);
    //y = canvas.height - y;
    //y = Math.round(y / dy);
    //console.log(x, y);
    
    //ctx.bindFramebuffer(ctx.FRAMEBUFFER, colorFBO);
    
    //ctx.viewport(0, 0, 512, 512);
    //gl.setPerspective(45, 1, 0.1, 5E4);
    
    renderColor();
    
    // The Y axis of the WebGL viewport is inverted compared to screen space
    y = canvas.clientHeight - y;
    
    ctx.readPixels(x, y, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, pixel);
    
    //ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
    
    //ctx.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
    //gl.setPerspective(45, canvas.clientWidth / canvas.clientHeight, 0.1, 5E4);
    
    //console.log(pixel);
    
    // WebGL sometimes rounds down and sometimes up, so this code takes care of that.
    // E.g.: 0.1*255 = 25.5, WebGL returns 25
    // E.g.: 0.5*255 = 127.5, WebGL returns 128
    var r = Math.floor(Math.round(pixel[0] / 25.5) * 25.5);
    var g = Math.floor(Math.round(pixel[1] / 25.5) * 25.5);
    var b = Math.floor(Math.round(pixel[2] / 25.5) * 25.5);
    
    var color = "" + r + g + b;
    var instance = instanceMap[color];
    
    //console.log("selectInstance", new Date() - date);
    
    if (instance) {
      return instance.id;
    }
    
    return -1;
  }
  
  /**
    * Saves the scene as a JSON string.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {string} The JSON string.
    */
  function saveScene() {
    var i, 
          l,
          models = [],
          instances = [],
          object;
    
    for (i = 0, l = modelArray.length; i &lt; l; i++) {
      object = modelArray[i];
      
      if (object.ready) {
        models.push(object);
      }
    }
    
    for (i = 0, l = instanceArray.length; i &lt; l; i++) {
      object = instanceArray[i];
      
      if (object.ready) {
        instances.push(object);
      }
    }
    
    return JSON.stringify([saveContext(), models, instances]);
  }
  
  /**
    * Loads a scene from JSON string.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} scene The JSON string.
    */
  function loadScene(scene) {
    var i,
          l,
          idMap = [], // Map from object IDs in the scene to actual indices in the object array.
          id,
          models,
          instances,
          object,
          owningModel,
          instance;
    
    scene = JSON.parse(scene);
    
    loadContext(scene[0]);
    
    models = scene[1];
    instances = scene[2];
    
    // Load all the models
    for (i = 0, l = models.length; i &lt; l; i++) {
      // object[0] = id
      // object[1] = source
      // object[2] = texture map
      object = models[i];
      
      loadModel(object[1], object[2]);
      
      idMap[object[0]] = idFactory;
    }
    
    // Load all the instances
    for (i = 0, l = instances.length; i &lt; l; i++) {
      // object[0] = id
      // object[1] = model id
      // ...
      object = instances[i];
      
      owningModel = modelInstanceMap[idMap[object[1]]];
      
      instance = loadInstance(owningModel.getSource());
      instance.fromJSON(object);
      
      idMap[object[0]] = idFactory;
    }
    
    // The parenting must be applied after all instances are loaded
    for (i = 0, l = instances.length; i &lt; l; i++) {
      // object[0] = id
      // object[8] = parent
      object = instances[i];
      parent = object[8];
      
      setParent(idMap[object[0]], idMap[parent[0]], parent[1]);
    }
  }
  
  /**
    * Registers external handlers for an unspported model type.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} fileType The file format the handlers handle.
    * @param {BaseModel} modelHandler A BaseModel-like object.
    * @param {BaseModelInstance} modelInstanceHandler A BaseModelInstance-like object.
    * @param {boolean} binary Determines what type of input the model handler will get - a string, or an ArrayBuffer.
    */
  function registerModelHandler(fileType, modelHandler, modelInstanceHandler, binary) {
    AsyncModel.handlers[fileType] = [modelHandler, binary];
    AsyncModelInstance.handlers[fileType] = modelInstanceHandler;
    
    supportedModelFileTypes[fileType] = 1;
    supportedFileTypes[fileType] = 1;
  }
  
  /**
    * Registers an external handler for an unsupported texture type.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} fileType The file format the handler handles.
    * @param {function} textureHandler
    */
  function registerTextureHandler(fileType, textureHandler) {
    gl.registerTextureHandler(fileType, textureHandler);
    
    supportedTextureFileTypes[fileType] = 1;
    supportedFileTypes[fileType] = 1;
  }
  
  return {
    // Resource API
    loadResource: loadResource,
    unloadResource: unloadResource,
    // Instance visibility
    setVisibility: setVisibility,
    getVisibility: getVisibility,
    setMeshVisibility: setMeshVisibility,
    getMeshVisibility: getMeshVisibility,
    // Transform API
    setLocation: setLocation,
    move: move,
    getLocation: getLocation,
    setRotation: setRotation,
    rotate: rotate,
    getRotation: getRotation,
    setRotationQuat: setRotationQuat,
    rotateQuat: rotateQuat,
    getRotationQuat: getRotationQuat,
    setScale: setScale,
    scale: scale,
    getScale: getScale,
    setParent: setParent,
    getParent: getParent,
    // Team colors and textures
    setTeamColor: setTeamColor,
    getTeamColor: getTeamColor,
    overrideTexture: overrideTexture,
    getTextureMap: getTextureMap,
    // Sequences
    setSequence: setSequence,
    stopSequence: stopSequence,
    getSequence: getSequence,
    setSequenceLoopMode: setSequenceLoopMode,
    // Information getters
    getInfo: getInfo,
    getModel: getModel,
    getSource: getSource,
    getSequences: getSequences,
    getAttachments: getAttachments,
    getCameras: getCameras,
    getBoundingShapes: getBoundingShapes,
    getMeshCount: getMeshCount,
    getInstances: getInstances,
    // General settings
    setAnimationSpeed: setAnimationSpeed,
    getAnimationSpeed: getAnimationSpeed,
    setWorldMode: setWorldMode,
    getWorldMode: getWorldMode,
    setGroundSize: setGroundSize,
    getGroundSize: getGroundSize,
    setMeshesMode: setMeshesMode,
    getMeshesMode: getMeshesMode,
    setEmittersMode: setEmittersMode,
    getEmittersMode: getEmittersMode,
    setBoundingShapesMode: setBoundingShapesMode,
    getBoundingShapesMode: getBoundingShapesMode,
    setTeamColorsMode: setTeamColorsMode,
    getTeamColorsMode: getTeamColorsMode,
    setPolygonMode: setPolygonMode,
    getPolygonMode: getPolygonMode,
    setShader: setShader,
    getShader: getShader,
    // Camera settings
    setCamera: setCamera,
    getCamera: getCamera,
    panCamera: panCamera,
    rotateCamera: rotateCamera,
    zoomCamera: zoomCamera,
    resetCamera: resetCamera,
    // Misc
    selectInstance: selectInstance,
    saveScene: saveScene,
    loadScene: loadScene,
    // Extending
    registerModelHandler: registerModelHandler,
    registerTextureHandler: registerTextureHandler
  };
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="AsyncModel.html">AsyncModel</a></li><li><a href="AsyncModelInstance.html">AsyncModelInstance</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BaseModelInstance.html">BaseModelInstance</a></li><li><a href="BaseNode.html">BaseNode</a></li><li><a href="BinaryReader.html">BinaryReader</a></li><li><a href="BLPTexture.html">BLPTexture</a></li><li><a href="Camera.html">Camera</a></li><li><a href="DDSTexture.html">DDSTexture</a></li><li><a href="GL.html">GL</a></li><li><a href="GL.Cube.html">Cube</a></li><li><a href="GL.Cylinder.html">Cylinder</a></li><li><a href="GL.NativeTexture.html">NativeTexture</a></li><li><a href="GL.Rect.html">Rect</a></li><li><a href="GL.Shader.html">Shader</a></li><li><a href="GL.ShaderUnit.html">ShaderUnit</a></li><li><a href="GL.Sphere.html">Sphere</a></li><li><a href="ModelViewer.html">ModelViewer</a></li><li><a href="Node.html">Node</a></li><li><a href="Texture.html">Texture</a></li><li><a href="TGATexture.html">TGATexture</a></li></ul><h3>Mixins</h3><ul><li><a href="Async.html">Async</a></li><li><a href="Spatial.html">Spatial</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bytesToString">bytesToString</a></li><li><a href="global.html#decodeFloat2">decodeFloat2</a></li><li><a href="global.html#decodeFloat3">decodeFloat3</a></li><li><a href="global.html#encodeFloat2">encodeFloat2</a></li><li><a href="global.html#encodeFloat3">encodeFloat3</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#getDom">getDom</a></li><li><a href="global.html#getFile">getFile</a></li><li><a href="global.html#getFileExtension">getFileExtension</a></li><li><a href="global.html#getFileName">getFileName</a></li><li><a href="global.html#getUrlVariables">getUrlVariables</a></li><li><a href="global.html#mixin">mixin</a></li><li><a href="global.html#peek">peek</a></li><li><a href="global.html#read">read</a></li><li><a href="global.html#readFloat32">readFloat32</a></li><li><a href="global.html#readFloat32Array">readFloat32Array</a></li><li><a href="global.html#readFloat32Matrix">readFloat32Matrix</a></li><li><a href="global.html#readFloat64">readFloat64</a></li><li><a href="global.html#readFloat64Array">readFloat64Array</a></li><li><a href="global.html#readFloat64Matrix">readFloat64Matrix</a></li><li><a href="global.html#readInt8">readInt8</a></li><li><a href="global.html#readInt8Array">readInt8Array</a></li><li><a href="global.html#readInt8Matrix">readInt8Matrix</a></li><li><a href="global.html#readInt16">readInt16</a></li><li><a href="global.html#readInt16Array">readInt16Array</a></li><li><a href="global.html#readInt16Matrix">readInt16Matrix</a></li><li><a href="global.html#readInt32">readInt32</a></li><li><a href="global.html#readInt32Array">readInt32Array</a></li><li><a href="global.html#readInt32Matrix">readInt32Matrix</a></li><li><a href="global.html#readMatrix">readMatrix</a></li><li><a href="global.html#readUint8">readUint8</a></li><li><a href="global.html#readUint8Array">readUint8Array</a></li><li><a href="global.html#readUint8Matrix">readUint8Matrix</a></li><li><a href="global.html#readUint16">readUint16</a></li><li><a href="global.html#readUint16Array">readUint16Array</a></li><li><a href="global.html#readUint16Matrix">readUint16Matrix</a></li><li><a href="global.html#readUint32">readUint32</a></li><li><a href="global.html#readUint32Array">readUint32Array</a></li><li><a href="global.html#readUint32Matrix">readUint32Matrix</a></li><li><a href="global.html#readVector2">readVector2</a></li><li><a href="global.html#readVector3">readVector3</a></li><li><a href="global.html#readVector4">readVector4</a></li><li><a href="global.html#remaining">remaining</a></li><li><a href="global.html#seek">seek</a></li><li><a href="global.html#skip">skip</a></li><li><a href="global.html#tell">tell</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Thu Oct 09 2014 23:21:20 GMT+0300 (Jerusalem Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
