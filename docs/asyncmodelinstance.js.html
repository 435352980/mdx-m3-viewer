<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: asyncmodelinstance.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: asyncmodelinstance.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Creates a new AsyncModelInstance.
 *
 * @class The parent of {@link BaseModelInstance}. Takes care of all the asynchronous aspects of loading model instances. 
 * @name AsyncModelInstance
 * @mixes Async
 * @mixes Spatial
 * @param {AsyncModel} model The model this instance points to.
 * @param {number} id The id of this instance.
 * @param {vec3} color The color this instance uses for {@link AsyncModelInstance.renderColor}.
 * @param {object} textureMap An object with texture path -> absolute urls mapping.
 */
function AsyncModelInstance(asyncModel, id, color, textureMap) {
  this.ready = false;
  this.fileType = asyncModel.fileType;
  this.isInstance = true;
  this.asyncModel = asyncModel;
  this.id = id;
  
  this.source = asyncModel.source;
  this.visible = 1;
  
  // Used for color picking
  this.color = color;
  
  // If the model is already ready, the onload message from setup() must be delayed, since this instance wouldn't be added to the cache yet.
  if (asyncModel.ready) {
    this.delayOnload = true;
  }
  
  this.setupAsync();
  this.setupSpatial();
  
  // Request the setup function to be called by the model when it can.
  // If the model is loaded, setup runs instantly, otherwise it runs when the model finishes loading.
  asyncModel.setupInstance(this, textureMap || {});
}

AsyncModelInstance.handlers = {};

AsyncModelInstance.prototype = {
  /**
    * Setup a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {BaseModel} model The model implementation this instance points to.
    * @param {object} textureMap An object with texture path -> absolute urls mapping.
    */
  setup: function (model, textureMap) {
    this.instance = new AsyncModelInstance.handlers[this.fileType](model, textureMap);
    
    this.ready = true;
    
    this.runActions();
    
    this.recalculateTransformation();
    
    if (!this.delayOnload) {
      onload(this);
    }
    
    if (context.debugMode) {
      console.log(this.instance);
    }
  },
  
  /**
    * Updates a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  update: function (context) {
    if (this.ready) {
      this.instance.update(this.getTransformation(), context);
    }
  },
  
  /**
    * Render a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  render: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.render(context);
    }
  },
  
  /**
    * Render the particle emitters of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderEmitters: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderEmitters(context);
    }
  },
  
  /**
    * Render the bounding shapes of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderBoundingShapes: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderBoundingShapes(context);
    }
  },
  
  /**
    * Render a model instance with a specific color.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderColor: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderColor(this.color, context);
    }
  },
  
  /**
    * Gets the name of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {string} The instance's name.
    */
  getName: function () {
    if (this.ready) {
      return this.instance.getName() + "[" + this.id + "]";
    }
  },
  
  /**
    * Gets the source of the model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {string} The model's source.
    */
  getSource: function () {
    return this.asyncModel.source;
  },
  
  // Sets the parent value of a requesting Spatial.
  setRequestedAttachment: function (requester, attachment) {
    requester.setParentNode(this.instance.getAttachment(attachment));
  },
  
  requestAttachment: function (requester, attachment) {
    if (this.ready) {
      return this.setRequestedAttachment(requester, attachment);
    } else {
      this.addAction("setRequestedAttachment", [requester, attachment]);
    }
  },
  
  /**
    * Overrides a texture used by a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  overrideTexture: function (path, override) {
    if (this.ready) {
      this.instance.overrideTexture(path, override);
    } else {
      this.addAction("overrideTexture", [path, override]);
    }
  },
  
  /**
    * Gets a model instance's texture map.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The texture map.
    */
  getTextureMap: function () {
    if (this.ready) {
      var textureMap = this.instance.getTextureMap();
      
      // Avoid reporting the team color textures, since they are internal.
      // Is there any nicer way to do this?
      delete textureMap["replaceabletextures/teamcolor/teamcolor00.blp"];
      delete textureMap["replaceabletextures/teamglow/teamglow00.blp"];
      
      return textureMap;
    }
  },
  
  /**
    * Set the team color of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The team color.
    */
  setTeamColor: function (id) {
    if (this.ready) {
      this.instance.setTeamColor(id);
    } else {
      this.addAction("setTeamColor", [id]);
    }
  },
  
  /**
    * Gets the team color of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The team.
    */
  getTeamColor: function () {
    if (this.ready) {
      return this.instance.getTeamColor();
    }
  },
  
  /**
    * Set the sequence of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The sequence.
    */
  setSequence: function (id) {
    if (this.ready) {
      this.instance.setSequence(id);
    } else {
      this.addAction("setSequence", [id]);
    }
  },
  
  /**
    * Gets the sequence of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The sequence.
    */
  getSequence: function () {
    if (this.ready) {
      return this.instance.getSequence();
    }
  },
  
  /**
    * Set the sequence loop mode of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} mode The sequence loop mode.
    */
  setSequenceLoopMode: function (mode) {
    if (this.ready) {
      this.instance.setSequenceLoopMode(mode);
    } else {
      this.addAction("setSequenceLoopMode", [mode]);
    }
  },
  
  /**
    * Gets the sequence loop mode of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The sequence loop mode.
    */
  getSequenceLoopMode: function () {
    if (this.ready) {
      return this.instance.getSequenceLoopMode();
    }
  },
  
  /**
    * Gets a model instance's attachment.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The id of the attachment.
    * @returns {Node} The attachment.
    */
  getAttachment: function (id) {
    if (this.ready) {
      return this.instance.getAttachment(id);
    }
  },
  
  /**
    * Gets a model instance's camera.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The id of the camera.
    * @returns {Camera} The camera.
    */
  getCamera: function (id) {
    if (this.ready) {
      return this.instance.getCamera(id);
    }
  },
  
  /**
    * Set a model instance's mesh's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @param {boolean} mode The visibility mode
    */
  setMeshVisibility: function (id, mode) {
    if (this.ready) {
      this.instance.setMeshVisibility(id, mode);
    } else {
      this.addAction("setMeshVisibility", [id, mode]);
    }
  },
  
  /**
    * Gets a model instance's mesh's visibility
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @returns {boolean} The mesh's visiblity.
    */
  getMeshVisibility: function (id) {
    if (this.ready) {
      return this.instance.getMeshVisibility(id);
    }
  },
  
  /**
    * Gets a model instance's mesh's visibility
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @returns {boolean} The mesh's visiblity.
    */
  getMeshVisibilities: function () {
    if (this.ready) {
      return this.instance.getMeshVisibilities();
    }
  },
  
  /**
    * Gets the sequences of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of sequence names.
    */
  getSequences: function () {
    if (this.ready) {
      return this.asyncModel.getSequences();
    }
  },
  
  /**
    * Gets the attachments of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of attachment names.
    */
  getAttachments: function () {
    if (this.ready) {
      return this.asyncModel.getAttachments();
    }
  },
  
  /**
    * Gets the bounding shapes of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of bounding shape names.
    */
  getBoundingShapes: function() {
    if (this.ready) {
      return this.asyncModel.getBoundingShapes();
    }
  },
  
  /**
    * Gets the cameras of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of camera names.
    */
  getCameras: function () {
    if (this.ready) {
      return this.asyncModel.getCameras();
    }
  },
  
  /**
    * Gets the number of meshes of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The number of meshes.
    */
  getMeshCount: function () {
    if (this.ready) {
      return this.asyncModel.getMeshCount();
    }
  },
  
  /**
    * Sets a model instance's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {boolean} mode The visibility.
    */
  setVisibility: function (mode) {
    this.visible = mode;
  },
  
  /**
    * Gets a model instance's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {boolean} The visibility.
    */
  getVisibility: function () {
    return this.visible;
  },
  
  /**
    * Gets a model instance's information. This includes most of the getters, and also the information from {@link AsyncModel.getInfo}.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The model instance information.
    */
  getInfo: function () {
    return {
      modelInfo: this.asyncModel.getInfo(),
      visible: this.getVisibility(),
      sequence: this.getSequence(),
      sequenceLoopMode: this.getSequenceLoopMode(),
      location: this.getLocation(),
      rotation: this.getRotation(),
      rotationQuat: this.getRotationQuat(),
      scale: this.getScale(),
      parent: this.getParent(),
      teamColor: this.getTeamColor(),
      textureMap: this.getTextureMap(),
      meshVisibilities: this.getMeshVisibilities(),
      name: this.getName()
    };
  },
  
  /**
    * Gets a model instance's representation as an object that will be converted to JSON.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The JSON representation.
    */
  toJSON: function () {
    // For some reason, when typed arrays are JSON stringified they change to object notation rather than array notation.
    // This is why I don't bother to access the location and rotation directly.
    var location = this.getLocation(),
          rotation = Array.toDeg(this.getRotation()),
          scale = this.getScale(),
          textureMap = {},
          localTextureMap = this.getTextureMap(),
          modelTextureMap = this.asyncModel.getTextureMap(),
          keys = Object.keys(localTextureMap),
          key,
          i,
          l,
          visibilities = this.getMeshVisibilities();
          
    // This code avoids saving instance overrides that match the model's texture map.
    // For example, when the client overrides a texture and then sets it back to the original value.
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      if (localTextureMap[key] !== modelTextureMap[key]) {
        textureMap[key] = localTextureMap[key];
      }
    }
    
    // To avoid silly numbers like 1.0000000000000002
    location = Array.setFloatPrecision(location, 2);
    rotation = Array.setFloatPrecision(rotation, 0);
    scale = Math.setFloatPrecision(scale, 2);
    
    // Turn booleans to numbers to shorten the string.
    for (i = 0, l = visibilities.length; i &lt; l; i++) {
      visibilities[i] = visibilities[i] &amp; 1;
    }
    
    return [
      this.id,
      this.asyncModel.id,
      this.getVisibility() &amp; 1,
      this.getSequence(),
      this.getSequenceLoopMode(),
      location,
      rotation,
      scale,
      this.getParent(),
      this.getTeamColor(),
      textureMap,
      visibilities
    ];
  },
  
  /**
    * Applies the settings of a JSON representation to a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @object {object} The JSON representation.
    */
  fromJSON: function (object) {
    var textureMap = object[10],
          visibilities = object[11],
          keys = Object.keys(textureMap),
          key,
          i,
          l;
          
    this.setVisibility(!!object[2]);
    this.setSequence(object[3]);
    this.setSequenceLoopMode(object[4]);
    this.setLocation(object[5]);
    this.rotate(Array.toRad(object[6]));
    this.setScale(object[7]);
    this.setTeamColor(object[9]);
    
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      this.overrideTexture(key, textureMap[key]);
    }
    
    for (i = 0, l = visibilities.length; i &lt; l; i++) {
      this.setMeshVisibility(i, visibilities[i]);
    }
  }
};

mixin(Async, AsyncModelInstance.prototype);
mixin(Spatial, AsyncModelInstance.prototype);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="AsyncModel.html">AsyncModel</a></li><li><a href="AsyncModelInstance.html">AsyncModelInstance</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BaseModelInstance.html">BaseModelInstance</a></li><li><a href="BinaryReader.html">BinaryReader</a></li><li><a href="BLPTexture.html">BLPTexture</a></li><li><a href="Camera.html">Camera</a></li><li><a href="DDSTexture.html">DDSTexture</a></li><li><a href="GL.html">GL</a></li><li><a href="GL.Cube.html">Cube</a></li><li><a href="GL.Cylinder.html">Cylinder</a></li><li><a href="GL.NativeTexture.html">NativeTexture</a></li><li><a href="GL.Rect.html">Rect</a></li><li><a href="GL.Shader.html">Shader</a></li><li><a href="GL.ShaderUnit.html">ShaderUnit</a></li><li><a href="GL.Sphere.html">Sphere</a></li><li><a href="ModelViewer.html">ModelViewer</a></li><li><a href="Node.html">Node</a></li><li><a href="Texture.html">Texture</a></li><li><a href="TGATexture.html">TGATexture</a></li></ul><h3>Mixins</h3><ul><li><a href="Async.html">Async</a></li><li><a href="Spatial.html">Spatial</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bytesToString">bytesToString</a></li><li><a href="global.html#decodeFloat2">decodeFloat2</a></li><li><a href="global.html#decodeFloat3">decodeFloat3</a></li><li><a href="global.html#encodeFloat2">encodeFloat2</a></li><li><a href="global.html#encodeFloat3">encodeFloat3</a></li><li><a href="global.html#getDom">getDom</a></li><li><a href="global.html#getFile">getFile</a></li><li><a href="global.html#getFileExtension">getFileExtension</a></li><li><a href="global.html#getFileName">getFileName</a></li><li><a href="global.html#getUrlVariables">getUrlVariables</a></li><li><a href="global.html#mixin">mixin</a></li><li><a href="global.html#peek">peek</a></li><li><a href="global.html#read">read</a></li><li><a href="global.html#readFloat32">readFloat32</a></li><li><a href="global.html#readFloat32Array">readFloat32Array</a></li><li><a href="global.html#readFloat32Matrix">readFloat32Matrix</a></li><li><a href="global.html#readFloat64">readFloat64</a></li><li><a href="global.html#readFloat64Array">readFloat64Array</a></li><li><a href="global.html#readFloat64Matrix">readFloat64Matrix</a></li><li><a href="global.html#readInt8">readInt8</a></li><li><a href="global.html#readInt8Array">readInt8Array</a></li><li><a href="global.html#readInt8Matrix">readInt8Matrix</a></li><li><a href="global.html#readInt16">readInt16</a></li><li><a href="global.html#readInt16Array">readInt16Array</a></li><li><a href="global.html#readInt16Matrix">readInt16Matrix</a></li><li><a href="global.html#readInt32">readInt32</a></li><li><a href="global.html#readInt32Array">readInt32Array</a></li><li><a href="global.html#readInt32Matrix">readInt32Matrix</a></li><li><a href="global.html#readMatrix">readMatrix</a></li><li><a href="global.html#readUint8">readUint8</a></li><li><a href="global.html#readUint8Array">readUint8Array</a></li><li><a href="global.html#readUint8Matrix">readUint8Matrix</a></li><li><a href="global.html#readUint16">readUint16</a></li><li><a href="global.html#readUint16Array">readUint16Array</a></li><li><a href="global.html#readUint16Matrix">readUint16Matrix</a></li><li><a href="global.html#readUint32">readUint32</a></li><li><a href="global.html#readUint32Array">readUint32Array</a></li><li><a href="global.html#readUint32Matrix">readUint32Matrix</a></li><li><a href="global.html#readVector2">readVector2</a></li><li><a href="global.html#readVector3">readVector3</a></li><li><a href="global.html#readVector4">readVector4</a></li><li><a href="global.html#remaining">remaining</a></li><li><a href="global.html#seek">seek</a></li><li><a href="global.html#skip">skip</a></li><li><a href="global.html#tell">tell</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Sun Oct 05 2014 02:07:29 GMT+0300 (Jerusalem Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
