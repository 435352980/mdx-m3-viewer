<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: viewer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: viewer.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* The MIT License (MIT)

Copyright (c) 2013-2014 Chananya Freiman

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
(function(J){var H;"undefined"===typeof exports?"function"==typeof define&amp;&amp;"object"==typeof define.amd&amp;&amp;define.amd?(H={},define(function(){return H})):H="undefined"!==typeof window?window:J:H=exports;(function(y){if(!H)var H=1E-6;if(!v)var v="undefined"!==typeof Float32Array?Float32Array:Array;if(!F)var F=Math.random;var w={setMatrixArrayType:function(a){v=a}};"undefined"!==typeof y&amp;&amp;(y.glMatrix=w);var J=Math.PI/180;w.toRadian=function(a){return a*J};var r={create:function(){var a=new v(2);a[0]=0; a[1]=0;return a},clone:function(a){var b=new v(2);b[0]=a[0];b[1]=a[1];return b},fromValues:function(a,b){var c=new v(2);c[0]=a;c[1]=b;return c},copy:function(a,b){a[0]=b[0];a[1]=b[1];return a},set:function(a,b,c){a[0]=b;a[1]=c;return a},add:function(a,b,c){a[0]=b[0]+c[0];a[1]=b[1]+c[1];return a},subtract:function(a,b,c){a[0]=b[0]-c[0];a[1]=b[1]-c[1];return a}};r.sub=r.subtract;r.multiply=function(a,b,c){a[0]=b[0]*c[0];a[1]=b[1]*c[1];return a};r.mul=r.multiply;r.divide=function(a,b,c){a[0]=b[0]/c[0]; a[1]=b[1]/c[1];return a};r.div=r.divide;r.min=function(a,b,c){a[0]=Math.min(b[0],c[0]);a[1]=Math.min(b[1],c[1]);return a};r.max=function(a,b,c){a[0]=Math.max(b[0],c[0]);a[1]=Math.max(b[1],c[1]);return a};r.scale=function(a,b,c){a[0]=b[0]*c;a[1]=b[1]*c;return a};r.scaleAndAdd=function(a,b,c,d){a[0]=b[0]+c[0]*d;a[1]=b[1]+c[1]*d;return a};r.distance=function(a,b){var c=b[0]-a[0],d=b[1]-a[1];return Math.sqrt(c*c+d*d)};r.dist=r.distance;r.squaredDistance=function(a,b){var c=b[0]-a[0],d=b[1]-a[1];return c* c+d*d};r.sqrDist=r.squaredDistance;r.length=function(a){var b=a[0];a=a[1];return Math.sqrt(b*b+a*a)};r.len=r.length;r.squaredLength=function(a){var b=a[0];a=a[1];return b*b+a*a};r.sqrLen=r.squaredLength;r.negate=function(a,b){a[0]=-b[0];a[1]=-b[1];return a};r.normalize=function(a,b){var c=b[0],d=b[1],c=c*c+d*d;0&lt;c&amp;&amp;(c=1/Math.sqrt(c),a[0]=b[0]*c,a[1]=b[1]*c);return a};r.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]};r.cross=function(a,b,c){b=b[0]*c[1]-b[1]*c[0];a[0]=a[1]=0;a[2]=b;return a};r.lerp=function(a, b,c,d){var e=b[0];b=b[1];a[0]=e+d*(c[0]-e);a[1]=b+d*(c[1]-b);return a};r.random=function(a,b){b=b||1;var c=2*F()*Math.PI;a[0]=Math.cos(c)*b;a[1]=Math.sin(c)*b;return a};r.transformMat2=function(a,b,c){var d=b[0];b=b[1];a[0]=c[0]*d+c[2]*b;a[1]=c[1]*d+c[3]*b;return a};r.transformMat2d=function(a,b,c){var d=b[0];b=b[1];a[0]=c[0]*d+c[2]*b+c[4];a[1]=c[1]*d+c[3]*b+c[5];return a};r.transformMat3=function(a,b,c){var d=b[0];b=b[1];a[0]=c[0]*d+c[3]*b+c[6];a[1]=c[1]*d+c[4]*b+c[7];return a};r.transformMat4=function(a, b,c){var d=b[0];b=b[1];a[0]=c[0]*d+c[4]*b+c[12];a[1]=c[1]*d+c[5]*b+c[13];return a};r.forEach=function(){var a=r.create();return function(b,c,d,e,f,g){c||(c=2);d||(d=0);for(e=e?Math.min(e*c+d,b.length):b.length;d&lt;e;d+=c)a[0]=b[d],a[1]=b[d+1],f(a,a,g),b[d]=a[0],b[d+1]=a[1];return b}}();r.str=function(a){return"vec2("+a[0]+", "+a[1]+")"};"undefined"!==typeof y&amp;&amp;(y.vec2=r);var q={create:function(){var a=new v(3);a[0]=0;a[1]=0;a[2]=0;return a},clone:function(a){var b=new v(3);b[0]=a[0];b[1]=a[1];b[2]= a[2];return b},fromValues:function(a,b,c){var d=new v(3);d[0]=a;d[1]=b;d[2]=c;return d},copy:function(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];return a},set:function(a,b,c,d){a[0]=b;a[1]=c;a[2]=d;return a},add:function(a,b,c){a[0]=b[0]+c[0];a[1]=b[1]+c[1];a[2]=b[2]+c[2];return a},subtract:function(a,b,c){a[0]=b[0]-c[0];a[1]=b[1]-c[1];a[2]=b[2]-c[2];return a}};q.sub=q.subtract;q.multiply=function(a,b,c){a[0]=b[0]*c[0];a[1]=b[1]*c[1];a[2]=b[2]*c[2];return a};q.mul=q.multiply;q.divide=function(a,b,c){a[0]= b[0]/c[0];a[1]=b[1]/c[1];a[2]=b[2]/c[2];return a};q.div=q.divide;q.min=function(a,b,c){a[0]=Math.min(b[0],c[0]);a[1]=Math.min(b[1],c[1]);a[2]=Math.min(b[2],c[2]);return a};q.max=function(a,b,c){a[0]=Math.max(b[0],c[0]);a[1]=Math.max(b[1],c[1]);a[2]=Math.max(b[2],c[2]);return a};q.scale=function(a,b,c){a[0]=b[0]*c;a[1]=b[1]*c;a[2]=b[2]*c;return a};q.scaleAndAdd=function(a,b,c,d){a[0]=b[0]+c[0]*d;a[1]=b[1]+c[1]*d;a[2]=b[2]+c[2]*d;return a};q.distance=function(a,b){var c=b[0]-a[0],d=b[1]-a[1],e=b[2]- a[2];return Math.sqrt(c*c+d*d+e*e)};q.dist=q.distance;q.squaredDistance=function(a,b){var c=b[0]-a[0],d=b[1]-a[1],e=b[2]-a[2];return c*c+d*d+e*e};q.sqrDist=q.squaredDistance;q.length=function(a){var b=a[0],c=a[1];a=a[2];return Math.sqrt(b*b+c*c+a*a)};q.len=q.length;q.squaredLength=function(a){var b=a[0],c=a[1];a=a[2];return b*b+c*c+a*a};q.sqrLen=q.squaredLength;q.negate=function(a,b){a[0]=-b[0];a[1]=-b[1];a[2]=-b[2];return a};q.inverse=function(a,b){a[0]=1/b[0];a[1]=1/b[1];a[2]=1/b[2];return a};q.normalize= function(a,b){var c=b[0],d=b[1],e=b[2],c=c*c+d*d+e*e;0&lt;c&amp;&amp;(c=1/Math.sqrt(c),a[0]=b[0]*c,a[1]=b[1]*c,a[2]=b[2]*c);return a};q.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};q.cross=function(a,b,c){var d=b[0],e=b[1];b=b[2];var f=c[0],g=c[1];c=c[2];a[0]=e*c-b*g;a[1]=b*f-d*c;a[2]=d*g-e*f;return a};q.lerp=function(a,b,c,d){var e=b[0],f=b[1];b=b[2];a[0]=e+d*(c[0]-e);a[1]=f+d*(c[1]-f);a[2]=b+d*(c[2]-b);return a};q.random=function(a,b){b=b||1;var c=2*F()*Math.PI,d=2*F()-1,e=Math.sqrt(1-d*d)*b;a[0]= Math.cos(c)*e;a[1]=Math.sin(c)*e;a[2]=d*b;return a};q.transformMat4=function(a,b,c){var d=b[0],e=b[1];b=b[2];a[0]=c[0]*d+c[4]*e+c[8]*b+c[12];a[1]=c[1]*d+c[5]*e+c[9]*b+c[13];a[2]=c[2]*d+c[6]*e+c[10]*b+c[14];return a};q.transformMat3=function(a,b,c){var d=b[0],e=b[1];b=b[2];a[0]=d*c[0]+e*c[3]+b*c[6];a[1]=d*c[1]+e*c[4]+b*c[7];a[2]=d*c[2]+e*c[5]+b*c[8];return a};q.transformQuat=function(a,b,c){var d=b[0],e=b[1],f=b[2];b=c[0];var g=c[1],h=c[2];c=c[3];var k=c*d+g*f-h*e,l=c*e+h*d-b*f,n=c*f+b*e-g*d,d=-b* d-g*e-h*f;a[0]=k*c+d*-b+l*-h-n*-g;a[1]=l*c+d*-g+n*-b-k*-h;a[2]=n*c+d*-h+k*-g-l*-b;return a};q.rotateX=function(a,b,c,d){var e=[],f=[];e[0]=b[0]-c[0];e[1]=b[1]-c[1];e[2]=b[2]-c[2];f[0]=e[0];f[1]=e[1]*Math.cos(d)-e[2]*Math.sin(d);f[2]=e[1]*Math.sin(d)+e[2]*Math.cos(d);a[0]=f[0]+c[0];a[1]=f[1]+c[1];a[2]=f[2]+c[2];return a};q.rotateY=function(a,b,c,d){var e=[],f=[];e[0]=b[0]-c[0];e[1]=b[1]-c[1];e[2]=b[2]-c[2];f[0]=e[2]*Math.sin(d)+e[0]*Math.cos(d);f[1]=e[1];f[2]=e[2]*Math.cos(d)-e[0]*Math.sin(d);a[0]= f[0]+c[0];a[1]=f[1]+c[1];a[2]=f[2]+c[2];return a};q.rotateZ=function(a,b,c,d){var e=[],f=[];e[0]=b[0]-c[0];e[1]=b[1]-c[1];e[2]=b[2]-c[2];f[0]=e[0]*Math.cos(d)-e[1]*Math.sin(d);f[1]=e[0]*Math.sin(d)+e[1]*Math.cos(d);f[2]=e[2];a[0]=f[0]+c[0];a[1]=f[1]+c[1];a[2]=f[2]+c[2];return a};q.forEach=function(){var a=q.create();return function(b,c,d,e,f,g){c||(c=3);d||(d=0);for(e=e?Math.min(e*c+d,b.length):b.length;d&lt;e;d+=c)a[0]=b[d],a[1]=b[d+1],a[2]=b[d+2],f(a,a,g),b[d]=a[0],b[d+1]=a[1],b[d+2]=a[2];return b}}(); q.str=function(a){return"vec3("+a[0]+", "+a[1]+", "+a[2]+")"};"undefined"!==typeof y&amp;&amp;(y.vec3=q);var p={create:function(){var a=new v(4);a[0]=0;a[1]=0;a[2]=0;a[3]=0;return a},clone:function(a){var b=new v(4);b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b},fromValues:function(a,b,c,d){var e=new v(4);e[0]=a;e[1]=b;e[2]=c;e[3]=d;return e},copy:function(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];return a},set:function(a,b,c,d,e){a[0]=b;a[1]=c;a[2]=d;a[3]=e;return a},add:function(a,b,c){a[0]=b[0]+ c[0];a[1]=b[1]+c[1];a[2]=b[2]+c[2];a[3]=b[3]+c[3];return a},subtract:function(a,b,c){a[0]=b[0]-c[0];a[1]=b[1]-c[1];a[2]=b[2]-c[2];a[3]=b[3]-c[3];return a}};p.sub=p.subtract;p.multiply=function(a,b,c){a[0]=b[0]*c[0];a[1]=b[1]*c[1];a[2]=b[2]*c[2];a[3]=b[3]*c[3];return a};p.mul=p.multiply;p.divide=function(a,b,c){a[0]=b[0]/c[0];a[1]=b[1]/c[1];a[2]=b[2]/c[2];a[3]=b[3]/c[3];return a};p.div=p.divide;p.min=function(a,b,c){a[0]=Math.min(b[0],c[0]);a[1]=Math.min(b[1],c[1]);a[2]=Math.min(b[2],c[2]);a[3]=Math.min(b[3], c[3]);return a};p.max=function(a,b,c){a[0]=Math.max(b[0],c[0]);a[1]=Math.max(b[1],c[1]);a[2]=Math.max(b[2],c[2]);a[3]=Math.max(b[3],c[3]);return a};p.scale=function(a,b,c){a[0]=b[0]*c;a[1]=b[1]*c;a[2]=b[2]*c;a[3]=b[3]*c;return a};p.scaleAndAdd=function(a,b,c,d){a[0]=b[0]+c[0]*d;a[1]=b[1]+c[1]*d;a[2]=b[2]+c[2]*d;a[3]=b[3]+c[3]*d;return a};p.distance=function(a,b){var c=b[0]-a[0],d=b[1]-a[1],e=b[2]-a[2],f=b[3]-a[3];return Math.sqrt(c*c+d*d+e*e+f*f)};p.dist=p.distance;p.squaredDistance=function(a,b){var c= b[0]-a[0],d=b[1]-a[1],e=b[2]-a[2],f=b[3]-a[3];return c*c+d*d+e*e+f*f};p.sqrDist=p.squaredDistance;p.length=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};p.len=p.length;p.squaredLength=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];return b*b+c*c+d*d+a*a};p.sqrLen=p.squaredLength;p.negate=function(a,b){a[0]=-b[0];a[1]=-b[1];a[2]=-b[2];a[3]=-b[3];return a};p.normalize=function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],c=c*c+d*d+e*e+f*f;0&lt;c&amp;&amp;(c=1/Math.sqrt(c),a[0]=b[0]*c,a[1]= b[1]*c,a[2]=b[2]*c,a[3]=b[3]*c);return a};p.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]};p.lerp=function(a,b,c,d){var e=b[0],f=b[1],g=b[2];b=b[3];a[0]=e+d*(c[0]-e);a[1]=f+d*(c[1]-f);a[2]=g+d*(c[2]-g);a[3]=b+d*(c[3]-b);return a};p.random=function(a,b){b=b||1;a[0]=F();a[1]=F();a[2]=F();a[3]=F();p.normalize(a,a);p.scale(a,a,b);return a};p.transformMat4=function(a,b,c){var d=b[0],e=b[1],f=b[2];b=b[3];a[0]=c[0]*d+c[4]*e+c[8]*f+c[12]*b;a[1]=c[1]*d+c[5]*e+c[9]*f+c[13]*b;a[2]=c[2]*d+ c[6]*e+c[10]*f+c[14]*b;a[3]=c[3]*d+c[7]*e+c[11]*f+c[15]*b;return a};p.transformQuat=function(a,b,c){var d=b[0],e=b[1],f=b[2];b=c[0];var g=c[1],h=c[2];c=c[3];var k=c*d+g*f-h*e,l=c*e+h*d-b*f,n=c*f+b*e-g*d,d=-b*d-g*e-h*f;a[0]=k*c+d*-b+l*-h-n*-g;a[1]=l*c+d*-g+n*-b-k*-h;a[2]=n*c+d*-h+k*-g-l*-b;return a};p.forEach=function(){var a=p.create();return function(b,c,d,e,f,g){c||(c=4);d||(d=0);for(e=e?Math.min(e*c+d,b.length):b.length;d&lt;e;d+=c)a[0]=b[d],a[1]=b[d+1],a[2]=b[d+2],a[3]=b[d+3],f(a,a,g),b[d]=a[0], b[d+1]=a[1],b[d+2]=a[2],b[d+3]=a[3];return b}}();p.str=function(a){return"vec4("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")"};"undefined"!==typeof y&amp;&amp;(y.vec4=p);w={create:function(){var a=new v(4);a[0]=1;a[1]=0;a[2]=0;a[3]=1;return a},clone:function(a){var b=new v(4);b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b},copy:function(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];return a},identity:function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=1;return a},transpose:function(a,b){if(a===b){var c=b[1];a[1]=b[2];a[2]= c}else a[0]=b[0],a[1]=b[2],a[2]=b[1],a[3]=b[3];return a},invert:function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=c*f-e*d;if(!g)return null;g=1/g;a[0]=f*g;a[1]=-d*g;a[2]=-e*g;a[3]=c*g;return a},adjoint:function(a,b){var c=b[0];a[0]=b[3];a[1]=-b[1];a[2]=-b[2];a[3]=c;return a},determinant:function(a){return a[0]*a[3]-a[2]*a[1]},multiply:function(a,b,c){var d=b[0],e=b[1],f=b[2];b=b[3];var g=c[0],h=c[1],k=c[2];c=c[3];a[0]=d*g+f*h;a[1]=e*g+b*h;a[2]=d*k+f*c;a[3]=e*k+b*c;return a}};w.mul=w.multiply;w.rotate= function(a,b,c){var d=b[0],e=b[1],f=b[2];b=b[3];var g=Math.sin(c);c=Math.cos(c);a[0]=d*c+f*g;a[1]=e*c+b*g;a[2]=d*-g+f*c;a[3]=e*-g+b*c;return a};w.scale=function(a,b,c){var d=b[1],e=b[2],f=b[3],g=c[0];c=c[1];a[0]=b[0]*g;a[1]=d*g;a[2]=e*c;a[3]=f*c;return a};w.str=function(a){return"mat2("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")"};w.frob=function(a){return Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1],2)+Math.pow(a[2],2)+Math.pow(a[3],2))};w.LDU=function(a,b,c,d){a[2]=d[2]/d[0];c[0]=d[0];c[1]=d[1];c[3]=d[3]- a[2]*c[1];return[a,b,c]};"undefined"!==typeof y&amp;&amp;(y.mat2=w);w={create:function(){var a=new v(6);a[0]=1;a[1]=0;a[2]=0;a[3]=1;a[4]=0;a[5]=0;return a},clone:function(a){var b=new v(6);b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];return b},copy:function(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];return a},identity:function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=1;a[4]=0;a[5]=0;return a},invert:function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=b[4],h=b[5],k=c*f-d*e;if(!k)return null; k=1/k;a[0]=f*k;a[1]=-d*k;a[2]=-e*k;a[3]=c*k;a[4]=(e*h-f*g)*k;a[5]=(d*g-c*h)*k;return a},determinant:function(a){return a[0]*a[3]-a[1]*a[2]},multiply:function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=b[4];b=b[5];var k=c[0],l=c[1],n=c[2],m=c[3],u=c[4];c=c[5];a[0]=d*k+f*l;a[1]=e*k+g*l;a[2]=d*n+f*m;a[3]=e*n+g*m;a[4]=d*u+f*c+h;a[5]=e*u+g*c+b;return a}};w.mul=w.multiply;w.rotate=function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=b[4];b=b[5];var k=Math.sin(c);c=Math.cos(c);a[0]=d*c+f*k;a[1]=e*c+g*k;a[2]= d*-k+f*c;a[3]=e*-k+g*c;a[4]=h;a[5]=b;return a};w.scale=function(a,b,c){var d=b[1],e=b[2],f=b[3],g=b[4],h=b[5],k=c[0];c=c[1];a[0]=b[0]*k;a[1]=d*k;a[2]=e*c;a[3]=f*c;a[4]=g;a[5]=h;return a};w.translate=function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=b[4];b=b[5];var k=c[0];c=c[1];a[0]=d;a[1]=e;a[2]=f;a[3]=g;a[4]=d*k+f*c+h;a[5]=e*k+g*c+b;return a};w.str=function(a){return"mat2d("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+")"};w.frob=function(a){return Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1], 2)+Math.pow(a[2],2)+Math.pow(a[3],2)+Math.pow(a[4],2)+Math.pow(a[5],2)+1)};"undefined"!==typeof y&amp;&amp;(y.mat2d=w);var D={create:function(){var a=new v(9);a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a},fromMat4:function(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[4];a[4]=b[5];a[5]=b[6];a[6]=b[8];a[7]=b[9];a[8]=b[10];return a},clone:function(a){var b=new v(9);b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b},copy:function(a,b){a[0]= b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];return a},identity:function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a},transpose:function(a,b){if(a===b){var c=b[1],d=b[2],e=b[5];a[1]=b[3];a[2]=b[6];a[3]=c;a[5]=b[7];a[6]=d;a[7]=e}else a[0]=b[0],a[1]=b[3],a[2]=b[6],a[3]=b[1],a[4]=b[4],a[5]=b[7],a[6]=b[2],a[7]=b[5],a[8]=b[8];return a},invert:function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=b[4],h=b[5],k=b[6],l=b[7],n=b[8],m=n*g-h*l, u=-n*f+h*k,t=l*f-g*k,E=c*m+d*u+e*t;if(!E)return null;E=1/E;a[0]=m*E;a[1]=(-n*d+e*l)*E;a[2]=(h*d-e*g)*E;a[3]=u*E;a[4]=(n*c-e*k)*E;a[5]=(-h*c+e*f)*E;a[6]=t*E;a[7]=(-l*c+d*k)*E;a[8]=(g*c-d*f)*E;return a},adjoint:function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=b[4],h=b[5],k=b[6],l=b[7],n=b[8];a[0]=g*n-h*l;a[1]=e*l-d*n;a[2]=d*h-e*g;a[3]=h*k-f*n;a[4]=c*n-e*k;a[5]=e*f-c*h;a[6]=f*l-g*k;a[7]=d*k-c*l;a[8]=c*g-d*f;return a},determinant:function(a){var b=a[3],c=a[4],d=a[5],e=a[6],f=a[7],g=a[8];return a[0]*(g* c-d*f)+a[1]*(-g*b+d*e)+a[2]*(f*b-c*e)},multiply:function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=b[4],k=b[5],l=b[6],n=b[7];b=b[8];var m=c[0],u=c[1],t=c[2],E=c[3],q=c[4],K=c[5],p=c[6],r=c[7];c=c[8];a[0]=m*d+u*g+t*l;a[1]=m*e+u*h+t*n;a[2]=m*f+u*k+t*b;a[3]=E*d+q*g+K*l;a[4]=E*e+q*h+K*n;a[5]=E*f+q*k+K*b;a[6]=p*d+r*g+c*l;a[7]=p*e+r*h+c*n;a[8]=p*f+r*k+c*b;return a}};D.mul=D.multiply;D.translate=function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=b[4],k=b[5],l=b[6],n=b[7];b=b[8];var m=c[0];c=c[1];a[0]=d;a[1]= e;a[2]=f;a[3]=g;a[4]=h;a[5]=k;a[6]=m*d+c*g+l;a[7]=m*e+c*h+n;a[8]=m*f+c*k+b;return a};D.rotate=function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=b[4],k=b[5],l=b[6],n=b[7];b=b[8];var m=Math.sin(c);c=Math.cos(c);a[0]=c*d+m*g;a[1]=c*e+m*h;a[2]=c*f+m*k;a[3]=c*g-m*d;a[4]=c*h-m*e;a[5]=c*k-m*f;a[6]=l;a[7]=n;a[8]=b;return a};D.scale=function(a,b,c){var d=c[0];c=c[1];a[0]=d*b[0];a[1]=d*b[1];a[2]=d*b[2];a[3]=c*b[3];a[4]=c*b[4];a[5]=c*b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];return a};D.fromMat2d=function(a,b){a[0]= b[0];a[1]=b[1];a[2]=0;a[3]=b[2];a[4]=b[3];a[5]=0;a[6]=b[4];a[7]=b[5];a[8]=1;return a};D.fromQuat=function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=c+c,h=d+d,k=e+e,c=c*g,l=d*g,d=d*h,n=e*g,m=e*h,e=e*k,g=f*g,h=f*h,f=f*k;a[0]=1-d-e;a[3]=l-f;a[6]=n+h;a[1]=l+f;a[4]=1-c-e;a[7]=m-g;a[2]=n-h;a[5]=m+g;a[8]=1-c-d;return a};D.normalFromMat4=function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=b[4],h=b[5],k=b[6],l=b[7],n=b[8],m=b[9],u=b[10],t=b[11],E=b[12],q=b[13],p=b[14],r=b[15],s=c*h-d*g,B=c*k-e*g,x=c*l-f*g,z=d*k- e*h,v=d*l-f*h,w=e*l-f*k,y=n*q-m*E,A=n*p-u*E,n=n*r-t*E,I=m*p-u*q,m=m*r-t*q,u=u*r-t*p,t=s*u-B*m+x*I+z*n-v*A+w*y;if(!t)return null;t=1/t;a[0]=(h*u-k*m+l*I)*t;a[1]=(k*n-g*u-l*A)*t;a[2]=(g*m-h*n+l*y)*t;a[3]=(e*m-d*u-f*I)*t;a[4]=(c*u-e*n+f*A)*t;a[5]=(d*n-c*m-f*y)*t;a[6]=(q*w-p*v+r*z)*t;a[7]=(p*x-E*w-r*B)*t;a[8]=(E*v-q*x+r*s)*t;return a};D.str=function(a){return"mat3("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+")"};D.frob=function(a){return Math.sqrt(Math.pow(a[0], 2)+Math.pow(a[1],2)+Math.pow(a[2],2)+Math.pow(a[3],2)+Math.pow(a[4],2)+Math.pow(a[5],2)+Math.pow(a[6],2)+Math.pow(a[7],2)+Math.pow(a[8],2))};"undefined"!==typeof y&amp;&amp;(y.mat3=D);var A={create:function(){var a=new v(16);a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a},clone:function(a){var b=new v(16);b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11]; b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b},copy:function(a,b){a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];a[9]=b[9];a[10]=b[10];a[11]=b[11];a[12]=b[12];a[13]=b[13];a[14]=b[14];a[15]=b[15];return a},identity:function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a},transpose:function(a,b){if(a===b){var c=b[1],d=b[2],e=b[3],f=b[6],g=b[7],h=b[11];a[1]=b[4];a[2]= b[8];a[3]=b[12];a[4]=c;a[6]=b[9];a[7]=b[13];a[8]=d;a[9]=f;a[11]=b[14];a[12]=e;a[13]=g;a[14]=h}else a[0]=b[0],a[1]=b[4],a[2]=b[8],a[3]=b[12],a[4]=b[1],a[5]=b[5],a[6]=b[9],a[7]=b[13],a[8]=b[2],a[9]=b[6],a[10]=b[10],a[11]=b[14],a[12]=b[3],a[13]=b[7],a[14]=b[11],a[15]=b[15];return a},invert:function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=b[4],h=b[5],k=b[6],l=b[7],n=b[8],m=b[9],u=b[10],t=b[11],q=b[12],p=b[13],r=b[14],s=b[15],C=c*h-d*g,B=c*k-e*g,x=c*l-f*g,z=d*k-e*h,v=d*l-f*h,w=e*l-f*k,y=n*p-m*q,A=n*r-u* q,I=n*s-t*q,D=m*r-u*p,H=m*s-t*p,F=u*s-t*r,G=C*F-B*H+x*D+z*I-v*A+w*y;if(!G)return null;G=1/G;a[0]=(h*F-k*H+l*D)*G;a[1]=(e*H-d*F-f*D)*G;a[2]=(p*w-r*v+s*z)*G;a[3]=(u*v-m*w-t*z)*G;a[4]=(k*I-g*F-l*A)*G;a[5]=(c*F-e*I+f*A)*G;a[6]=(r*x-q*w-s*B)*G;a[7]=(n*w-u*x+t*B)*G;a[8]=(g*H-h*I+l*y)*G;a[9]=(d*I-c*H-f*y)*G;a[10]=(q*v-p*x+s*C)*G;a[11]=(m*x-n*v-t*C)*G;a[12]=(h*A-g*D-k*y)*G;a[13]=(c*D-d*A+e*y)*G;a[14]=(p*B-q*z-r*C)*G;a[15]=(n*z-m*B+u*C)*G;return a},adjoint:function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=b[4], h=b[5],k=b[6],l=b[7],n=b[8],m=b[9],u=b[10],t=b[11],q=b[12],p=b[13],r=b[14],s=b[15];a[0]=h*(u*s-t*r)-m*(k*s-l*r)+p*(k*t-l*u);a[1]=-(d*(u*s-t*r)-m*(e*s-f*r)+p*(e*t-f*u));a[2]=d*(k*s-l*r)-h*(e*s-f*r)+p*(e*l-f*k);a[3]=-(d*(k*t-l*u)-h*(e*t-f*u)+m*(e*l-f*k));a[4]=-(g*(u*s-t*r)-n*(k*s-l*r)+q*(k*t-l*u));a[5]=c*(u*s-t*r)-n*(e*s-f*r)+q*(e*t-f*u);a[6]=-(c*(k*s-l*r)-g*(e*s-f*r)+q*(e*l-f*k));a[7]=c*(k*t-l*u)-g*(e*t-f*u)+n*(e*l-f*k);a[8]=g*(m*s-t*p)-n*(h*s-l*p)+q*(h*t-l*m);a[9]=-(c*(m*s-t*p)-n*(d*s-f*p)+q*(d*t- f*m));a[10]=c*(h*s-l*p)-g*(d*s-f*p)+q*(d*l-f*h);a[11]=-(c*(h*t-l*m)-g*(d*t-f*m)+n*(d*l-f*h));a[12]=-(g*(m*r-u*p)-n*(h*r-k*p)+q*(h*u-k*m));a[13]=c*(m*r-u*p)-n*(d*r-e*p)+q*(d*u-e*m);a[14]=-(c*(h*r-k*p)-g*(d*r-e*p)+q*(d*k-e*h));a[15]=c*(h*u-k*m)-g*(d*u-e*m)+n*(d*k-e*h);return a},determinant:function(a){var b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7],l=a[8],n=a[9],m=a[10],p=a[11],q=a[12],r=a[13],s=a[14];a=a[15];return(b*g-c*f)*(m*a-p*s)-(b*h-d*f)*(n*a-p*r)+(b*k-e*f)*(n*s-m*r)+(c*h-d*g)*(l* a-p*q)-(c*k-e*g)*(l*s-m*q)+(d*k-e*h)*(l*r-n*q)},multiply:function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=b[4],k=b[5],l=b[6],n=b[7],m=b[8],p=b[9],q=b[10],r=b[11],s=b[12],v=b[13],w=b[14];b=b[15];var C=c[0],B=c[1],x=c[2],z=c[3];a[0]=C*d+B*h+x*m+z*s;a[1]=C*e+B*k+x*p+z*v;a[2]=C*f+B*l+x*q+z*w;a[3]=C*g+B*n+x*r+z*b;C=c[4];B=c[5];x=c[6];z=c[7];a[4]=C*d+B*h+x*m+z*s;a[5]=C*e+B*k+x*p+z*v;a[6]=C*f+B*l+x*q+z*w;a[7]=C*g+B*n+x*r+z*b;C=c[8];B=c[9];x=c[10];z=c[11];a[8]=C*d+B*h+x*m+z*s;a[9]=C*e+B*k+x*p+z*v;a[10]= C*f+B*l+x*q+z*w;a[11]=C*g+B*n+x*r+z*b;C=c[12];B=c[13];x=c[14];z=c[15];a[12]=C*d+B*h+x*m+z*s;a[13]=C*e+B*k+x*p+z*v;a[14]=C*f+B*l+x*q+z*w;a[15]=C*g+B*n+x*r+z*b;return a}};A.mul=A.multiply;A.translate=function(a,b,c){var d=c[0],e=c[1];c=c[2];var f,g,h,k,l,n,m,p,q,r,s,v;b===a?(a[12]=b[0]*d+b[4]*e+b[8]*c+b[12],a[13]=b[1]*d+b[5]*e+b[9]*c+b[13],a[14]=b[2]*d+b[6]*e+b[10]*c+b[14],a[15]=b[3]*d+b[7]*e+b[11]*c+b[15]):(f=b[0],g=b[1],h=b[2],k=b[3],l=b[4],n=b[5],m=b[6],p=b[7],q=b[8],r=b[9],s=b[10],v=b[11],a[0]= f,a[1]=g,a[2]=h,a[3]=k,a[4]=l,a[5]=n,a[6]=m,a[7]=p,a[8]=q,a[9]=r,a[10]=s,a[11]=v,a[12]=f*d+l*e+q*c+b[12],a[13]=g*d+n*e+r*c+b[13],a[14]=h*d+m*e+s*c+b[14],a[15]=k*d+p*e+v*c+b[15]);return a};A.scale=function(a,b,c){var d=c[0],e=c[1];c=c[2];a[0]=b[0]*d;a[1]=b[1]*d;a[2]=b[2]*d;a[3]=b[3]*d;a[4]=b[4]*e;a[5]=b[5]*e;a[6]=b[6]*e;a[7]=b[7]*e;a[8]=b[8]*c;a[9]=b[9]*c;a[10]=b[10]*c;a[11]=b[11]*c;a[12]=b[12];a[13]=b[13];a[14]=b[14];a[15]=b[15];return a};A.rotate=function(a,b,c,d){var e=d[0],f=d[1];d=d[2];var g= Math.sqrt(e*e+f*f+d*d),h,k,l,n,m,p,q,r,s,v,w,C,B,x,z,y,A,D,F,I;if(Math.abs(g)&lt;H)return null;g=1/g;e*=g;f*=g;d*=g;h=Math.sin(c);k=Math.cos(c);l=1-k;c=b[0];g=b[1];n=b[2];m=b[3];p=b[4];q=b[5];r=b[6];s=b[7];v=b[8];w=b[9];C=b[10];B=b[11];x=e*e*l+k;z=f*e*l+d*h;y=d*e*l-f*h;A=e*f*l-d*h;D=f*f*l+k;F=d*f*l+e*h;I=e*d*l+f*h;e=f*d*l-e*h;f=d*d*l+k;a[0]=c*x+p*z+v*y;a[1]=g*x+q*z+w*y;a[2]=n*x+r*z+C*y;a[3]=m*x+s*z+B*y;a[4]=c*A+p*D+v*F;a[5]=g*A+q*D+w*F;a[6]=n*A+r*D+C*F;a[7]=m*A+s*D+B*F;a[8]=c*I+p*e+v*f;a[9]=g*I+q*e+ w*f;a[10]=n*I+r*e+C*f;a[11]=m*I+s*e+B*f;b!==a&amp;&amp;(a[12]=b[12],a[13]=b[13],a[14]=b[14],a[15]=b[15]);return a};A.rotateX=function(a,b,c){var d=Math.sin(c);c=Math.cos(c);var e=b[4],f=b[5],g=b[6],h=b[7],k=b[8],l=b[9],n=b[10],m=b[11];b!==a&amp;&amp;(a[0]=b[0],a[1]=b[1],a[2]=b[2],a[3]=b[3],a[12]=b[12],a[13]=b[13],a[14]=b[14],a[15]=b[15]);a[4]=e*c+k*d;a[5]=f*c+l*d;a[6]=g*c+n*d;a[7]=h*c+m*d;a[8]=k*c-e*d;a[9]=l*c-f*d;a[10]=n*c-g*d;a[11]=m*c-h*d;return a};A.rotateY=function(a,b,c){var d=Math.sin(c);c=Math.cos(c);var e= b[0],f=b[1],g=b[2],h=b[3],k=b[8],l=b[9],n=b[10],m=b[11];b!==a&amp;&amp;(a[4]=b[4],a[5]=b[5],a[6]=b[6],a[7]=b[7],a[12]=b[12],a[13]=b[13],a[14]=b[14],a[15]=b[15]);a[0]=e*c-k*d;a[1]=f*c-l*d;a[2]=g*c-n*d;a[3]=h*c-m*d;a[8]=e*d+k*c;a[9]=f*d+l*c;a[10]=g*d+n*c;a[11]=h*d+m*c;return a};A.rotateZ=function(a,b,c){var d=Math.sin(c);c=Math.cos(c);var e=b[0],f=b[1],g=b[2],h=b[3],k=b[4],l=b[5],n=b[6],m=b[7];b!==a&amp;&amp;(a[8]=b[8],a[9]=b[9],a[10]=b[10],a[11]=b[11],a[12]=b[12],a[13]=b[13],a[14]=b[14],a[15]=b[15]);a[0]=e*c+k*d; a[1]=f*c+l*d;a[2]=g*c+n*d;a[3]=h*c+m*d;a[4]=k*c-e*d;a[5]=l*c-f*d;a[6]=n*c-g*d;a[7]=m*c-h*d;return a};A.fromRotationTranslation=function(a,b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=d+d,k=e+e,l=f+f;b=d*h;var n=d*k,d=d*l,m=e*k,e=e*l,f=f*l,h=g*h,k=g*k,g=g*l;a[0]=1-(m+f);a[1]=n+g;a[2]=d-k;a[3]=0;a[4]=n-g;a[5]=1-(b+f);a[6]=e+h;a[7]=0;a[8]=d+k;a[9]=e-h;a[10]=1-(b+m);a[11]=0;a[12]=c[0];a[13]=c[1];a[14]=c[2];a[15]=1;return a};A.fromQuat=function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=c+c,h=d+d,k=e+e,c=c*g,l= d*g,d=d*h,n=e*g,m=e*h,e=e*k,g=f*g,h=f*h,f=f*k;a[0]=1-d-e;a[1]=l+f;a[2]=n-h;a[3]=0;a[4]=l-f;a[5]=1-c-e;a[6]=m+g;a[7]=0;a[8]=n+h;a[9]=m-g;a[10]=1-c-d;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};A.frustum=function(a,b,c,d,e,f,g){var h=1/(c-b),k=1/(e-d),l=1/(f-g);a[0]=2*f*h;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=2*f*k;a[6]=0;a[7]=0;a[8]=(c+b)*h;a[9]=(e+d)*k;a[10]=(g+f)*l;a[11]=-1;a[12]=0;a[13]=0;a[14]=g*f*2*l;a[15]=0;return a};A.perspective=function(a,b,c,d,e){b=1/Math.tan(b/2);var f=1/(d-e);a[0]=b/c; a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=b;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=(e+d)*f;a[11]=-1;a[12]=0;a[13]=0;a[14]=2*e*d*f;a[15]=0;return a};A.ortho=function(a,b,c,d,e,f,g){var h=1/(b-c),k=1/(d-e),l=1/(f-g);a[0]=-2*h;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=-2*k;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=2*l;a[11]=0;a[12]=(b+c)*h;a[13]=(e+d)*k;a[14]=(g+f)*l;a[15]=1;return a};A.lookAt=function(a,b,c,d){var e,f,g,h,k,l,n,m,p=b[0],q=b[1];b=b[2];g=d[0];h=d[1];f=d[2];n=c[0];d=c[1];e=c[2];if(Math.abs(p-n)&lt;H&amp;&amp;Math.abs(q-d)&lt;H&amp;&amp; Math.abs(b-e)&lt;H)return A.identity(a);c=p-n;d=q-d;n=b-e;m=1/Math.sqrt(c*c+d*d+n*n);c*=m;d*=m;n*=m;e=h*n-f*d;f=f*c-g*n;g=g*d-h*c;(m=Math.sqrt(e*e+f*f+g*g))?(m=1/m,e*=m,f*=m,g*=m):g=f=e=0;h=d*g-n*f;k=n*e-c*g;l=c*f-d*e;(m=Math.sqrt(h*h+k*k+l*l))?(m=1/m,h*=m,k*=m,l*=m):l=k=h=0;a[0]=e;a[1]=h;a[2]=c;a[3]=0;a[4]=f;a[5]=k;a[6]=d;a[7]=0;a[8]=g;a[9]=l;a[10]=n;a[11]=0;a[12]=-(e*p+f*q+g*b);a[13]=-(h*p+k*q+l*b);a[14]=-(c*p+d*q+n*b);a[15]=1;return a};A.str=function(a){return"mat4("+a[0]+", "+a[1]+", "+a[2]+", "+ a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+")"};A.frob=function(a){return Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1],2)+Math.pow(a[2],2)+Math.pow(a[3],2)+Math.pow(a[4],2)+Math.pow(a[5],2)+Math.pow(a[6],2)+Math.pow(a[6],2)+Math.pow(a[7],2)+Math.pow(a[8],2)+Math.pow(a[9],2)+Math.pow(a[10],2)+Math.pow(a[11],2)+Math.pow(a[12],2)+Math.pow(a[13],2)+Math.pow(a[14],2)+Math.pow(a[15],2))};"undefined"!==typeof y&amp;&amp;(y.mat4= A);var s={create:function(){var a=new v(4);a[0]=0;a[1]=0;a[2]=0;a[3]=1;return a}};s.rotationTo=function(){var a=q.create(),b=q.fromValues(1,0,0),c=q.fromValues(0,1,0);return function(d,e,f){var g=q.dot(e,f);if(-.999999>g)return q.cross(a,b,e),1E-6>q.length(a)&amp;&amp;q.cross(a,c,e),q.normalize(a,a),s.setAxisAngle(d,a,Math.PI),d;if(.999999&lt;g)return d[0]=0,d[1]=0,d[2]=0,d[3]=1,d;q.cross(a,e,f);d[0]=a[0];d[1]=a[1];d[2]=a[2];d[3]=1+g;return s.normalize(d,d)}}();s.setAxes=function(){var a=D.create();return function(b, c,d,e){a[0]=d[0];a[3]=d[1];a[6]=d[2];a[1]=e[0];a[4]=e[1];a[7]=e[2];a[2]=-c[0];a[5]=-c[1];a[8]=-c[2];return s.normalize(b,s.fromMat3(b,a))}}();s.clone=p.clone;s.fromValues=p.fromValues;s.copy=p.copy;s.set=p.set;s.identity=function(a){a[0]=0;a[1]=0;a[2]=0;a[3]=1;return a};s.setAxisAngle=function(a,b,c){c*=.5;var d=Math.sin(c);a[0]=d*b[0];a[1]=d*b[1];a[2]=d*b[2];a[3]=Math.cos(c);return a};s.add=p.add;s.multiply=function(a,b,c){var d=b[0],e=b[1],f=b[2];b=b[3];var g=c[0],h=c[1],k=c[2];c=c[3];a[0]=d*c+ b*g+e*k-f*h;a[1]=e*c+b*h+f*g-d*k;a[2]=f*c+b*k+d*h-e*g;a[3]=b*c-d*g-e*h-f*k;return a};s.mul=s.multiply;s.scale=p.scale;s.rotateX=function(a,b,c){c*=.5;var d=b[0],e=b[1],f=b[2];b=b[3];var g=Math.sin(c);c=Math.cos(c);a[0]=d*c+b*g;a[1]=e*c+f*g;a[2]=f*c-e*g;a[3]=b*c-d*g;return a};s.rotateY=function(a,b,c){c*=.5;var d=b[0],e=b[1],f=b[2];b=b[3];var g=Math.sin(c);c=Math.cos(c);a[0]=d*c-f*g;a[1]=e*c+b*g;a[2]=f*c+d*g;a[3]=b*c-e*g;return a};s.rotateZ=function(a,b,c){c*=.5;var d=b[0],e=b[1],f=b[2];b=b[3];var g= Math.sin(c);c=Math.cos(c);a[0]=d*c+e*g;a[1]=e*c-d*g;a[2]=f*c+b*g;a[3]=b*c-f*g;return a};s.calculateW=function(a,b){var c=b[0],d=b[1],e=b[2];a[0]=c;a[1]=d;a[2]=e;a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return a};s.dot=p.dot;s.lerp=p.lerp;s.slerp=function(a,b,c,d){var e=b[0],f=b[1],g=b[2];b=b[3];var h=c[0],k=c[1],l=c[2];c=c[3];var n,m,p;m=e*h+f*k+g*l+b*c;0>m&amp;&amp;(m=-m,h=-h,k=-k,l=-l,c=-c);1E-6&lt;1-m?(n=Math.acos(m),p=Math.sin(n),m=Math.sin((1-d)*n)/p,d=Math.sin(d*n)/p):m=1-d;a[0]=m*e+d*h;a[1]=m*f+d*k;a[2]= m*g+d*l;a[3]=m*b+d*c;return a};s.invert=function(a,b){var c=b[0],d=b[1],e=b[2],f=b[3],g=c*c+d*d+e*e+f*f,g=g?1/g:0;a[0]=-c*g;a[1]=-d*g;a[2]=-e*g;a[3]=f*g;return a};s.conjugate=function(a,b){a[0]=-b[0];a[1]=-b[1];a[2]=-b[2];a[3]=b[3];return a};s.length=p.length;s.len=s.length;s.squaredLength=p.squaredLength;s.sqrLen=s.squaredLength;s.normalize=p.normalize;s.fromMat3=function(a,b){var c=b[0]+b[4]+b[8];if(0&lt;c)c=Math.sqrt(c+1),a[3]=.5*c,c=.5/c,a[0]=(b[7]-b[5])*c,a[1]=(b[2]-b[6])*c,a[2]=(b[3]-b[1])*c;else{var d= 0;b[4]>b[0]&amp;&amp;(d=1);b[8]>b[3*d+d]&amp;&amp;(d=2);var e=(d+1)%3,f=(d+2)%3,c=Math.sqrt(b[3*d+d]-b[3*e+e]-b[3*f+f]+1);a[d]=.5*c;c=.5/c;a[3]=(b[3*f+e]-b[3*e+f])*c;a[e]=(b[3*e+d]+b[3*d+e])*c;a[f]=(b[3*f+d]+b[3*d+f])*c}return a};s.str=function(a){return"quat("+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+")"};"undefined"!==typeof y&amp;&amp;(y.quat=s)})(H)})(this);

vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

mat4.fromRotationTranslationScale = function (out, q, v, s) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
  
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,
      
      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];
      
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;
        
  return out;
};

mat4.toRotationMat4 = (function () {
  var quadrent = mat3.create();
  
  return function (out, m) {
    mat3.fromMat4(quadrent, m);
    mat3.invert(quadrent, quadrent);
    
    out[0] = quadrent[0];
    out[1] = quadrent[1];
    out[2] = quadrent[2];
    out[3] = 1;
    out[4] = quadrent[3];
    out[5] = quadrent[4];
    out[6] = quadrent[5];
    out[7] = 1;
    out[8] = quadrent[6];
    out[9] = quadrent[7];
    out[10] = quadrent[8];
    out[11] = 1;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    
    return out;
  };
}());

quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

mat4.decomposeScale = function (out, m) {
  var m0 = m[0], m1 = m[1], m2 = m[2],
        m4 = m[4], m5 = m[5], m6 = m[6],
        m8 = m[8], m9 = m[9], m10 = m[10];
  
  out[0] = Math.sqrt(m0*m0 + m1*m1 + m2*m2);
  out[1] = Math.sqrt(m4*m4 + m5*m5 + m6*m6);
  out[2] = Math.sqrt(m8*m8 + m9*m9 + m10*m10);
  
  return out;
};

var math = (function () {
  var math = {};
  var TORAD = Math.PI / 180;
  var TODEG = 180 / Math.PI;
  
  math.floatPrecision = function (number, decimals) {
    var multiplier = Math.pow(10, decimals);
    
    return Math.round(number * multiplier) / multiplier;
  };
  
  math.floatPrecisionArray = function (a, decimals) {
    var multiplier = Math.pow(10, decimals);
    var res = [];
    
    for (var i = 0, l = a.length; i &lt; l; i++) {
      res[i] = Math.round(a[i] * multiplier) / multiplier;
    }
    
    return res;
  };

  math.random = function (a, b) {
    return a + Math.random() * (b - a);
  };

  math.clamp = function (x, minVal, maxVal) {
    return Math.min(Math.max(x, minVal), maxVal);
  };

  math.lerp = function (a, b, t) {
    return a + t * (b - a);
  };

  math.hermite = function (a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    
    return (a * factor1) + (b * factor2) + (c * factor3) + (d * factor4);
  };

  math.bezier = function (a, b, c, d, t) {
    var invt = 1 - t;
    var factorTimes2 = t * t;
    var inverseFactorTimesTwo = invt * invt;
    var factor1 = inverseFactorTimesTwo * invt;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * invt;
    var factor4 = factorTimes2 * t;
    
    return (a * factor1) + (b * factor2) + (c * factor3) + (d * factor4);
  };

  math.toRad = function (degrees) {
    var i,
          l,
          arr;
    
    if (typeof degrees === "number") {
      return degrees * TORAD;
    } else {
      arr = [];
      
      for (i = 0, l = degrees.length; i &lt; l; i++) {
          arr[i] = degrees[i] * TORAD;
      }
      
      return arr;
    }
  };

  math.toDeg = function (radians) {
    var i,
          l,
          arr;
    
    if (typeof radians === "number") {
      return radians * TODEG;
    } else {
      arr = [];
      
      for (i = 0, l = radians.length; i &lt; l; i++) {
          arr[i] = radians[i] * TODEG;
      }
      
      return arr;
    }
  };
  
  math.sign = function (x) {
    return x === 0 ? 0 : (x &lt; 0 ? -1 : 1);
  };

  math.copysign = function (x, y) {
    var signy = sign(y);
    
    if (signy === 0) {
      return 0;
    }
    
    var signx = sign(x);
    
    if (signx !== signy) {
      return -x;
    }
    
    return x;
  };

  math.powerOfTwo = function (x) {
    x--;
    x |= x >> 1; 
    x |= x >> 2; 
    x |= x >> 4; 
    x |= x >> 8; 
    x |= x >> 16; 
    x++;
    
    return x;
  };

  return math;
}());

var interpolator = (function () {
  var zeroV = vec3.create();
  var zeroQ = quat.create();
    
  function scalar(a, b, c, d, t, type) {
    if (type === 0) {
      return a;
    } else if (type === 1) {
      return math.lerp(a, d, t);
    } else if (type === 2) {
      return math.hermite(a, b, c, d, t);
    } else if (type === 3) {
      return math.bezier(a, b, c, d, t);
    }
    
    return 0;
  }
  
  function vector(out, a, b, c, d, t, type) {
    if (type === 0) {
      return a;
    } else if (type === 1) {
      return vec3.lerp(out, a, d, t);
    } else if (type === 2) {
      return vec3.hermite(out, a, b, c, d, t);
    } else if (type === 3) {
      return vec3.bezier(out, a, b, c, d, t);
    }
    
    return zeroV;
	}
  
  function quaternion(out, a, b, c, d, t, type) {
    if (type === 0) {
      return a;
    } else if (type === 1) {
      return quat.slerp(out, a, d, t);
    } else if (type === 2 || type === 3) {
      return quat.sqlerp(out, a, b, c, d, t);
    }
    
    return zeroQ;
  }
  
  return function (out, a, b, c, d, t, type) {
    var length = a.length;
    
    if (length === 3) {
      return vector(out, a, b, c, d, t, type);
    } else if (length === 4) {
      return quaternion(out, a, b, c, d, t, type);
    } else {
      return scalar(a, b, c, d, t, type);
    }
  }
}());

/**
 * A simple binary reader.
 *
 * @class BinaryReader
 * @param {ArrayByffer} buffer The internal buffer this reader uses.
 * @property {ArrayBuffer} buffer
 * @property {number} index
 * @property {DataView} dataview
 * @property {Uint8Array} uint8Array
 * @property {number} size
 */
function BinaryReader(buffer) {
  this.buffer = buffer;
  this.index = 0;
  this.dataview = new DataView(buffer);
  this.uint8Array = new Uint8Array(buffer);
  this.size = buffer.byteLength;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @returns {number} The remaining bytes.
 */
function remaining(reader) {
  return reader.size - reader.index;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} bytes Bytes to skip.
 */
function skip(reader, bytes) {
  reader.index += bytes;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} index Where to seek to.
 */
function seek(reader, index) {
  reader.index = index;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The reader's position.
 */
function tell(reader) {
  return reader.index;
}

/**
 * @param {Uint8Array} bytes Bytes to convert.
 * @return {string} A string representation of the input bytes.
 */
function bytesToString(bytes) {
  var i, l, b, buffer = "";
  
  for (var i = 0, l = bytes.length; i &lt; l; i++) {
    b = bytes[i];
    
    // Avoid \0
    if (b > 0) {
      buffer += String.fromCharCode(b);
    }
  }
  
  return buffer;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} size Number of bytes to read.
 * @return {string} The read string.
 */
function read(reader, size) {
  var data = bytesToString(reader.uint8Array.subarray(reader.index, reader.index + size));
  
  reader.index += size;
  
  return data;
}

/**
 * Reads a string, but does not advance the reader's position.
 *
 * @param {BinaryReader} reader Binary reader.
 * @param {number} size Number of bytes to read.
 * @return {string} The read string.
 */
function peek(reader, size) {
  return bytesToString(reader.uint8Array.subarray(reader.index, reader.index + size));
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readInt8(reader) {
  var data = reader.dataview.getInt8(reader.index, true);
  
  reader.index += 1;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readInt16(reader) {
  var data = reader.dataview.getInt16(reader.index, true);
  
  reader.index += 2;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readInt32(reader) {
  var data = reader.dataview.getInt32(reader.index, true);
  
  reader.index += 4;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readUint8(reader) {
  var data = reader.dataview.getUint8(reader.index, true);
  
  reader.index += 1;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readUint16(reader) {
  var data = reader.dataview.getUint16(reader.index, true);
  
  reader.index += 2;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readUint32(reader) {
  var data = reader.dataview.getUint32(reader.index, true);
  
  reader.index += 4;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readFloat32(reader) {
  var data = reader.dataview.getFloat32(reader.index, true);
  
  reader.index += 4;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {number} The read number.
 */
function readFloat64(reader) {
  var data = reader.dataview.getFloat64(reader.index, true);
  
  reader.index += 8;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Int8Array} The read array.
 */
function readInt8Array(reader, count) {
  var i, data = new Int8Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getInt8(reader.index + i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Int16Array} The read array.
 */
function readInt16Array(reader, count) {
  var i, data = new Int16Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getInt16(reader.index + 2 * i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Int32Array} The read array.
 */
function readInt32Array(reader, count) {
  var i, data = new Int32Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getInt32(reader.index + 4 * i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Uint8Array} The read array.
 */
function readUint8Array(reader, count) {
  var i, data = new Uint8Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getUint8(reader.index + i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Uint16Array} The read array.
 */
function readUint16Array(reader, count) {
  var i, data = new Uint16Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getUint16(reader.index + 2 * i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Uint32Array} The read array.
 */
function readUint32Array(reader, count) {
  var i, data = new Uint32Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getUint32(reader.index + 4 * i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Float32Array} The read array.
 */
function readFloat32Array(reader, count) {
  var i, data = new Float32Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getFloat32(reader.index + 4 * i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Array size.
 * @return {Float64Array} The read array.
 */
function readFloat64Array(reader, count) {
  var i, data = new Float64Array(count);
  
  for (i = 0; i &lt; count; i++) {
    data[i] = reader.dataview.getFloat64(reader.index + 8 * i, true);
  }
  
  reader.index += data.byteLength;
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Int8Array.
 */
function readInt8Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readInt8Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Int16Array.
 */
function readInt16Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readInt16Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Int32Array.
 */
function readInt32Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readInt32Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Uint8Array.
 */
function readUint8Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readUint8Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Uint16Array.
 */
function readUint16Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readUint16Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Uint32Array.
 */
function readUint32Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readUint32Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Float32Array.
 */
function readFloat32Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readFloat32Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @param {number} count Rows.
 * @param {number} size Columns.
 * @return {array} The read array of Float64Array.
 */
function readFloat64Matrix(reader, count, size) {
  var i, data = [];
  
  for (i = 0; i &lt; count; i++) {
    data[i] = readFloat64Array(reader, size);
  }
  
  return data;
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {Float32Array} The read array.
 */
function readVector2(reader) {
  return readFloat32Array(reader, 2);
}
  
/**
 * @param {BinaryReader} reader Binary reader.
 * @return {Float32Array} The read array.
 */
function readVector3(reader) {
  return readFloat32Array(reader, 3);
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {Float32Array} The read array.
 */
function readVector4(reader) {
  return readFloat32Array(reader, 4);
}

/**
 * @param {BinaryReader} reader Binary reader.
 * @return {Float32Array} The read array.
 */
function readMatrix(reader) {
  return readFloat32Array(reader, 16);
}

/**
 * Mixes one object onto another.
 * If the destination already defines a property, it wont be copied from the source.
 *
 * @param {object} mixer The source.
 * @param {object} mixed The destination.
 */
function mixin(mixer, mixed) {
  var properties = Object.getOwnPropertyNames(mixer),
        property,
        i,
        l;
  
  for (i = 0, l = properties.length; i &lt; l; i++) {
    property = properties[i];
    
    // Allow the target to override properties
    if (!mixed[property]) {
      mixed[property] = mixer[property];
    }
  }
}

function getNamesFromObjects(objects) {
  var names = [],
        i,
        l;
  
  if (objects) {
    for (i = 0, l = objects.length; i &lt; l; i++) {
      names[i] = objects[i].name;
    }
  }
  
  return names;
}

/**
 * Encodes two 0-255 numbers into one.
 *
 * @param {number} x The first number.
 * @param {number} y The second number.
 * @returns {number} The encoded number.
 */
function encodeFloat2(x, y) {
  return x + y * 256;
}

/**
 * Decodes a previously encoded number into the two original numbers.
 *
 * @param {number} f The input.
 * @returns {array} The two decoded numbers.
 */
function decodeFloat2(f) {
  var v = [];
  
  v[1] = Math.floor(f / 256);
  v[0] = Math.floor(f - v[1] * 256);
  
  return v;
}

/**
 * Encodes three 0-255 numbers into one.
 *
 * @param {number} x The first number.
 * @param {number} y The second number.
 * @param {number} z The third number.
 * @returns {number} The encoded number.
 */
function encodeFloat3(x, y, z) {
  return x + y * 256 + z * 65536;
}

/**
 * Decodes a previously encoded number into the three original numbers.
 *
 * @param {number} f The input.
 * @returns {array} The three decoded numbers.
 */
function decodeFloat3(f) {
  var v = [];
  
  v[2] = Math.floor(f / 65536);
  v[1] = Math.floor((f - v[2] * 65536) / 256);
  v[0] = Math.floor(f - v[2] * 65536 - v[1] * 256);
  
  return v;
}

/**
 * Gets the file name from a file path.
 *
 * @param {string} source The file path.
 * @returns {string} The file name.
 */
function getFileName(source) {
  var tokens = source.split(/[\\\/]/g);
  
  return tokens[tokens.length - 1];
}

/**
 * Gets the file extention from a file path.
 *
 * @param {string} source The file path.
 * @returns {string} The file extension.
 */
function getFileExtension(source) {
  var tokens = source.split(".");
  
  return tokens[tokens.length - 1];
}

if (typeof String.prototype.endsWith !== "function") {
  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };
}

if (!window.requestAnimationFrame ) {
  window.requestAnimationFrame = (function() {
    return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) { window.setTimeout(callback, 1000 / 60); };
  }());
}

/**
 * Parses all of the url parameters and returns a map.
 *
 * @returns {string} The parameters map.
 */
function getUrlVariables() {
  var urlMap = {};
  var searchstr = window.location.search.substring(1);
  var variables = searchstr.split("&amp;");
  var i, l, keyval;
    
  for (i = 0, l = variables.length; i &lt; l; i++){
      keyval = variables[i].split("=");
      
      urlMap[keyval[0]] = keyval[1] || 1;
  }
  
  return urlMap;
}

/**
 * Goes over the DOM, and returns a map of all the elements with IDs, such that map[elementId]=element.
 *
 * @returns {object} The DOM map.
 */
function getDom() {
  var dom = {};
  var elements = document.getElementsByTagName("*");
  var i, element;
    
  for (i = elements.length; i--;) {
    element = elements[i];
    
    if (element.id) {
      dom[element.id] = element;
    }
  }
  
  return dom;
}

/**
 * Sends an XHR2 request.
 *
 * @param {string} path The url to request.
 * @param {boolean} binary If true, the request type will be arraybuffer.
 * @param {function} onload onload callback.
 * @param {function} onerror onerror callback.
 * @param {function} onprogress onprogress callback.
 */
function getFile(path, binary, onload, onerror, onprogress) {
  var xhr = new XMLHttpRequest();
  
  if (onload) {
    xhr.addEventListener("load", onload, false);
  }
  
  if (onerror) {
    xhr.addEventListener("error", onerror, false);
  }
  
  if (onprogress) {
    xhr.addEventListener("progress", onprogress, false);
  }
  
  xhr.open("GET", path, true);
  
  if (binary) {
    xhr.responseType = "arraybuffer";
  }
  
  xhr.send();
}

function addEvent(element, event, callback) {
  // No mousewheel in Firefox
  if (event === "mousewheel") {
    element.addEventListener("DOMMouseScroll", callback, false);
  }
  
  element.addEventListener(event, callback, false);
}

function removeEvent(element, event, callback) {
  if (event === "mousewheel") {
    element.removeEventListener("DOMMouseScroll", callback, false);
  }
  
  element.removeEventListener(event, callback, false);
}

function preventDefault(e) {
  e.preventDefault();
}

/**
 * A very simple string hashing algorithm.
 *
 * @param {string} s String to hash.
 * @returns {number} The string hash.
 */
String.hashCode = function(s) {
  var hash = 0;
  
  for (var i = 0, l = s.length; i &lt; l; i++) {
    hash = hash * 31 + s.charCodeAt(i);
    hash = hash &amp; hash;
  }
  
  return hash;
};

if (typeof String.prototype.startsWith != "function") {
  String.prototype.startsWith = function (what) {
    return this.lastIndexOf(what, 0) === 0;
  };
}

/**
 * A deep Object copy.
 *
 * @param {object} object The object to copy.
 * @returns {object} The copied object.
 */
Object.copy = function (object) {
  var keys = Object.keys(object);
  var newObj = (object instanceof Array) ? [] : {};
  var i, l, key;
    
  for (i = 0, l = keys.length; i &lt; l; i++) {
    key = keys[i];
    
    if (typeof key === "object") {
      newObj[key] = Object.copy(object[key]);
    } else {
      newObj[key] = object[key];
    }
  }

  return newObj;
};

/**
 * A shallow Array equality check.
 *
 * @param {array} a First array.
 * @param {array} b Second array.
 * @returns {boolean} The result.
 */
Array.equals = function (a, b) {
  var i, l;
  
  if (!a || !b || a.length !== b.length) {
    return false;
  }
  
  for (i = 0, l = a.length; i &lt; l; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  
  return true;
};

/**
 * A shallow Array copy.
 *
 * @param {array} a The array to copy.
 * @returns {array} The copied array.
 */
Array.copy = function (a) {
  var newArray = [];
  var i, l;
  
  for (i = 0, l = a.length; i &lt; l; i++) {
    newArray[i] = a[i];
  }
  
  return newArray;
};

/**
 * Creates a new BaseModel.
 *
 * @class A skeleton model. Can be used to help extending the viewer with new model types.
 * @name BaseModel
 * @param {object} textureMap An object with texture path -> absolute urls mapping.
 * @property {string} name
 * @property {array} meshes
 * @property {array} sequences
 * @property {array} textures
 * @property {array} cameras
 * @property {array} boundingShapes
 * @property {array} attachments
 * @property {object} textureMap
 */
window["BaseModel"] = function (textureMap) {
  this.name = "";
  this.meshes = [];
  this.sequences = [];
  this.textures = [];
  this.cameras = [];
  this.boundingShapes = [];
  this.attachments = [];
  this.textureMap = textureMap;
}

BaseModel.prototype = {
  /**
    * Render a model for some specific model instance.
    *
    * @param {BaseModelInstance} instance The instance that is getting rendered.
    * @param {object} context An object containing the global state of the viewer.
    */
  render: function(instance, context) {
  
  },

  /**
    * Render a model's particle emitters for some specific model instance.
    *
    * @param {BaseModelInstance} instance The instance that is getting rendered.
    * @param {object} context An object containing the global state of the viewer.
    */
  renderEmitters: function(instance, context) {
    
  },

  /**
    * Render a model's bounding shapes o for some specific model instance.
    *
    * @param {BaseModelInstance} instance The instance that is getting rendered.
    * @param {object} context An object containing the global state of the viewer.
    */
  renderBoundingShapes: function(instance, context) {
    
  },

  /**
    * Render a model with a specific color for some specific model instance.
    * This is used for color picking.
    *
    * @param {BaseModelInstance} instance The instance that is getting rendered.
    * @param {vec3} color A RGB color in which the model should be rendered.
    * @param {object} context An object containing the global state of the viewer.
    */
  renderColor: function(instance, color, context) {
    
  },

  /**
    * Gets the name of a model.
    *
    * @returns {string} The model's name.
    */
  getName: function() {
    return this.name;
  },

  /**
    * Gets a model's attachment.
    *
    * @param {number} id The id of the attachment.
    * @returns {Node} The attachment.
    */
  getAttachment: function(id) {
    return this.attachments[id];
  },

  /**
    * Gets a model's camera.
    *
    * @param {number} id The id of the camera.
    * @returns {Camera} The camera.
    */
  getCamera: function(id) {
      return this.cameras[id];
  },

  /**
    * Overrides a texture used by a model.
    *
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  overrideTexture: function(path, override) {
    this.textureMap[path] = override;
  },

  /**
    * Gets a model's texture map.
    *
    * @returns {object} The texture map.
    */
  getTextureMap: function() {
    return Object.copy(this.textureMap);
  },

  /**
    * Gets a model's sequences list.
    *
    * @returns {array} The list of sequence names.
    */
  getSequences: function() {
    return getNamesFromObjects(this.sequences);
  },

  /**
    * Gets a model's attachments list.
    *
    * @returns {array} The list of attachment names.
    */
  getAttachments: function() {
    return getNamesFromObjects(this.attachments);
  },
  
  /**
    * Gets a model's bounding shapes list.
    *
    * @returns {array} The list of bounding shape names.
    */
  getBoundingShapes: function() {
    return getNamesFromObjects(this.boundingShapes);
  },
  
  /**
    * Gets a model's cameras list.
    *
    * @returns {array} The list of camera names.
    */
  getCameras: function() {
    return getNamesFromObjects(this.cameras);
  },

  /**
    * Gets a model's number of meshes.
    *
    * @returns {number} The number of meshes.
    */
  getMeshCount: function() {
    return this.meshes.length;
  }
};

/**
 * Creates a new BaseModelInstance.
 *
 * @class A skeleton model instance. Can be used to help extending the viewer with new model types.
 * @name BaseModelInstance
 * @param {BaseModel} model The model this instance points to.
 * @param {object} textureMap An object with texture path -> absolute urls mapping.
 * @property {BaseModel} model
 * @property {object} textureMap
 * @property {number} sequence
 * @property {number} frame
 * @property {number} sequenceLoopMode
 * @property {number} teamColor
 * @property {array} meshVisibilities
 */
window["BaseModelInstance"] = function (model, textureMap) {
    var i,
          l;
    
    this.model = model;
    this.textureMap = textureMap;
    this.sequence = -1;
    this.frame = 0;
    this.sequenceLoopMode = 0;
    this.teamColor = 0;
    this.meshVisibilities = [];
    
    for (i = 0, l = model.getMeshCount(); i &lt; l; i++) {
      this.meshVisibilities[i] = true;
    }
}

BaseModelInstance.prototype = {
  /**
    * Updates a model instance.
    *
    * @param {mat4} worldMatrix The world matrix of the parent {@link AsyncModelInstance}.
    * @param {object} context An object containing the global state of the viewer.
    */
  update: function(worldMatrix, context) {
    
  },

  /**
    * Render the model a model instance points to.
    *
    * @param {object} context An object containing the global state of the viewer.
    */
  render: function(context) {
    this.model.render(this, context);
  },

  /**
    * Render the particle emitters of the model a model instance points to.
    *
    * @param {object} context An object containing the global state of the viewer.
    */
  renderEmitters: function(context) {
    this.model.renderEmitters(this, context);
  },

  /**
    * Render the bounding shapes of the model a model instance points to.
    *
    * @param {object} context An object containing the global state of the viewer.
    */
  renderBoundingShapes: function(context) {
    this.model.renderBoundingShapes(this, context);
  },

  /**
    * Render the model a model instance points to, with a specific color.
    *
    * @param {vec3} color A RGB color.
    * @param {object} context An object containing the global state of the viewer.
    */
  renderColor: function(color, context) {
    this.model.renderColor(this, color, context);
  },

  /**
    * Gets the name of the model a model instance points to.
    *
    * @returns {string} The model's name.
    */
  getName: function() {
    return this.model.getName();
  },

  /**
    * Overrides a texture used by a model instance.
    *
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  overrideTexture: function(path, override) {
    this.textureMap[path] = override;
  },

  /**
    * Gets a model instance's texture map.
    *
    * @returns {object} The texture map.
    */
  getTextureMap: function() {
    return Object.copy(this.textureMap);
  },

  /**
    * Set the team color of a model instance.
    *
    * @param {number} id The team color.
    */
  setTeamColor: function(id) {
    
  },

  /**
    * Gets the team color of a model instance.
    *
    * @returns {number} The team.
    */
  getTeamColor: function() {
    return this.teamColor;
  },

  /**
    * Set the sequence of a model instance.
    *
    * @param {number} id The sequence.
    */
  setSequence: function(id) {
    
  },

  /**
    * Gets the sequence of a model instance.
    *
    * @returns {number} The sequence.
    */
  getSequence: function() {
    return this.sequence;
  },

  /**
    * Set the sequence loop mode of a model instance.
    *
    * @param {number} mode The sequence loop mode.
    */
  setSequenceLoopMode: function(mode) {
    this.sequenceLoopMode = mode;
  },

  /**
    * Gets the sequence loop mode of a model instance.
    *
    * @returns {number} The sequence loop mode.
    */
  getSequenceLoopMode: function() {
    return this.sequenceLoopMode;
  },

  /**
    * Gets a model instance's attachment.
    *
    * @param {number} id The id of the attachment.
    * @returns {Node} The attachment.
    */
  getAttachment: function(id) {
    
  },
  
  /**
    * Gets a model instance's camera.
    *
    * @param {number} id The id of the camera.
    * @returns {Camera} The camera.
    */
  getCamera: function (id) {
    
  },
  
  /**
    * Set a model instance's mesh's visibility.
    *
    * @param {number} id The mesh.
    * @param {boolean} mode The visibility mode
    */
  setMeshVisibility: function(id, mode) {
    this.meshVisibilities[id] = mode;
  },

  /**
    * Gets a model instance's mesh's visibility
    *
    * @param {number} id The mesh.
    * @returns {boolean} The mesh's visiblity.
    */
  getMeshVisibility: function(id) {
    return this.meshVisibilities[id];
  },
  
  /**
    * Gets all the mesh visibilities of a model instance.
    *
    * @returns {array} The mesh visibilities.
    */
  getMeshVisibilities: function() {
    return Array.copy(this.meshVisibilities);
  }
};

/**
 * @class A wrapper around WebGL.
 * @name GL
 * @param {HTMLCanvasElement} element A canvas element.
 * @param {function} onload A callback function.
 * @param {function} onerror A callback function.
 * @param {function} onprogress A callback function.
 * @param {function} onloadstart A callback function.
 * @param {function} onunload A callback function.
 * @property {WebGLRenderingContext} ctx
 */
function GL(element, onload, onerror, onprogress, onloadstart, onunload) {
  var ctx;
  var identifiers = ["webgl", "experimental-webgl"];
  
  for (var i = 0, l = identifiers.length; i &lt; l; ++i) {
    try {
      ctx = element.getContext(identifiers[i], {antialias: true, alpha: false});
    } catch(e) {}

    if (ctx) {
      break;
    }
  }
  
  if (!ctx) {
    onerror({isWebGL: true}, "WebGLContext");
    return;
  }
  
  var hasVertexTexture = ctx.getParameter(ctx.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
  var hasFloatTexture = ctx.getExtension("OES_texture_float");
  var compressedTextures = ctx.getExtension("WEBGL_compressed_texture_s3tc");
  
  if (!hasVertexTexture) {
    onerror({isWebGL: true}, "VertexTexture");
    return;
  }
  
  if (!hasFloatTexture) {
    onerror({isWebGL: true}, "FloatTexture");
    return;
  }
  
  if (!compressedTextures) {
    onerror({isWebGL: true}, "CompressedTextures");
  }
  
  var refreshViewProjectionMatrix = false;
  var projectionMatrix = mat4.create();
  var viewMatrix = mat4.create();
  var viewProjectionMatrix = mat4.create();
  var matrixStack = [];
  var textureStore = {};
  var textureLoading = {};
  var shaderUnitStore = {};
  var shaderStore = {};
  var boundShader;
  var boundShaderName = "";
  var boundTextures = [];
  var floatPrecision = "precision mediump float;\n";
  var textureHandlers = {};
    
  ctx.viewport(0, 0, element.clientWidth, element.clientHeight);
  ctx.depthFunc(ctx.LEQUAL);
  ctx.enable(ctx.DEPTH_TEST);
  ctx.enable(ctx.CULL_FACE);
  
  function textureOptions(wrapS, wrapT, magFilter, minFilter) {
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, wrapS);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, wrapT);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, magFilter);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, minFilter);
  }

/**
 * @memberof GL
 * @class A wrapper around WebGL shader units.
 * @name ShaderUnit
 * @param {string} source The GLSL source.
 * @param {number} type The WebGL shader unit identifier - VERTEX_SHADER or FRAGMENT_SHADER.
 * @param {string} name The owning shader's name.
 * @property {string} source
 * @property {number} type
 * @property {WebGLShader} id
 * @property {boolean} ready
 */
function ShaderUnit(source, type, name) {
  var id = ctx.createShader(type);
  
  this.source = source;
  this.type = type;
  this.id = id;
  
  ctx.shaderSource(id, source);
  ctx.compileShader(id);
  
  if (ctx.getShaderParameter(id, ctx.COMPILE_STATUS)) {
    this.ready = true;
  } else {
    //console.warn("Failed to compile a shader:");
    //console.warn(name, ctx.getShaderInfoLog(this.id));
    //console.warn(source);
    onerror({isShader: true, source: name}, "Compile");
  }
}

/**
 * @memberof GL
 * @class A wrapper around WebGL shader programs.
 * @name Shader
 * @param {string} name The shader's name.
 * @param {GL.ShaderUnit} vertexUnit The vertex shader unit.
 * @param {GL.ShaderUnit} fragmentUnit The fragment shader unit.
 * @property {string} name
 * @property {GL.ShaderUnit} vertexUnit
 * @property {GL.ShaderUnit} fragmentUnit
 * @property {WebGLProgram} id
 * @property {object} variables
 * @property {number} attribs
 * @property {boolean} ready
 */
function Shader(name, vertexUnit, fragmentUnit) {
  var id = ctx.createProgram();
  
  this.name = name;
  this.vertexUnit = vertexUnit;
  this.fragmentUnit = fragmentUnit;
  this.id = id;
    
  ctx.attachShader(id, vertexUnit.id);
  ctx.attachShader(id, fragmentUnit.id);
  ctx.linkProgram(id);
  
  if (ctx.getProgramParameter(id, ctx.LINK_STATUS)) {
    this.getVariables();
    this.ready = true;
  } else {
    //console.warn(name, ctx.getProgramInfoLog(this.id));
    onerror({isShader: true, source: name}, "Link");
  }
}

Shader.prototype = {
  getVariables: function () {
    var id = this.id;
    var variables = {};
    var i, l, v, location;
      
    for (i = 0, l = ctx.getProgramParameter(id, ctx.ACTIVE_UNIFORMS); i &lt; l; i++) {
      v = ctx.getActiveUniform(id, i);
      location = ctx.getUniformLocation(id, v.name);
      
      variables[v.name] = location;
    }
    
    l = ctx.getProgramParameter(id, ctx.ACTIVE_ATTRIBUTES);
    
    for (i = 0; i &lt; l; i++) {
      v = ctx.getActiveAttrib(id, i);
      location = ctx.getAttribLocation(id, v.name);
      
      variables[v.name] = location;
    }
    
    this.variables = variables;
    this.attribs = l;
  }
};

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
   Copyright 2011 notmasteryet

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

// NOTE: This file was edited to match the crude usage of the JPG format by Blizzard for their BLP1 format.

var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
     0,
     1,  8,
    16,  9,  2,
     3, 10, 17, 24,
    32, 25, 18, 11, 4,
     5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13,  6,
     7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1  =  4017   // cos(pi/16)
  var dctSin1  =   799   // sin(pi/16)
  var dctCos3  =  3406   // cos(3*pi/16)
  var dctSin3  =  2276   // sin(3*pi/16)
  var dctCos6  =  1567   // cos(6*pi/16)
  var dctSin6  =  3784   // sin(6*pi/16)
  var dctSqrt2 =  5793   // sqrt(2)
  var dctSqrt1d2 = 2896  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 &amp;&amp; !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i &lt; length; i++) {
      for (j = 0; j &lt; codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length &lt;= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 &lt; length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) &amp; 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw "unexpected marker: " + ((bitsData &lt;&lt; 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;
      var bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw "invalid huffman sequence";
      }
      return null;
    }

    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null) return;
        n = (n &lt;&lt; 1) | bit;
        length--;
      }
      return n;
    }

    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 &lt;&lt; (length - 1))
        return n;
      return n + (-1 &lt;&lt; length) + 1;
    }

    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = (component.pred += diff);
      var k = 1;
      while (k &lt; 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs &amp; 15, r = rs >> 4;
        if (s === 0) {
          if (r &lt; 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) &lt;&lt; successive);
      component.blockData[offset] = (component.pred += diff);
    }

    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() &lt;&lt; successive;
    }

    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k &lt;= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs &amp; 15, r = rs >> 4;
        if (s === 0) {
          if (r &lt; 15) {
            eobrun = receive(r) + (1 &lt;&lt; r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 &lt;&lt; successive);
        k++;
      }
    }

    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k &lt;= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
        case 0: // initial state
          var rs = decodeHuffman(component.huffmanTableAC);
          var s = rs &amp; 15, r = rs >> 4;
          if (s === 0) {
            if (r &lt; 15) {
              eobrun = receive(r) + (1 &lt;&lt; r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1)
              throw "invalid ACn encoding";
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1: // skipping r zero items
        case 2:
          if (component.blockData[offset + z]) {
            component.blockData[offset + z] += (readBit() &lt;&lt; successive);
          } else {
            r--;
            if (r === 0)
              successiveACState = successiveACState == 2 ? 3 : 0;
          }
          break;
        case 3: // set value for a zero item
          if (component.blockData[offset + z]) {
            component.blockData[offset + z] += (readBit() &lt;&lt; successive);
          } else {
            component.blockData[offset + z] = successiveACNextValue &lt;&lt; successive;
            successiveACState = 0;
          }
          break;
        case 4: // eob
          if (component.blockData[offset + z]) {
            component.blockData[offset + z] += (readBit() &lt;&lt; successive);
          }
          break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) {
      resetInterval = mcuExpected;
    }

    var h, v;
    while (mcu &lt; mcuExpected) {
      // reset interval stuff
      for (i = 0; i &lt; componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n &lt; resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n &lt; resetInterval; n++) {
          for (i = 0; i &lt; componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j &lt; v; j++) {
              for (k = 0; k &lt; h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] &lt;&lt; 8) | data[offset + 1];
      if (marker &lt;= 0xFF00) {
        throw "marker was not found";
      }

      if (marker >= 0xFFD0 &amp;&amp; marker &lt;= 0xFFD7) { // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech &amp; Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable;
    var v0, v1, v2, v3, v4, v5, v6, v7, t;
    var i;

    // dequant
    for (i = 0; i &lt; 64; i++) {
      p[i] = component.blockData[blockBufferOffset + i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i &lt; 8; ++i) {
      var row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] == 0 &amp;&amp; p[2 + row] == 0 &amp;&amp; p[3 + row] == 0 &amp;&amp;
          p[4 + row] == 0 &amp;&amp; p[5 + row] == 0 &amp;&amp; p[6 + row] == 0 &amp;&amp;
          p[7 + row] == 0) {
        t = (dctSqrt2 * p[0 + row] + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
      v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
      v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
      v5 = p[3 + row] &lt;&lt; 4;
      v6 = p[5 + row] &lt;&lt; 4;

      // stage 3
      t = (v0 - v1+ 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i &lt; 8; ++i) {
      var col = i;

      // check for all-zero AC coefficients
      if (p[1*8 + col] == 0 &amp;&amp; p[2*8 + col] == 0 &amp;&amp; p[3*8 + col] == 0 &amp;&amp;
          p[4*8 + col] == 0 &amp;&amp; p[5*8 + col] == 0 &amp;&amp; p[6*8 + col] == 0 &amp;&amp;
          p[7*8 + col] == 0) {
        t = (dctSqrt2 * p[i+0] + 8192) >> 14;
        p[0*8 + col] = t;
        p[1*8 + col] = t;
        p[2*8 + col] = t;
        p[3*8 + col] = t;
        p[4*8 + col] = t;
        p[5*8 + col] = t;
        p[6*8 + col] = t;
        p[7*8 + col] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
      v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
      v2 = p[2*8 + col];
      v3 = p[6*8 + col];
      v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
      v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
      v5 = p[3*8 + col];
      v6 = p[5*8 + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0*8 + col] = v0 + v7;
      p[7*8 + col] = v0 - v7;
      p[1*8 + col] = v1 + v6;
      p[6*8 + col] = v1 - v6;
      p[2*8 + col] = v2 + v5;
      p[5*8 + col] = v2 - v5;
      p[3*8 + col] = v3 + v4;
      p[4*8 + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i &lt; 64; ++i) {
      var index = blockBufferOffset + i;
      var q = p[i];
      q = (q &lt;= -2056) ? 0 : (q >= 2024) ? 255 : (q + 2056) >> 4;
      component.blockData[index] = q;
    }
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine &lt;&lt; 3;
    var computationBuffer = new Int32Array(64);

    var i, j, ll = 0;
    for (var blockRow = 0; blockRow &lt; blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol &lt; blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol)
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }

  function clampToUint8(a) {
    return a &lt;= 0 ? 0 : a >= 255 ? 255 : a | 0;
  }

  constructor.prototype = {
    load: function load(path) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = (function() {
        // TODO catch parse error
        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);
      xhr.send(null);
    },
    
    loadFromBuffer: function loadFromBuffer(arrayBuffer) {
      this.parse(arrayBuffer);
        if (this.onload)
          this.onload();
    },

    parse: function parse(data) {

      function readUint16() {
        var value = (data[offset] &lt;&lt; 8) | data[offset + 1];
        offset += 2;
        return value;
      }

      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i &lt; frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;

          var blocksBufferSize = 64 * blocksPerColumnForMcu
                                    * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0, length = data.length;
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw "SOI not found";
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch(fileMarker) {
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();
          
            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A &amp;&amp; appData[1] === 0x46 &amp;&amp; appData[2] === 0x49 &amp;&amp;
                appData[3] === 0x46 &amp;&amp; appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: { major: appData[5], minor: appData[6] },
                  densityUnits: appData[7],
                  xDensity: (appData[8] &lt;&lt; 8) | appData[9],
                  yDensity: (appData[10] &lt;&lt; 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 &amp;&amp; appData[1] === 0x64 &amp;&amp; appData[2] === 0x6F &amp;&amp;
                appData[3] === 0x62 &amp;&amp; appData[4] === 0x65 &amp;&amp; appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] &lt;&lt; 8) | appData[8],
                  flags1: (appData[9] &lt;&lt; 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset &lt; quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j &lt; 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j &lt; 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = readUint16();
                }
              } else
                throw "DQT: invalid table spec";
              quantizationTables[quantizationTableSpec &amp; 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw "Only single frame JPEGs supported";
            }
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i &lt; componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] &amp; 15;
              if (maxH &lt; h) maxH = h;
              if (maxV &lt; v) maxV = v;
              var qId = data[offset + 2];
              var l = frame.components.push({
                h: h,
                v: v,
                quantizationTable: quantizationTables[qId]
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i &lt; huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j &lt; 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j &lt; codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec &amp; 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i &lt; selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec &amp; 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation &amp; 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &amp;&amp;
                data[offset - 2] >= 0xC0 &amp;&amp; data[offset - 2] &lt;= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw "unknown JPEG marker " + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      for (var i = 0; i &lt; frame.components.length; i++) {
        var component = frame.components[i];
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn
        });
      }
    },

    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint8Array((this.components[0].blocksPerLine &lt;&lt; 3) *
                                    this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i &lt; numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine &lt;&lt; 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow &lt; blocksPerColumn; blockRow++) {
          var scanLine = blockRow &lt;&lt; 3;
          for (var blockCol = 0; blockCol &lt; blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol &lt;&lt; 3;
            for (j = 0; j &lt; 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k &lt; 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++];
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y &lt; height; y++) {
          for (x = 0; x &lt; width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }
       
/*
      // ... then transform colors, if necessary
      switch (numComponents) {
        case 1: case 2: break;
        // no color conversion for one or two compoenents

        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe &amp;&amp; this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;
        
          if (colorTransform) {
            for (i = 0; i &lt; dataLength; i += numComponents) {
              Y  = data[i    ];
              Cb = data[i + 1];
              Cr = data[i + 2];

              R = clampToUint8(Y - 179.456 + 1.402 * Cr);
              G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
              B = clampToUint8(Y - 226.816 + 1.772 * Cb);

              data[i    ] = R;
              data[i + 1] = G;
              data[i + 2] = B;
            }
          }
          break;
        case 4:
          console.log(this.colorTransform);
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe &amp;&amp; this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i &lt; dataLength; i += numComponents) {
              Y  = data[i];
              Cb = data[i + 1];
              Cr = data[i + 2];

              C = clampToUint8(434.456 - Y - 1.402 * Cr);
              M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
              Y = clampToUint8(481.816 - Y - 1.772 * Cb);

              data[i    ] = C;
              data[i + 1] = M;
              data[i + 2] = Y;
              // K is unchanged
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      */
      return data;
    },
    copyToImageData: function copyToImageData(imageData) {
      var width = imageData.width, height = imageData.height;
      var imageDataBytes = width * height * 4;
      var imageDataArray = imageData.data;
      var data = this.getData(width, height);
      var i = 0, j = 0, k0, k1;
      var Y, K, C, M, R, G, B;
      switch (this.components.length) {
        case 1:
          while (j &lt; imageDataBytes) {
            Y = data[i++];

            imageDataArray[j++] = Y;
            imageDataArray[j++] = Y;
            imageDataArray[j++] = Y;
            imageDataArray[j++] = 255;
          }
          break;
        case 3:
          while (j &lt; imageDataBytes) {
            R = data[i++];
            G = data[i++];
            B = data[i++];

            imageDataArray[j++] = R;
            imageDataArray[j++] = G;
            imageDataArray[j++] = B;
            imageDataArray[j++] = 255;
          }
          break;
        case 4:
          while (j &lt; imageDataBytes) {
            C = data[i++];
            M = data[i++];
            Y = data[i++];
            K = data[i++];

            k0 = 255 - K;
            k1 = k0 / 255;


            R = clampToUint8(k0 - C * k1);
            G = clampToUint8(k0 - M * k1);
            B = clampToUint8(k0 - Y * k1);

            imageDataArray[j++] = R;
            imageDataArray[j++] = G;
            imageDataArray[j++] = B;
            imageDataArray[j++] = 255;
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
    }
  };

  return constructor;
})();


function Texture(source, onload, onerror) {
  var image = new Image(),
        self = this;
        
  image.onload = function (e) {
    var id = ctx.createTexture();
    
    ctx.bindTexture(ctx.TEXTURE_2D, id);
    textureOptions(ctx.REPEAT, ctx.REPEAT, ctx.LINEAR, ctx.LINEAR_MIPMAP_LINEAR);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, image);
    ctx.generateMipmap(ctx.TEXTURE_2D);
    
    self.id = id;
    self.ready = true;
    
    // Because Texture is async, unlike all the other texture types, it must explicitly call onload
    onload({isTexture: 1, source: source});
  };
  
  image.onerror = function (e) {
    onerror({isTexture: 1, source: source}, "404");
  };
  
  image.src = source;
}

var BLP1_MAGIC = 0x31504c42;
var BLP_JPG = 0x0;
var BLP_PALLETE = 0x1;

/**
 * @memberof GL
 * @class A BLP1 texture decoder.
 * @name BLPTexture
 * @param {ArrayBuffer} arrayBuffer The raw texture data.
 * @param {object} options An object containing options.
 * @param {function} onerror A function that allows to report errors.
 * @property {WebGLTexture} id
 * @property {boolean} ready
 */
function BLPTexture(arrayBuffer, options, onerror) {
  var i;
  
  // If compression=0, the header size is 40
  // If compression=1, the header size is 39
  // Might as well make one typed array for both
  var header = new Int32Array(arrayBuffer, 0, 40);
  
  if (header[0] !== BLP1_MAGIC) {
    onerror("Format");
    return;
  }
  
  var arrayData = new Uint8Array(arrayBuffer);
  var compression = header[1];
  var width = header[3];
  var height = header[4];
  var pictureType = header[5];
  var mipmapOffset = header[7];
  var mipmapSize = header[23];
  var rgba8888Data;
  
  if (compression === BLP_JPG) {
    var jpegHeaderSize = header[39];
    var jpegHeader = new Uint8Array(arrayBuffer, 160, jpegHeaderSize)
    var jpegData = new Uint8Array(jpegHeaderSize + mipmapSize);
    
    jpegData.set(jpegHeader);
    jpegData.set(arrayData.subarray(mipmapOffset, mipmapOffset + mipmapSize), jpegHeaderSize);
    
    var jpegImage = new JpegImage();
    
    jpegImage.loadFromBuffer(jpegData);
    
    rgba8888Data = jpegImage.getData(jpegImage.width, jpegImage.height);
    
    // BGR -> RGB
    for (i = 0; i &lt; rgba8888Data.length; i += 4) {
      var b = rgba8888Data[i];

      rgba8888Data[i] = rgba8888Data[i + 2];
      rgba8888Data[i + 2] = b;
    }
  } else {
    var pallete = new Uint8Array(arrayBuffer, 156, 1024);
    var size = width * height;
    var mipmapAlphaOffset = mipmapOffset + size;
    var dstI;
    var hasAlpha = pictureType === 3 || pictureType === 4;
    
    rgba8888Data = new Uint8Array(size * 4);
    
    for (var index = 0; index &lt; size; index++) {
      i = arrayData[mipmapOffset + index] * 4;
      dstI = index * 4;
      
      // BGR -> RGB
      rgba8888Data[dstI] = pallete[i + 2];
      rgba8888Data[dstI + 1] = pallete[i + 1];
      rgba8888Data[dstI + 2] = pallete[i];
      
      if (hasAlpha) {
        rgba8888Data[dstI + 3] = arrayData[mipmapAlphaOffset + index]
      } else {
        rgba8888Data[dstI + 3] = 255 - pallete[i + 3];
      }
    }
  }
  
  var id = ctx.createTexture();
  ctx.bindTexture(ctx.TEXTURE_2D, id);
  textureOptions(ctx.REPEAT, ctx.REPEAT, ctx.LINEAR, ctx.LINEAR_MIPMAP_LINEAR);
  ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, width, height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, rgba8888Data);
  ctx.generateMipmap(ctx.TEXTURE_2D);
  
  this.id = id;
  this.ready = true;
}

// Note: This file is largely based on https://github.com/toji/webctx-texture-utils/blob/master/texture-util/dds.js

var DDS_MAGIC = 0x20534444;
  
var DDSD_MIPMAPCOUNT = 0x20000;

var DDPF_FOURCC = 0x4;

var FOURCC_DXT1 = 0x31545844;
var FOURCC_DXT3 = 0x33545844;
var FOURCC_DXT5 = 0x35545844;

function int32ToFourCC(value) {
  return String.fromCharCode(value &amp; 0xff, (value >> 8) &amp; 0xff,  (value >> 16) &amp; 0xff, (value >> 24) &amp; 0xff);
}

var int4to8 = 255 / 15;
var int5to8 = 255 / 31;
var int6to8 = 255 / 63;

// 4 bit alpha
function setRgba8888Dxt3(dst, i, int565, a) {
  dst[i] = Math.floor(((int565 >> 11) &amp; 31) * int5to8);
  dst[i + 1] = Math.floor(((int565 >> 5) &amp; 63) * int6to8);
  dst[i + 2] = Math.floor((int565 &amp; 31) * int5to8);
  dst[i + 3] = Math.floor(a * int4to8);
}

// 8 bit alpha
function setRgba8888Dxt5(dst, i, int565, a) {
  dst[i] = Math.floor(((int565 >> 11) &amp; 31) * int5to8);
  dst[i + 1] = Math.floor(((int565 >> 5) &amp; 63) * int6to8);
  dst[i + 2] = Math.floor((int565 &amp; 31) * int5to8);
  dst[i + 3] = a;
}

function dxt1ToRgb565(src, width, height) {
  var c = new Uint16Array(4);
  var dst = new Uint16Array(width * height);
  var m;
  var dstI;
  var i;
  var r0, g0, b0, r1, g1, b1;
  var blockWidth = width / 4;
  var blockHeight = height / 4;
  
  for (var blockY = 0; blockY &lt; blockHeight; blockY++) {
    for (var blockX = 0; blockX &lt; blockWidth; blockX++) {
      i = 4 * (blockY * blockWidth + blockX);
      c[0] = src[i];
      c[1] = src[i + 1];
      r0 = c[0] &amp; 0x1f;
      g0 = c[0] &amp; 0x7e0;
      b0 = c[0] &amp; 0xf800;
      r1 = c[1] &amp; 0x1f;
      g1 = c[1] &amp; 0x7e0;
      b1 = c[1] &amp; 0xf800;
      
      if (c[0] > c[1]) {
        c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) &amp; 0x7e0) | (((5 * b0 + 3 * b1) >> 3) &amp; 0xf800);
        c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) &amp; 0x7e0) | (((5 * b1 + 3 * b0) >> 3) &amp; 0xf800);
      } else {
        c[2] = (c[0] + c[1]) >> 1;
        c[3] = 0;
      }
      
      m = src[i + 2];
      dstI = (blockY * 4) * width + blockX * 4;
      dst[dstI] = c[m &amp; 0x3];
      dst[dstI + 1] = c[(m >> 2) &amp; 0x3];
      dst[dstI + 2] = c[(m >> 4) &amp; 0x3];
      dst[dstI + 3] = c[(m >> 6) &amp; 0x3];
      dstI += width;
      dst[dstI] = c[(m >> 8) &amp; 0x3];
      dst[dstI + 1] = c[(m >> 10) &amp; 0x3];
      dst[dstI + 2] = c[(m >> 12) &amp; 0x3];
      dst[dstI + 3] = c[(m >> 14)];
      m = src[i + 3];
      dstI += width;
      dst[dstI] = c[m &amp; 0x3];
      dst[dstI + 1] = c[(m >> 2) &amp; 0x3];
      dst[dstI + 2] = c[(m >> 4) &amp; 0x3];
      dst[dstI + 3] = c[(m >> 6) &amp; 0x3];
      dstI += width;
      dst[dstI] = c[(m >> 8) &amp; 0x3];
      dst[dstI + 1] = c[(m >> 10) &amp; 0x3];
      dst[dstI + 2] = c[(m >> 12) &amp; 0x3];
      dst[dstI + 3] = c[(m >> 14)];
    }
  }
  
  return dst;
}

function dxt3ToRgba8888(src, width, height) {
  var c = new Uint16Array(4);
  var dst = new Uint8Array(width * height * 4);
  var m;
  var a;
  var dstI;
  var i;
  var r0, g0, b0, r1, g1, b1;
  var blockWidth = width / 4;
  var blockHeight = height / 4;
  var widthBytes = width * 4;
  
  for (var blockY = 0; blockY &lt; blockHeight; blockY++) {
    for (var blockX = 0; blockX &lt; blockWidth; blockX++) {
      i = 8 * (blockY * blockWidth + blockX);
      c[0] = src[i + 4];
      c[1] = src[i + 5];
      r0 = c[0] &amp; 0x1f;
      g0 = c[0] &amp; 0x7e0;
      b0 = c[0] &amp; 0xf800;
      r1 = c[1] &amp; 0x1f;
      g1 = c[1] &amp; 0x7e0;
      b1 = c[1] &amp; 0xf800;
      c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) &amp; 0x7e0) | (((5 * b0 + 3 * b1) >> 3) &amp; 0xf800);
      c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) &amp; 0x7e0) | (((5 * b1 + 3 * b0) >> 3) &amp; 0xf800);
      
      m = src[i + 6];
      a = src[i];
      dstI = (blockY * 16) * width + blockX * 16;
      setRgba8888Dxt3(dst, dstI, c[m &amp; 0x3], a &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 4, c[(m >> 2) &amp; 0x3], (a >> 4) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 8, c[(m >> 4) &amp; 0x3], (a >> 8) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 12, c[(m >> 6) &amp; 0x3], (a >> 12) &amp; 0xf);
      a = src[i + 1];
      dstI += widthBytes;
      setRgba8888Dxt3(dst, dstI, c[(m >> 8) &amp; 0x3], a &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 4, c[(m >> 10) &amp; 0x3], (a >> 4) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 8, c[(m >> 12) &amp; 0x3], (a >> 8) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 12, c[m >> 14], (a >> 12) &amp; 0xf);
      m = src[i + 7];
      a = src[i + 2];
      dstI += widthBytes;
      setRgba8888Dxt3(dst, dstI, c[m &amp; 0x3], a &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 4, c[(m >> 2) &amp; 0x3], (a >> 4) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 8, c[(m >> 4) &amp; 0x3], (a >> 8) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 12, c[(m >> 6) &amp; 0x3], (a >> 12) &amp; 0xf);
      a = src[i + 3];
      dstI += widthBytes;
      setRgba8888Dxt3(dst, dstI, c[(m >> 8) &amp; 0x3], a &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 4, c[(m >> 10) &amp; 0x3], (a >> 4) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 8, c[(m >> 12) &amp; 0x3], (a >> 8) &amp; 0xf);
      setRgba8888Dxt3(dst, dstI + 12, c[m >> 14], (a >> 12) &amp; 0xf);
    }
  }
  
  return dst;
}

function dxt5ToRgba8888(src, width, height) {
  var c = new Uint16Array(4);
  var a = new Uint8Array(8);
  var alphaBits;
  var dst = new Uint8Array(width * height * 4);
  var m;
  var a;
  var dstI;
  var i;
  var r0, g0, b0, r1, g1, b1;
  var blockWidth = width / 4;
  var blockHeight = height / 4;
  var widthBytes = width * 4;
  
  for (var blockY = 0; blockY &lt; blockHeight; blockY++) {
    for (var blockX = 0; blockX &lt; blockWidth; blockX++) {
      i = 8 * (blockY * blockWidth + blockX);
      c[0] = src[i + 4];
      c[1] = src[i + 5];
      r0 = c[0] &amp; 0x1f;
      g0 = c[0] &amp; 0x7e0;
      b0 = c[0] &amp; 0xf800;
      r1 = c[1] &amp; 0x1f;
      g1 = c[1] &amp; 0x7e0;
      b1 = c[1] &amp; 0xf800;
      c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) &amp; 0x7e0) | (((5 * b0 + 3 * b1) >> 3) &amp; 0xf800);
      c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) &amp; 0x7e0) | (((5 * b1 + 3 * b0) >> 3) &amp; 0xf800);
      alphaBits = src[i + 1] + 65536 * (src[i + 2] + 65536 * src[i + 3]);
      a[0] = src[i] &amp; 0xff;
      a[1] = src[i]  >> 8;
      
      if (a[0] > a[1]) {
        a[2] = (54 * a[0] + 9 * a[1]) >> 6;
        a[3] = (45 * a[0] + 18 * a[1]) >> 6;
        a[4] = (36 * a[0] + 27 * a[1]) >> 6;
        a[5] = (27 * a[0] + 36 * a[1]) >> 6;
        a[6] = (18 * a[0] + 45 * a[1]) >> 6;
        a[7] = (9 * a[0] + 54 * a[1]) >> 6;
        
        /*
        a[2] = (6 * a[0] + a[1]) / 7;
        a[3] = (5 * a[0] + 2 * a[1]) / 7;
        a[4] = (4 * a[0] + 3 * a[1]) / 7;
        a[5] = (3 * a[0] + 4 * a[1]) / 7;
        a[6] = (2 * a[0] + 5 * a[1]) / 7;
        a[7] = (a[0] + 6 * a[1]) / 7;
        //*/
      } else {
        a[2] = (12 * a[0] + 3 * a[1]) >> 4;
        a[3] = (9 * a[0] + 6 * a[1]) >> 4;
        a[4] = (6 * a[0] + 9 * a[1]) >> 4;
        a[5] = (3 * a[0] + 12 * a[1]) >> 4;
        a[6] = 0;
        a[7] = 1
        
        /*
        a[2] = (4 * a[0] + a[1]) / 5;
        a[3] = (3 * a[0] + 2 * a[1]) / 5;
        a[4] = (2 * a[0] + 3 * a[1]) / 5;
        a[5] = (a[0] + 4 * a[1]) / 5;
        a[6] = 0;
        a[7] = 1;
        //*/
      }
      
      m = src[i + 6];
      dstI = (blockY * 16) * width + blockX * 16;
      setRgba8888Dxt5(dst, dstI, c[m &amp; 0x3], a[alphaBits &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 4, c[(m >> 2) &amp; 0x3], a[(alphaBits >> 3) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 8, c[(m >> 4) &amp; 0x3], a[(alphaBits >> 6) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 12, c[(m >> 6) &amp; 0x3], a[(alphaBits >> 9) &amp; 0x7]);
      dstI += widthBytes;
      setRgba8888Dxt5(dst, dstI, c[(m >> 8) &amp; 0x3], a[(alphaBits >> 12) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 4, c[(m >> 10) &amp; 0x3], a[(alphaBits >> 15) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 8, c[(m >> 12) &amp; 0x3], a[(alphaBits >> 18) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 12, c[m >> 14], a[(alphaBits >> 21) &amp; 0x7]);
      m = src[i + 7];
      dstI += widthBytes;
      setRgba8888Dxt5(dst, dstI, c[m &amp; 0x3], a[(alphaBits >> 24) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 4, c[(m >> 2) &amp; 0x3], a[(alphaBits >> 27) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 8, c[(m >> 4) &amp; 0x3], a[(alphaBits >> 30) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 12, c[(m >> 6) &amp; 0x3],a[(alphaBits >> 33) &amp; 0x7]);
      dstI += widthBytes;
      setRgba8888Dxt5(dst, dstI, c[(m >> 8) &amp; 0x3], a[(alphaBits >> 36) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 4, c[(m >> 10) &amp; 0x3], a[(alphaBits >> 39) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 8, c[(m >> 12) &amp; 0x3], a[(alphaBits >> 42) &amp; 0x7]);
      setRgba8888Dxt5(dst, dstI + 12, c[m >> 14], a[(alphaBits >> 45) &amp; 0x7]);
    }
  }
  
  return dst;
}

/**
 * @memberof GL
 * @class A DDS texture decoder.
 * @name DDSTexture
 * @param {ArrayBuffer} arrayBuffer The raw texture data.
 * @param {object} options An object containing options.
 * @param {function} onerror A function that allows to report errors.
 * @property {WebGLTexture} id
 * @property {boolean} ready
 */
function DDSTexture(arrayBuffer, options, onerror) {
  var header = new Int32Array(arrayBuffer, 0, 31);
  
  if (header[0] !== DDS_MAGIC) {
    onerror("Format");
    return;
  }
  
  if (!header[20] &amp; DDPF_FOURCC) {
    onerror("FourCC");
    return;
  }
  
  var fourCC = header[21];
  var blockBytes, internalFormat;
  
  if (fourCC === FOURCC_DXT1) {
    blockBytes = 8;
    internalFormat = compressedTextures ? compressedTextures.COMPRESSED_RGBA_S3TC_DXT1_EXT : null;
  } else if (fourCC === FOURCC_DXT3) {
    blockBytes = 16;
    internalFormat = compressedTextures ? compressedTextures.COMPRESSED_RGBA_S3TC_DXT3_EXT : null;
  } else if (fourCC === FOURCC_DXT5) {
    blockBytes = 16;
    internalFormat = compressedTextures ? compressedTextures.COMPRESSED_RGBA_S3TC_DXT5_EXT : null;
  } else {
    onerror(int32ToFourCC(fourCC));
    return;
  }
  
  var mipmapCount = 1;
  
  if (header[2] &amp; DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[7]);
  }
  
  var width = header[4];
  var height = header[3];
  var dataOffset = header[1] + 4;
  var dataLength, byteArray;
  var rgb565Data, rgba8888Data;
  
  var id = ctx.createTexture();
  ctx.bindTexture(ctx.TEXTURE_2D, id);
  textureOptions(options.clampS ? ctx.CLAMP_TO_EDGE : ctx.REPEAT, options.clampT ? ctx.CLAMP_TO_EDGE : ctx.REPEAT, ctx.LINEAR, mipmapCount > 1 ? ctx.LINEAR_MIPMAP_LINEAR : ctx.LINEAR);
  
  if (internalFormat) {
    for (var i = 0; i &lt; mipmapCount; i++) {
      dataLength = Math.max(4, width) / 4 * Math.max( 4, height ) / 4 * blockBytes;
      byteArray = new Uint8Array(arrayBuffer, dataOffset, dataLength);
      ctx.compressedTexImage2D(ctx.TEXTURE_2D, i, internalFormat, width, height, 0, byteArray);
      dataOffset += dataLength;
      width *= 0.5;
      height *= 0.5;
    }
  } else {
    dataLength = Math.max(4, width) / 4 * Math.max( 4, height ) / 4 * blockBytes;
    byteArray = new Uint16Array(arrayBuffer, dataOffset);
    
    if (fourCC === FOURCC_DXT1) {
      rgb565Data = dxt1ToRgb565(byteArray, width, height);
      ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGB, width, height, 0, ctx.RGB, ctx.UNSIGNED_SHORT_5_6_5, rgb565Data);
    } else if (fourCC === FOURCC_DXT3) {
      rgba8888Data = dxt3ToRgba8888(byteArray, width, height);
      ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, width, height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, rgba8888Data);
    } else {
      rgba8888Data = dxt5ToRgba8888(byteArray, width, height);
      ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, width, height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, rgba8888Data);
    }
    
    ctx.generateMipmap(ctx.TEXTURE_2D);
  }
  
  this.id = id;
  this.ready = true;
}

/**
 * @memberof GL
 * @class A TGA texture decoder. Supports only simple 32bit TGA images.
 * @name TGATexture
 * @param {ArrayBuffer} arrayBuffer The raw texture data.
 * @param {Object} options An object containing options.
 * @param {function} onerror A function that allows to report errors.
 * @property {WebGLTexture} id
 * @property {boolean} ready
 */
function TGATexture(arrayBuffer, options, onerror) {
  var dataView = new DataView(arrayBuffer);
  var imageType = dataView.getUint8(2);
  
  if (imageType !== 2) {
    onerror("ImageType");
    return;
  }
  
  var width = dataView.getUint16(12, true);
  var height = dataView.getUint16(14, true);
  var pixelDepth = dataView.getUint8(16);
  var imageDescriptor = dataView.getUint8(17);
  
  if (pixelDepth !== 32) {
    onerror("PixelDepth");
    return;
  }
  
  var rgba8888Data = new Uint8Array(arrayBuffer, 18, width * height * 4);
  var index;
  var temp;
  
  // BGRA -> RGBA
  for (var i = 0, l = width * height; i &lt; l; i++) {
    index = i * 4;
    temp = rgba8888Data[index];
    
    rgba8888Data[index] = rgba8888Data[index + 2];
    rgba8888Data[index + 2] = temp;
  }
  
  var id = ctx.createTexture();
  ctx.bindTexture(ctx.TEXTURE_2D, id);
  textureOptions(options.clampS ? ctx.CLAMP_TO_EDGE : ctx.REPEAT, options.clampT ? ctx.CLAMP_TO_EDGE : ctx.REPEAT, ctx.LINEAR, ctx.LINEAR_MIPMAP_LINEAR);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, 1);
  ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, width, height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, rgba8888Data);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, 0);
  ctx.generateMipmap(ctx.TEXTURE_2D);
  
  this.id = id;
  this.ready = true;
}

/**
 * @memberof GL
 * @class A WebGL rectangle.
 * @name Rect
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} z Z coordinate.
 * @param {number} hw Half of the width.
 * @param {number} hh Half of the height.
 * @param {number} stscale A scale that is applied to the texture coordinates.
 * @property {number} originalSize
 * @property {number} originalStscale
 * @property {number} x
 * @property {number} y
 * @property {number} z
 * @property {WebGLBuffer} buffer
 * @property {Float32Array} data
 */
function Rect(x, y, z, hw, hh, stscale) {
  stscale = stscale || 1;
  
  this.originalSize = hw;
  this.originalStscale = stscale;
  this.x = x;
  this.y = y;
  this.z = z;
  
  this.buffer = ctx.createBuffer();
  this.data = new Float32Array(20);
  
  this.resize(hw, hh);
}

Rect.prototype = {
  /**
   * Renders a rectangle with the given shader.
   *
   * @memberof GL.Rect
   * @instance
   * @param {GL.Shader} shader
   */
  render: function (shader) {
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
    
    ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 20, 0);
    ctx.vertexAttribPointer(shader.variables.a_uv, 2, ctx.FLOAT, false, 20, 12);
    
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
  },
  
  /**
   * Resizes a rectangle..
   *
   * @memberof GL.Rect
   * @instance
   * @param {number} hw The new half width.
   * @param {number} hh The new half height.
   */
  resize: function (hw, hh) {
    var diff = hw / this.originalSize;
    var stscale = this.originalStscale * diff;
    var data = this.data;
    var x = this.x;
    var y = this.y;
    var z = this.z;
    
    data[0] = x - hw;
    data[1] = y - hh;
    data[2] = z
    data[3] = 0;
    data[4] = stscale;
    
    data[5] = x + hw;
    data[6] = y - hh;
    data[7] = z;
    data[8] = stscale;
    data[9] = stscale;
    
    data[10] = x - hw;
    data[11] = y + hh;
    data[12] = z;
    data[13] = 0;
    data[14] = 0;
    
    data[15] = x + hw;
    data[16] = y + hh;
    data[17] = z;
    data[18] = stscale;
    data[19] = 0;
  
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, data, ctx.STATIC_DRAW);
  }
};

/**
 * @memberof GL
 * @class A WebGL cube.
 * @name Cube
 * @param {number} x1 Minimum X coordinate.
 * @param {number} y1 Minimum Y coordinate.
 * @param {number} z1 Minimum Z coordinate.
 * @param {number} x2 Maximum X coordinate.
 * @param {number} y2 Maximum Y coordinate.
 * @param {number} z2 Maximum Z coordinate.
 * @property {WebGLBuffer} buffer
 * @property {Float32Array} data
 */
function Cube(x1, y1, z1, x2, y2, z2) {
  this.buffer = ctx.createBuffer();
  this.data = new Float32Array([
    x1, y2, z1,
    x1, y2, z2,
    x1, y2, z2,
    x2, y2, z2,
    x2, y2, z2,
    x2, y2, z1,
    x2, y2, z1,
    x1, y2, z1,
    x1, y1, z1,
    x1, y1, z2,
    x1, y1, z2,
    x2, y1, z2,
    x2, y1, z2,
    x2, y1, z1,
    x2, y1, z1,
    x1, y1, z1,
    x1, y1, z2,
    x1, y2, z2,
    x1, y2, z1,
    x1, y1, z1,
    x2, y1, z2,
    x2, y2, z2,
    x2, y2, z1,
    x2, y1, z1
  ]);
  
  ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
  ctx.bufferData(ctx.ARRAY_BUFFER, this.data, ctx.STATIC_DRAW);
}

Cube.prototype = {
  /**
   * Renders a cubes's lines with the given shader.
   *
   * @memberof GL.Cube
   * @instance
   * @param {GL.Shader} shader
   */
  renderLines: function (shader) {
    if (boundShader) {
      ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
      
      ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 12, 0);
      
      ctx.drawArrays(ctx.LINES, 0, 24);
    }
  }
};


/**
 * @memberof GL
 * @class A WebGL sphere.
 * @name Sphere
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} z Z coordinate.
 * @param {number} latitudeBands Latitude bands.
 * @param {number} longitudeBands Longitude bands.
 * @param {number} radius The sphere radius.
 * @property {WebGLBuffer} vertexBuffer
 * @property {WebGLBuffer} indexBuffer
 * @property {Float32Array} vertexArray
 * @property {Float32Array} indexArray
 */
function Sphere(x, y, z, latitudeBands, longitudeBands, radius) {
  var vertexData = [];
  var indexData = [];
  var latNumber;
  var longNumber;
  
  for (latNumber = 0; latNumber &lt;= latitudeBands; latNumber++) {
    var theta = latNumber * Math.PI / latitudeBands;
    var sinTheta = Math.sin(theta);
    var cosTheta = Math.cos(theta);

    for (longNumber = 0; longNumber &lt;= longitudeBands; longNumber++) {
      var phi = longNumber * 2 * Math.PI / longitudeBands;
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);

      var vx = cosPhi * sinTheta;
      var vy = cosTheta;
      var vz = sinPhi * sinTheta;
      var s = 1 - (longNumber / longitudeBands);
      var t = latNumber / latitudeBands;

      // Position
      vertexData.push(x + vx * radius);
      vertexData.push(y + vy * radius);
      vertexData.push(z + vz * radius);
      // Normal
      //vertexData.push(x);
      //vertexData.push(y);
      //vertexData.push(z);
      // Texture coordinate
      vertexData.push(s);
      vertexData.push(t);
    }
  }

  for (latNumber = 0; latNumber &lt; latitudeBands; latNumber++) {
    for (longNumber = 0; longNumber &lt; longitudeBands; longNumber++) {
      var first = (latNumber * (longitudeBands + 1)) + longNumber;
      var second = first + longitudeBands + 1;
      
      // First trianctxe
      indexData.push(first);
      indexData.push(second);
      indexData.push(first + 1);
      // Second trianctxe
      indexData.push(second);
      indexData.push(second + 1);
      indexData.push(first + 1);
    }
  }
  
  this.vertexArray = new Float32Array(vertexData);
  this.indexArray = new Uint16Array(indexData);
  
  this.vertexBuffer = ctx.createBuffer();
  this.indexBuffer = ctx.createBuffer();
  
  ctx.bindBuffer(ctx.ARRAY_BUFFER, this.vertexBuffer);
  ctx.bufferData(ctx.ARRAY_BUFFER, this.vertexArray, ctx.STATIC_DRAW);
  
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
  ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, this.indexArray, ctx.STATIC_DRAW);
}

Sphere.prototype = {
  /**
   * Renders a sphere with the given shader.
   *
   * @memberof GL.Sphere
   * @instance
   * @param {GL.Shader} shader
   */
  render: function (shader) {
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this.vertexBuffer);
    
    ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 20, 0);
    ctx.vertexAttribPointer(shader.variables.a_uv, 2, ctx.FLOAT, false, 20, 12);
    
    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    
    ctx.drawElements(ctx.TRIANGLES, this.indexArray.length, ctx.UNSIGNED_SHORT, 0);
  },
  
  /**
   * Renders a sphere's lines with the given shader.
   *
   * @memberof GL.Sphere
   * @instance
   * @param {Shader} shader
   */
  renderLines: function (shader) {
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this.vertexBuffer);
    
    ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 20, 0);
    
    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    
    ctx.drawElements(ctx.LINES, this.indexArray.length, ctx.UNSIGNED_SHORT, 0);
  }
};

/**
 * @memberof GL
 * @class A WebGL cylinder.
 * @name Cylinder
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} z Z coordinate.
 * @param {number} r The cylinder radius.
 * @param {number} h The cylinder height.
 * @param {number} bands Number of bands.
 * @property {WebGLBuffer} buffer
 * @property {Float32Array} data
 * @property {number} bands
 */
function Cylinder(x, y, z, r, h, bands) {
  var i, l;
  var step = Math.PI * 2 / bands;
  var offset = 0;

  var buffer = ctx.createBuffer();
  var data = new Float32Array(72 * bands);
  
  for (i = 0, l = bands; i &lt; l; i++) {
    var c = Math.cos(step * i) * r;
    var s = Math.sin(step * i) * r;
    var c2 = Math.cos(step * (i + 1)) * r;
    var s2 = Math.sin(step * (i + 1)) * r;
    var index = i * 72;

    // Top band
    data[index + 0] = 0;
    data[index + 1] = 0;
    data[index + 2] = h;
    data[index + 3] = c;
    data[index + 4] = s;
    data[index + 5] = h;

    data[index + 6] = 0;
    data[index + 7] = 0;
    data[index + 8] = h;
    data[index + 9] = c2;
    data[index + 10] = s2;
    data[index + 11] = h;

    data[index + 12] = c;
    data[index + 13] = s;
    data[index + 14] = h;
    data[index + 15] = c2;
    data[index + 16] = s2;
    data[index + 17] = h;

    // Bottom band
    data[index + 18] = 0;
    data[index + 19] = 0;
    data[index + 20] = -h;
    data[index + 21] = c;
    data[index + 22] = s;
    data[index + 23] = -h;

    data[index + 24] = 0;
    data[index + 25] = 0;
    data[index + 26] = -h;
    data[index + 27] = c2;
    data[index + 28] = s2;
    data[index + 29] = -h;

    data[index + 30] = c;
    data[index + 31] = s;
    data[index + 32] = -h;
    data[index + 33] = c2;
    data[index + 34] = s2;
    data[index + 35] = -h;

    // Side left-bottom band
    data[index + 36] = c;
    data[index + 37] = s;
    data[index + 38] = h;
    data[index + 39] = c;
    data[index + 40] = s;
    data[index + 41] = -h;

    data[index + 42] = c;
    data[index + 43] = s;
    data[index + 44] = h;
    data[index + 45] = c2;
    data[index + 46] = s2;
    data[index + 47] = -h;

    data[index + 48] = c;
    data[index + 49] = s;
    data[index + 50] = -h;
    data[index + 51] = c2;
    data[index + 52] = s2;
    data[index + 53] = -h;

    // Side right-top band
    data[index + 54] = c2;
    data[index + 55] = s2;
    data[index + 56] = -h;
    data[index + 57] = c;
    data[index + 58] = s;
    data[index + 59] = h;

    data[index + 60] = c2;
    data[index + 61] = s2;
    data[index + 62] = -h;
    data[index + 63] = c2;
    data[index + 64] = s2;
    data[index + 65] = h;

    data[index + 66] = c;
    data[index + 67] = s;
    data[index + 68] = h;
    data[index + 69] = c2;
    data[index + 70] = s2;
    data[index + 71] = h;
  }

  ctx.bindBuffer(ctx.ARRAY_BUFFER, buffer);
  ctx.bufferData(ctx.ARRAY_BUFFER, data, ctx.STATIC_DRAW);

  this.buffer = buffer;
  this.data = data;
  this.bands = bands;
}

Cylinder.prototype = {
  /**
   * Renders a cylinder's lines with the given shader.
   *
   * @memberof GL.Cylinder
   * @instance
   * @param {GL.Shader} shader
   */
  renderLines: function (shader) {
    if (boundShader) {
      ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);

      ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 12, 0);

      ctx.drawArrays(ctx.LINES, 0, this.bands * 24);
    }
  }
};

/**
 * Sets a perspective projection matrix.
 *
 * @memberof GL
 * @instance
 * @param {number} fovy
 * @param {number} aspect
 * @param {number} near
 * @param {number} far
 */
function setPerspective(fovy, aspect, near, far) {
  mat4.perspective(projectionMatrix, fovy, aspect, near, far);
  refreshViewProjectionMatrix = true;
}

/**
 * Sets an orthogonal projection matrix.
 *
 * @memberof GL
 * @instance
 * @param {number} left
 * @param {number} right
 * @param {number} bottom
 * @param {number} top
 * @param {number} near
 * @param {number} far
 */
function setOrtho(left, right, bottom, top, near, far) {
  mat4.ortho(projectionMatrix, left, right, bottom, top, near, far);
  refreshViewProjectionMatrix = true;
}

/**
 * Resets the view matrix.
 *
 * @memberof GL
 * @instance
 */
function loadIdentity() {
  mat4.identity(viewMatrix);
  refreshViewProjectionMatrix = true;
}

/**
 * Translates the view matrix.
 *
 * @memberof GL
 * @instance
 * @param {vec3} v Translation.
 */
function translate(v) {
  mat4.translate(viewMatrix, viewMatrix, v);
  refreshViewProjectionMatrix = true;
}

/**
 * Rotates the view matrix.
 *
 * @memberof GL
 * @instance
 * @param {number} radians Angle.
 * @param {vec3} axis The rotation axis..
 */
function rotate(radians, axis) {
  mat4.rotate(viewMatrix, viewMatrix, radians, axis);
  refreshViewProjectionMatrix = true;
}

/**
 * Scales the view matrix.
 *
 * @memberof GL
 * @instance
 * @param {vec3} v Scaling.
 */
function scale(v) {
  mat4.scale(viewMatrix, viewMatrix, v);
  refreshViewProjectionMatrix = true;
}

/**
 * Sets the view matrix to a look-at matrix.
 *
 * @memberof GL
 * @instance
 * @param {vec3} eye
 * @param {vec3} center
 * @param {vec3} up
 */
function lookAt(eye, center, up) {
  mat4.lookAt(viewMatrix, eye, center, up);
  refreshViewProjectionMatrix = true;
}

/**
 * Multiplies the view matrix by another matrix.
 *
 * @memberof GL
 * @instance
 * @param {mat4} mat.
 */
function multMat(mat) {
  mat4.multiply(viewMatrix, viewMatrix, mat);
  refreshViewProjectionMatrix = true;
}

/**
 * Pushes the current view matrix in the matrix stack.
 *
 * @memberof GL
 * @instance
 */
function pushMatrix() {
  matrixStack.push(mat4.clone(viewMatrix));
  refreshViewProjectionMatrix = true;
}

/**
 * Pops the matrix stacks and sets the popped matrix to the view matrix.
 *
 * @memberof GL
 * @instance
 */
function popMatrix() {
  viewMatrix = matrixStack.pop();
  refreshViewProjectionMatrix = true;
}

/**
 * Gets the view-projection matrix.
 *
 * @memberof GL
 * @instance
 * @returns {mat4} MVP.
 */
function getViewProjectionMatrix() {
  if (refreshViewProjectionMatrix) {
    mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);
    refreshViewProjectionMatrix = false;
  }
  
  return viewProjectionMatrix;
}

/**
 * Gets the projection matrix.
 *
 * @memberof GL
 * @instance
 * @returns {mat4} P.
 */
function getProjectionMatrix() {
  return projectionMatrix;
}

/**
 * Gets the view matrix.
 *
 * @memberof GL
 * @instance
 * @returns {mat4} MV.
 */
function getViewMatrix() {
  return viewMatrix;
}

/**
 * Creates a new {@link GL.ShaderUnit}, or grabs it from the cache if it was previously created, and returns it.
 *
 * @memberof GL
 * @instance
 * @param {string} source GLSL source.
 * @param {number} type Shader unit type.
 * @param {string} name Owning shader's  name.
 * @returns {GL.ShaderUnit} The created shader unit.
 */
function createShaderUnit(source, type, name) {
  var hash = String.hashCode(source);
  
  if (!shaderUnitStore[hash]) {
    shaderUnitStore[hash] = new ShaderUnit(source, type, name);
  }
  
  return shaderUnitStore[hash];
}

/**
 * Creates a new {@link GL.Shader} program, or grabs it from the cache if it was previously created, and returns it.
 *
 * @memberof GL
 * @instance
 * @param {string} name The name of the shader.
 * @param {string} vertexSource Vertex shader GLSL source.
 * @param {string} fragmentSource Fragment shader GLSL source.
 * @param {array} defines An array of strings that will be added as #define-s to the shader source.
 * @returns {GL.Shader?} The created shader, or a previously cached version, or null if it failed to compile and link.
 */
function createShader(name, vertexSource, fragmentSource, defines) {
  if (!shaderStore[name]) {
    defines = defines || [];
    
    for (var i = 0; i &lt; defines.length; i++) {
      defines[i] = "#define " + defines[i];
    }
    
    defines = defines.join("\n") + "\n";
    
    var vertexUnit = createShaderUnit(defines + vertexSource, ctx.VERTEX_SHADER, name);
    var fragmentUnit = createShaderUnit(floatPrecision + defines + fragmentSource, ctx.FRAGMENT_SHADER, name);
    
    if (vertexUnit.ready &amp;&amp; fragmentUnit.ready) {
      shaderStore[name] = new Shader(name, vertexUnit, fragmentUnit);
    }
  }
  
  if (shaderStore[name] &amp;&amp; shaderStore[name].ready) {
    return shaderStore[name];
  }
}

/**
 * Checks if a shader is ready for use.
 *
 * @memberof GL
 * @instance
 * @param {string} name The name of the shader.
 * @returns {boolean} The shader's status.
 */
function shaderStatus(name) {
  var shader = shaderStore[name];
  
  return shader &amp;&amp; shader.ready;
}

/**
 * Enables the WebGL vertex attribute arrays in the range defined by start-end.
 *
 * @memberof GL
 * @instance
 * @param {number} start The first attribute.
 * @param {number} end The last attribute.
 */
function enableVertexAttribs(start, end) {
  for (var i = start; i &lt; end; i++) {
    ctx.enableVertexAttribArray(i);
  }
}

/**
 * Disables the WebGL vertex attribute arrays in the range defined by start-end.
 *
 * @memberof GL
 * @instance
 * @param {number} start The first attribute.
 * @param {number} end The last attribute.
 */
function disableVertexAttribs(start, end) {
  for (var i = start; i &lt; end; i++) {
    ctx.disableVertexAttribArray(i);
  }
}

/**
 * Binds a shader. This automatically handles the vertex attribute arrays. Returns the currently bound shader.
 *
 * @memberof GL
 * @instance
 * @param {string} name The name of the shader.
 * @returns {GL.Shader} The bound shader.
 */
function bindShader(name) {
  var shader = shaderStore[name];
  
  if (shader &amp;&amp; (!boundShader || boundShader.id !== shader.id)) {
    var oldAttribs = 0;
    
    if (boundShader) {
      oldAttribs = boundShader.attribs;
    }
    
    var newAttribs = shader.attribs;
    
    ctx.useProgram(shader.id);
    
    if (newAttribs > oldAttribs) {
      enableVertexAttribs(oldAttribs, newAttribs);
    } else if (newAttribs &lt; oldAttribs) {
      disableVertexAttribs(newAttribs, oldAttribs);
    }
    
    boundShaderName = name;
    boundShader = shader;
  }
  
  return boundShader;
}

function onloadTexture(source, handler, options, e) {
  var target = e.target,
        status = target.status;
    
  if (status === 200) {
    textureStore[source] = new handler(target.response, options, onerror.bind(undefined, {isTexture: 1, source: source}), ctx);
    
    if (textureStore[source].ready) {
      onload({isTexture: 1, source: source});
    }
  } else {
    onerror({isTexture: 1, source: source}, "" + status);
  }
}

/**
 * Loads a texture, with optional options that will be sent to the texture's constructor,
 * If the texture was already loaded previously, it returns it.
 *
 * @memberof GL
 * @instance
 * @param {string} source The texture's url.
 * @param {object} options Options.
 * @returns {GL.Texture?} The bound shader.
 */
function loadTexture(source, options) {
  // Only load a texture if it wasn't already loaded, and isn't in the middle of loading.
  if (!textureStore[source] &amp;&amp; !textureLoading[source]) {
    var fileType = getFileExtension(source).toLowerCase(),
          handler = textureHandlers[fileType];
    
    if (handler) {
      textureLoading[source] = 1;
      
      onloadstart({isTexture: 1, source: source});
      
      // The normal texture uses a normal Image object to load the data.
      // This is because using a Blob seems to randomly not work, and it also doesn't cache requests.
      if (fileType === "png" || fileType === "gif" || fileType === "jpg") {
        textureStore[source] = new handler(source, onload, onerror, ctx);
      } else {
        getFile(source, true, onloadTexture.bind(undefined, source, handler, options || {}), onerror, onprogress.bind(undefined, {isTexture: true, source: source}));
      }
    } else {
      console.log("Error: no texture handler for file type " + fileType);
    }
  }
  
  return textureStore[source];
}

/**
 * Unloads a texture.
 *
 * @memberof GL
 * @instance
 * @param {string} source The texture's url.
 */
function unloadTexture(source) {
  if (textureStore[source]) {
    delete textureStore[source];
    
    onunload({isTexture: true, source: source});
  }
}

/**
 * Binds a texture to the specified texture unit.
 *
 * @memberof GL
 * @instance
 * @param {(string|GL.Texture)} object A texture source.
 * @param {number} [unit] The texture unit.
 */
function bindTexture(object, unit) {
  var finalTexture;
  
  if (object) {
    if (typeof object === "string") {
      var texture = textureStore[object];
      
      if (texture &amp;&amp; texture.ready) {
        finalTexture = texture;
      }
    } else if (object.ready) {
      finalTexture = object;
    }
  }
  
  unit = unit || 0;
  
  // This happens if the texture doesn't exist, or if it exists but didn't finish loading yet, or if asked to unbind (the given object is null).
  if (!finalTexture) {
    boundTextures[unit] = null;
    
    ctx.activeTexture(ctx.TEXTURE0 + unit);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
  } else if (!boundTextures[unit] || boundTextures[unit].id !== finalTexture.id) {
    boundTextures[unit] = finalTexture;
    
    ctx.activeTexture(ctx.TEXTURE0 + unit);
    ctx.bindTexture(ctx.TEXTURE_2D, finalTexture.id);
  } 
}

/**
 * Creates a new {@link GL.Rect} and returns it.
 *
 * @memberof GL
 * @instance
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} z Z coordinate.
 * @param {number} hw Half of the width.
 * @param {number} hh Half of the height.
 * @param {number} stscale A scale that is applied to the texture coordinates.
 * @returns {GL.Rect} The rectangle.
 */
function createRect(x, y, z, hw, hh, stscale) {
  return new Rect(x, y, z, hw, hh, stscale);
}

/**
 * Creates a new {@link GL.Cube} and returns it.
 *
 * @memberof GL
 * @instance
 * @param {number} x1 Minimum X coordinate.
 * @param {number} y1 Minimum Y coordinate.
 * @param {number} z1 Minimum Z coordinate.
 * @param {number} x2 Maximum X coordinate.
 * @param {number} y2 Maximum Y coordinate.
 * @param {number} z2 Maximum Z coordinate.
 * @returns {GL.Cube} The cube.
 */
function createCube(x1, y1, z1, x2, y2, z2) {
  return new Cube(x1, y1, z1, x2, y2, z2);
}

/**
 * Creates a new {@link GL.Sphere} and returns it.
 *
 * @memberof GL
 * @instance
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} z Z coordinate.
 * @param {number} latitudeBands Latitude bands.
 * @param {number} longitudeBands Longitude bands.
 * @param {number} radius The sphere radius.
 * @returns {GL.Sphere} The sphere.
 */
function createSphere(x, y, z, latitudeBands, longitudeBands, radius) {
  return new Sphere(x, y, z, latitudeBands, longitudeBands, radius);
}

/**
 * Creates a new {@link GL.Cylinder} and returns it.
 *
 * @memberof GL
 * @instance
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} z Z coordinate.
 * @param {number} r The cylinder radius.
 * @param {number} h The cylinder height.
 * @param {number} bands Number of bands..
 * @returns {GL.Cylinder} The cylinder.
 */
function createCylinder(x, y, z, r, h, bands) {
  return new Cylinder(x, y, z, r, h, bands);
}

/**
 * Registers an external handler for an unsupported texture type.
 *
 * @memberof GL
 * @instance
 * @param {string} fileType The file format the handler handles.
 * @param {function} textureHandler
 */
function registerTextureHandler(fileType, textureHandler) {
  textureHandlers[fileType] = textureHandler;
}

  textureHandlers["png"] = Texture;
  textureHandlers["gif"] = Texture;
  textureHandlers["jpg"] = Texture;
  textureHandlers["blp"] = BLPTexture;
  textureHandlers["dds"] = DDSTexture;
  textureHandlers["tga"] = TGATexture;
    
  return {
    setPerspective: setPerspective,
    setOrtho: setOrtho,
    loadIdentity: loadIdentity,
    translate: translate,
    rotate: rotate,
    scale: scale,
    lookAt: lookAt,
    multMat: multMat,
    pushMatrix: pushMatrix,
    popMatrix: popMatrix,
    createShader: createShader,
    shaderStatus: shaderStatus,
    bindShader: bindShader,
    getViewProjectionMatrix: getViewProjectionMatrix,
    getProjectionMatrix: getProjectionMatrix,
    getViewMatrix: getViewMatrix,
    loadTexture: loadTexture,
    unloadTexture: unloadTexture,
    textureOptions: textureOptions,
    bindTexture: bindTexture,
    createRect: createRect,
    createSphere: createSphere,
    createCube: createCube,
    createCylinder: createCylinder,
    ctx: ctx,
    registerTextureHandler: registerTextureHandler
  };
}

/**
 * @class The main model viewer object.
 * @name ModelViewer
 * @param {HTMLCanvasElement} canvas A canvas element.
 * @param {object} urls An object with the necessary methods to get urls from the viewer.
 * @param {function} onmessage A callback function, which the viewer will call with messages.
 * @param {boolean} debugMode If true, the viewer will log the loaded models and their parser to the console.
 */
window["ModelViewer"] = function (canvas, urls, onmessage, debugMode) {
  var grassPath = urls.localFile("grass.png");
  var waterPath = urls.localFile("water.png");
  var bedrockPath = urls.localFile("bedrock.png");
  var skyPath = urls.localFile("sky.png");
  
  // This function is used to filter out reports for internal textures (e.g. ground, sky, team colors beside 00, etc.).
  function noReport(path) {
    if (path === grassPath || path === waterPath || path === bedrockPath || path === skyPath || path.match(/(\d\d).blp/)) {
      return true;
    }
    
    return false;
  }
  
  function sendMessage(e) {
    if (typeof onmessage === "function") {
      onmessage(e);
    }
  }
  
  function objectTypeName(object) {
    if (object.isModel) {
      return "model";
    } else if (object.isInstance) {
      return "instance";
    } else if (object.isHeader) {
      return "header";
    } else if (object.isTexture) {
      return "texture";
    } else if (object.isWebGL) {
      return "webgl";
    } else if (object.isShader) {
      return "shader";
    }
  }
  
  function onloadstart(object) {
    var source = object.source;
    
    if (!noReport(source)) {
      sendMessage({type: "loadstart", objectType: objectTypeName(object), source: source});
    }
  }
  
  function onload(object) {
    var source = object.source,
          message;
    
    if (!noReport(source) ){
      message = {type: "load", objectType: objectTypeName(object), source: source};
      
      if (object.isModel || object.isInstance) {
        message.id = object.id;
      }
      
      sendMessage(message);
    }
  }
  
  function onerror(object, error) {
    sendMessage({type: "error", objectType: objectTypeName(object), source: object.source, error: error});
  }
  
  function onprogress(object, e) {
    var source = object.source,
          progress = e.loaded / e.total;
    
    if (e.target.status === 200) {
      if (!noReport(source)) {
        if (progress === Infinity) {
          progress = 0;
        }
      
        sendMessage({type: "progress", objectType: objectTypeName(object), source: source, progress: progress});
      }
    }
  }
  
  function onunload(object) {
    var message = {type: "unload", objectType: objectTypeName(object), source: object.source};
    
    if (object.isModel || object.isInstance) {
      message.id = object.id;
    }
      
    sendMessage(message);
  }
  
  var gl = GL(canvas, onload, onerror, onprogress, onloadstart, onunload);
  
  if (!gl) {
    return;
  }
  
  var ctx = gl.ctx;
  var cameraMatrix = mat4.create();
  var inverseCamera = mat4.create();
  var inverseCameraRotation = mat4.create();
  var xAxis = [1, 0, 0];
  var yAxis = [0, 1, 0];
  var zAxis = [0, 0, 1];
  var lightPosition = [0, 0, 10000];
  var cameraPosition = vec3.create();
  var grass_water;
  var bedrock;
  var sky;
  var uvOffset = [0, 0];
  var uvSpeed = [math.random(-0.004, 0.004), math.random(-0.004, 0.004)];
  var upDir = [0, 0, 1];
  
  var idFactory = -1;
  var modelArray = []; // All models
  var instanceArray = []; // All instances
  var modelInstanceMap = {}; // Referebce by ID. This is a map to support deletions.
  var modelMap = {}; // Reference by source
  var instanceMap = {}; // Reference by color
  
  var context = {
    frameTime: 1000 / 60,
    camera: [[0, 0, 0], [0, 0]],
    instanceCamera: [-1, -1],
    worldMode: 2,
    groundSize: 256,
    meshesMode: true,
    emittersMode: true,
    polygonMode: true,
    teamColorsMode: true,
    boundingShapesMode: false,
    texturesMode: true,
    shader: 0,
    particleRect: [vec3.fromValues(-1, -1, 0), vec3.fromValues(-1, 1, 0), vec3.fromValues(1, 1, 0), vec3.fromValues(1, -1, 0), vec3.fromValues(1, 0, 0), vec3.fromValues(0, 1, 0), vec3.fromValues(0, 0, 1)],
    particleBillboardedRect: [vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create()],
    gl: gl
  };
  
  var DEBUG_MODE = debugMode;
  
  var supportedFileTypes = {"mdx":1, "m3":1, "blp":1, "dds":1, "tga":1, "png":1, "gif":1, "jpg":1};
  var supportedModelFileTypes = {"mdx":1, "m3":1};
  var supportedTextureFileTypes = {"blp":1, "dds":1, "tga":1, "png":1, "gif":1, "jpg":1};
  
  // If an object has a visibility value below the cutoff, it shouldn't render.
  // This value is taken from Blizzard's Art Tools.
  var VISIBILITY_CUTOFF = 0.75;
  
  var teamColors = [
    [255, 3, 3],
    [0, 66, 255],
    [28, 230, 185],
    [84, 0, 129],
    [255, 252, 1],
    [254, 138, 14],
    [32, 192, 0],
    [229, 91, 176],
    [149, 150, 151],
    [126, 191, 241],
    [16, 98, 70],
    [78, 42, 4],
    [40, 40, 40],
    [0, 0, 0]
  ];
  
  var shaders = [
    "standard",
    "diffuse",
    "normals",
    "uvs",
    "normalmap",
    "specular",
    "specular_normalmap",
    "emissive",
    "unshaded",
    "unshaded_normalmap",
    "decal",
    "white"
  ];
  
  function bindTexture(source, unit, modelTextureMap, instanceTextureMap) {
    var texture;
    
    if (modelTextureMap[source]) {
      texture = modelTextureMap[source];
    }
    
    if (instanceTextureMap[source]) {
      texture = instanceTextureMap[source];   
    }
    
    if (!context.teamColorsMode &amp;&amp; source.endsWith("00.blp")) {
      texture = null;
    }
    
    gl.bindTexture(texture, unit);
  }
  
  function saveContext() {
    var camera = context.camera,
          translation = math.floatPrecisionArray(camera[0], 0),
          rotation = math.floatPrecisionArray(math.toDeg(camera[1]), 0);
    
    return [
      context.frameTime / 1000 * 60,
      [translation, rotation],
      context.instanceCamera,
      context.worldMode,
      context.groundSize,
      context.meshesMode &amp; 1,
      context.polygonMode &amp; 1,
      context.teamColorsMode &amp; 1,
      context.boundingShapesMode &amp; 1,
      context.texturesMode &amp; 1,
      context.shader
    ];
  }
  
  function loadContext(object) {
    var camera = object[1],
          translation = camera[0],
          rotation = math.toRad(camera[1]);
    
    context.frameTime = object[0] / 60 * 1000;
    context.camera = [translation, rotation],
    context.instanceCamera = object[2];
    context.worldMode = object[3];
    setGroundSize(object[4] * 2);
    context.meshesMode = !!object[5];
    context.polygonMode = !!object[6];
    context.teamColorsMode = !!object[7];
    context.boundingShapesMode = !!object[8];
    context.texturesMode = !!object[9];
    context.shader = object[10];
  }

var SHADERS = {
	"vsbonetexture":"uniform sampler2D u_boneMap;\nuniform float u_matrix_size;\nuniform float u_texel_size;\n\nmat4 boneAtIndex(float index) {\n  float offset = index * u_matrix_size;\n  return mat4(texture2D(u_boneMap, vec2(offset, 0)), texture2D(u_boneMap, vec2(offset + u_texel_size, 0)), texture2D(u_boneMap, vec2(offset + u_texel_size * 2.0, 0)), texture2D(u_boneMap, vec2(offset + u_texel_size * 3.0, 0)));\n}",
	"decodefloat":"vec2 decodeFloat2(float f) {\n  vec2 v;\n  \n  v[1] = floor(f / 256.0);\n  v[0] = floor(f - v[1] * 256.0);\n  \n  return v;\n}\n\nvec3 decodeFloat3(float f) {\n  vec3 v;\n  \n  v[2] = floor(f / 65536.0);\n  v[1] = floor((f - v[2] * 65536.0) / 256.0);\n  v[0] = floor(f - v[2] * 65536.0 - v[1] * 256.0);\n  \n  return v;\n}",
	"vsworld":"uniform mat4 u_mvp;\nuniform vec2 u_uv_offset;\n\nattribute vec3 a_position;\nattribute vec2 a_uv;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  v_uv = a_uv + u_uv_offset;\n  \n  gl_Position = u_mvp * vec4(a_position, 1);\n}\n",
	"vswhite":"uniform mat4 u_mvp;\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = u_mvp * vec4(a_position, 1);\n}",
	"psworld":"uniform sampler2D u_texture;\nuniform float u_a;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_texture, v_uv).rgb, u_a);\n}\n",
	"pswhite":"void main() {\n  gl_FragColor = vec4(1);\n}",
	"pscolor":"uniform vec3 u_color;\n\nvoid main() {\n  gl_FragColor = vec4(u_color, 1);\n}\n",
	"wvsmain":"uniform mat4 u_mvp;\nuniform vec3 u_uv_offset;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_uv;\nattribute vec4 a_bones;\nattribute float a_bone_number;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv;\n\nvoid transform(vec3 inposition, vec3 innormal, float bone_number, vec4 bones, out vec3 outposition, out vec3 outnormal) {\n  vec4 position = vec4(inposition, 1);\n  vec4 normal = vec4(innormal, 0);\n  vec4 temp;\n  \n  mat4 bone0 = boneAtIndex(bones[0]);\n  mat4 bone1= boneAtIndex(bones[1]);\n  mat4 bone2= boneAtIndex(bones[2]);\n  mat4 bone3= boneAtIndex(bones[3]);\n  \n  temp = vec4(0);\n  temp += bone0 * position;\n  temp += bone1 * position;\n  temp += bone2 * position;\n  temp += bone3 * position;\n  temp /= bone_number;\n  outposition = vec3(temp);\n  \n  temp = vec4(0);\n  temp += bone0 * normal;\n  temp += bone1 * normal;\n  temp += bone2 * normal;\n  temp += bone3 * normal;\n  outnormal = normalize(vec3(temp));\n}\n\nvoid main() {\n  vec3 position, normal;\n  \n  transform(a_position, a_normal, a_bone_number, a_bones, position, normal);\n  \n  v_normal = normal;\n  v_uv = a_uv + u_uv_offset.xy;\n  \n  gl_Position = u_mvp * vec4(position, 1);\n}",
	"wvsribbons":"uniform mat4 u_mvp;\nuniform vec3 u_uv_offset;\n\nattribute vec3 a_position;\nattribute vec2 a_uv;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  v_uv = a_uv + u_uv_offset.xy;\n    \n  gl_Position = u_mvp * vec4(a_position, 1);\n}",
	"wvsparticles":"uniform mat4 u_mvp;\nuniform vec2 u_dimensions;\n\nattribute vec3 a_position;\nattribute vec2 a_uva_rgb;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main() {\n  vec3 uva = decodeFloat3(a_uva_rgb[0]);\n  vec3 rgb = decodeFloat3(a_uva_rgb[1]);\n  \n  v_uv = uva.yx / u_dimensions;\n  v_color = vec4(rgb, uva.z) / 256.0;\n  \n  gl_Position = u_mvp * vec4(a_position, 1);\n}\n",
	"wvscolor":"uniform mat4 u_mvp;\n\nattribute vec3 a_position;\nattribute vec4 a_bones;\nattribute float a_bone_number;\n\nvoid main() {\n  vec4 v = vec4(a_position, 1);\n  vec4 p = (boneAtIndex(a_bones[0]) * v + boneAtIndex(a_bones[1]) * v + boneAtIndex(a_bones[2]) * v + boneAtIndex(a_bones[3]) * v) / a_bone_number;\n  \n  gl_Position = u_mvp * p ;\n}",
	"wpsmain":"uniform sampler2D u_texture;\nuniform bvec3 u_type;\nuniform vec4 u_modifier;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv;\n\nvoid main() {\n  #ifdef STANDARD_PASS\n  vec4 texel = texture2D(u_texture, v_uv);\n  \n  if (u_type[0] &amp;&amp; texel.a &lt; 0.7) {\n    discard;\n  }\n  \n  if (u_type[1] &amp;&amp; texel.r &lt; 0.2 &amp;&amp; texel.g &lt; 0.2 &amp;&amp; texel.b &lt; 0.2) {\n    discard;\n  }\n  \n  if (u_type[2] &amp;&amp; texel.r > .9 &amp;&amp; texel.g > 0.9 &amp;&amp; texel.b > 0.9) {\n    discard;\n  }\n  \n  gl_FragColor = texel * u_modifier;\n  #endif\n  \n  #ifdef UVS_PASS\n  gl_FragColor = vec4(v_uv, 0.0, 1.0);\n  #endif\n  \n  #ifdef NORMALS_PASS\n  gl_FragColor = vec4(v_normal, 1.0);\n  #endif\n  \n  #ifdef WHITE_PASS\n  gl_FragColor = vec4(1.0);\n  #endif\n}\n",
	"wpsparticles":"uniform sampler2D u_texture;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = texture2D(u_texture, v_uv) * v_color;\n}\n",
	"svscommon":"vec3 TBN(vec3 vector, vec3 tangent, vec3 binormal, vec3 normal) {\n  vec3 transformed;\n  \n  transformed.x = dot(vector, tangent);\n  transformed.y = dot(vector, binormal);\n  transformed.z = dot(vector, normal);\n  \n  return transformed;\n}\n\nvec4 decodeVector(vec4 v) {\n  return ((v / 255.0) * 2.0) - 1.0;\n}",
	"svsstandard":"uniform mat4 u_mvp;\nuniform mat4 u_mv;\nuniform vec3 u_eyePos;\nuniform vec3 u_lightPos;\nuniform float u_firstBoneLookupIndex;\n\nattribute vec3 a_position;\nattribute vec4 a_normal;\nattribute vec2 a_uv0;\n\n#ifdef EXPLICITUV1\nattribute vec2 a_uv1;\n#endif\n#ifdef EXPLICITUV2\nattribute vec2 a_uv1;\nattribute vec2 a_uv2;\n#endif\n#ifdef EXPLICITUV3\nattribute vec2 a_uv1;\nattribute vec2 a_uv2;\nattribute vec2 a_uv3;\n#endif\n\nattribute vec4 a_tangent;\nattribute vec4 a_bones;\nattribute vec4 a_weights;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv[4];\nvarying vec3 v_lightDir;\nvarying vec3 v_eyeVec;\nvarying vec3 v_halfVec;\n\nvoid transform(vec3 inposition, vec3 innormal, vec3 intangent, vec4 bones, vec4 weights, out vec3 outposition, out vec3 outnormal, out vec3 outtangent) {\n  vec4 position = vec4(inposition, 1);\n  vec4 normal = vec4(innormal, 0);\n  vec4 tangent = vec4(intangent, 0);\n  vec4 temp;\n  \n  mat4 weightedBone0 = boneAtIndex(bones[0]) * weights[0];\n  mat4 weightedBone1 = boneAtIndex(bones[1]) * weights[1];\n  mat4 weightedBone2 = boneAtIndex(bones[2]) * weights[2];\n  mat4 weightedBone3 = boneAtIndex(bones[3]) * weights[3];\n  \n  temp = vec4(0);\n  temp += weightedBone0 * position;\n  temp += weightedBone1 * position;\n  temp += weightedBone2 * position;\n  temp += weightedBone3 * position;\n  outposition = vec3(temp);\n  \n  temp = vec4(0);\n  temp += weightedBone0 * normal;\n  temp += weightedBone1 * normal;\n  temp += weightedBone2 * normal;\n  temp += weightedBone3 * normal;\n  outnormal = normalize(vec3(temp));\n  \n  temp = vec4(0);\n  temp += weightedBone0 * tangent;\n  temp += weightedBone1 * tangent;\n  temp += weightedBone2 * tangent;\n  temp += weightedBone3 * tangent;\n  outtangent = normalize(vec3(temp));\n}\n\nvoid main() {\n  vec4 decodedNormal = decodeVector(a_normal);\n  vec4 decodedTangent = decodeVector(a_tangent);\n  vec3 position, normal, tangent;\n  \n  transform(a_position, vec3(decodedNormal), vec3(decodedTangent), a_bones + u_firstBoneLookupIndex, a_weights / 255.0, position, normal, tangent);\n  \n  mat3 mv = mat3(u_mv);\n  \n  vec3 position_mv = (u_mv * vec4(position, 1)).xyz;\n  \n  vec3 n = normalize(mv * normal);\n  vec3 t = normalize(mv * tangent);\n  vec3 b = normalize(cross(n, t) * decodedNormal.w);\n  \n  vec3 lightDir = normalize(u_lightPos - position_mv);\n  v_lightDir = normalize(TBN(lightDir, t, b, n));\n  \n  vec3 eyeVec = normalize(u_eyePos - position_mv);\n  vec3 halfVec = normalize(eyeVec - u_lightPos);\n  \n  v_eyeVec = TBN(eyeVec, t, b, n);\n  v_halfVec = TBN(halfVec, t, b, n);\n  \n  v_normal = n;\n  \n  v_uv[0] = a_uv0 / 2048.0;\n  \n  v_uv[1] = vec2(0);\n  v_uv[2] = vec2(0);\n  v_uv[3] = vec2(0);\n  \n  #ifdef EXPLICITUV1\n  v_uv[1] = a_uv1 / 2048.0;\n  #endif\n  #ifdef EXPLICITUV2\n  v_uv[1] = a_uv1 / 2048.0;\n  v_uv[2] = a_uv2 / 2048.0;\n  #endif\n  #ifdef EXPLICITUV3\n  v_uv[1] = a_uv1 / 2048.0;\n  v_uv[2] = a_uv2 / 2048.0;\n  v_uv[3] = a_uv3 / 2048.0;\n  #endif\n  \n  gl_Position = u_mvp * vec4(position, 1);\n}\n",
	"svscolor":"uniform mat4 u_mvp;\nuniform float u_firstBoneLookupIndex;\n\nattribute vec3 a_position;\nattribute vec4 a_bones;\nattribute vec4 a_weights;\n\nvoid transform(vec3 inposition, vec4 bones, vec4 weights, out vec3 outposition) {\n  vec4 position = vec4(inposition, 1);\n  vec4 temp;\n  \n  mat4 weightedBone0 = boneAtIndex(bones[0]) * weights[0];\n  mat4 weightedBone1 = boneAtIndex(bones[1]) * weights[1];\n  mat4 weightedBone2 = boneAtIndex(bones[2]) * weights[2];\n  mat4 weightedBone3 = boneAtIndex(bones[3]) * weights[3];\n  \n  temp = vec4(0);\n  temp += weightedBone0 * position;\n  temp += weightedBone1 * position;\n  temp += weightedBone2 * position;\n  temp += weightedBone3 * position;\n  outposition = vec3(temp);\n}\n\nvoid main() {\n  vec3 position;\n  \n  transform(a_position, a_bones + u_firstBoneLookupIndex, a_weights / 255.0, position);\n  \n  gl_Position = u_mvp * vec4(position, 1);\n}\n",
	"spscommon":"uniform vec3 u_teamColor;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv[4];\nvarying vec3 v_lightDir;\nvarying vec3 v_eyeVec;\nvarying vec3 v_halfVec;\n\nstruct LayerSettings {\n  bool enabled;\n  float op;\n  float channels;\n  float teamColorMode;\n  //vec3 multAddAlpha;\n  //bool useAlphaFactor;\n  bool invert;\n  //bool multColor;\n  //bool addColor;\n  bool clampResult;\n  //bool useConstantColor;\n  //vec4 constantColor;\n  //float uvSource;\n  float uvCoordinate;\n  //float fresnelMode;\n  //float fresnelTransformMode;\n  //mat4 fresnelTransform;\n  //bool fresnelClamp;\n  //vec3 fresnelExponentBiasScale;\n};\n\n#define SPECULAR_RGB 0.0\n#define SPECULAR_A_ONLY 1.0\n\n#define FRESNELMODE_NONE 0.0\n#define FRESNELMODE_STANDARD 1.0\n#define FRESNELMODE_INVERTED 2.0\n\n#define FRESNELTRANSFORM_NONE 0.0\n#define FRESNELTRANSFORM_SIMPLE 1.0\n#define FRESNELTRANSFORM_NORMALIZED 2.0\n\n#define UVMAP_EXPLICITUV0 0.0\n#define UVMAP_EXPLICITUV1 1.0\n#define UVMAP_REFLECT_CUBICENVIO 2.0\n#define UVMAP_REFLECT_SPHERICALENVIO 3.0\n#define UVMAP_PLANARLOCALZ 4.0\n#define UVMAP_PLANARWORLDZ 5.0\n#define UVMAP_PARTICLE_FLIPBOOK 6.0\n#define UVMAP_CUBICENVIO 7.0\n#define UVMAP_SPHERICALENVIO 8.0\n#define UVMAP_EXPLICITUV2 9.0\n#define UVMAP_EXPLICITUV3 10.0\n#define UVMAP_PLANARLOCALX 11.0\n#define UVMAP_PLANARLOCALY 12.0\n#define UVMAP_PLANARWORLDX 13.0\n#define UVMAP_PLANARWORLDY 14.0\n#define UVMAP_SCREENSPACE 15.0\n#define UVMAP_TRIPLANAR_LOCAL 16.0\n#define UVMAP_TRIPLANAR_WORLD 17.0\n#define UVMAP_TRIPLANAR_WORLD_LOCAL_Z 18.0\n\n#define CHANNELSELECT_RGB 0.0\n#define CHANNELSELECT_RGBA 1.0\n#define CHANNELSELECT_A 2.0\n#define CHANNELSELECT_R 3.0\n#define CHANNELSELECT_G 4.0\n#define CHANNELSELECT_B 5.0\n\n#define TEAMCOLOR_NONE 0.0\n#define TEAMCOLOR_DIFFUSE 1.0\n#define TEAMCOLOR_EMISSIVE 2.0\n\n#define LAYEROP_MOD 0.0\n#define LAYEROP_MOD2X 1.0\n#define LAYEROP_ADD 2.0\n#define LAYEROP_LERP 3.0\n#define LAYEROP_TEAMCOLOR_EMISSIVE_ADD 4.0\n#define LAYEROP_TEAMCOLOR_DIFFUSE_ADD 5.0\n#define LAYEROP_ADD_NO_ALPHA 6.0\n/*\nfloat calculateFresnelTerm(vec3 normal, vec3 eyeToVertex, float exponent, mat4 fresnelTransform, float fresnelTransformMode, bool fresnelClamp) {\n  vec3 fresnelDir = eyeToVertex;\n  float result;\n  \n  if (fresnelTransformMode != FRESNELTRANSFORM_NONE) {\n    fresnelDir = (fresnelTransform * vec4(fresnelDir, 1.0)).xyz;\n    \n    if (fresnelTransformMode == FRESNELTRANSFORM_NORMALIZED) {\n      fresnelDir = normalize(fresnelDir);\n    }\n  }\n  \n  if (fresnelClamp) {\n    result = 1.0 - clamp(-dot(normal, fresnelDir), 0.0, 1.0);\n  } else {\n    result = 1.0 - abs(dot(normal, fresnelDir));\n  }\n  \n  result = max(result, 0.0000001);\n  \n  return pow(result, exponent);\n}\n*/\nvec3 combineLayerColor(vec4 color, vec3 result, LayerSettings layerSettings) {\n  if (layerSettings.op == LAYEROP_MOD) {\n    result *= color.rgb;\n  } else if (layerSettings.op == LAYEROP_MOD2X) {\n    result *= color.rgb * 2.0;\n  } else if (layerSettings.op == LAYEROP_ADD) {\n    result += color.rgb * color.a;\n  } else if (layerSettings.op == LAYEROP_ADD_NO_ALPHA) {\n    result += color.rgb;\n  } else if (layerSettings.op == LAYEROP_LERP) {\n    result = mix(result, color.rgb, color.a);\n  } else if (layerSettings.op == LAYEROP_TEAMCOLOR_EMISSIVE_ADD) {\n    result += color.a * (u_teamColor / 255.0);\n  } else if (layerSettings.op == LAYEROP_TEAMCOLOR_DIFFUSE_ADD) {\n    result += color.a * (u_teamColor / 255.0);\n  }\n  \n  return result;\n}\n\nvec4 chooseChannel(float channel, vec4 texel) {\n  if (channel == CHANNELSELECT_R) {\n    texel = texel.rrrr;\n  } else if (channel == CHANNELSELECT_G) {\n    texel = texel.gggg;\n  } else if (channel == CHANNELSELECT_B) {\n    texel = texel.bbbb;\n  } else if (channel == CHANNELSELECT_A) {\n    texel = texel.aaaa;\n  } else if (channel == CHANNELSELECT_RGB) {\n    texel.a = 1.0;\n  }\n  \n  return texel;\n}\n\nvec2 getUV(LayerSettings layerSettings) {\n  if (layerSettings.uvCoordinate == 1.0) {\n    return v_uv[1];\n  } else if (layerSettings.uvCoordinate == 2.0) {\n    return v_uv[2];\n  } else if (layerSettings.uvCoordinate == 3.0) {\n    return v_uv[3];\n  }\n  \n  return v_uv[0];\n}\n\nvec4 sampleLayer(sampler2D layer, LayerSettings layerSettings) {\n  /*\n  if (layerSettings.useConstantColor &amp;&amp; false) {\n    return layerSettings.constantColor;\n  }\n  */\n  return texture2D(layer, getUV(layerSettings));\n}\n\nvec4 computeLayerColor(sampler2D layer, LayerSettings layerSettings) {\n  vec4 texel = sampleLayer(layer, layerSettings);\n  vec4 result = chooseChannel(layerSettings.channels, texel);\n  /*\n  if (layerSettings.useAlphaFactor &amp;&amp; false) {\n    result.a *= layerSettings.multAddAlpha.z;\n  }\n  */\n  if (layerSettings.teamColorMode == TEAMCOLOR_DIFFUSE) {\n    result = vec4(mix(u_teamColor / 255.0, result.rgb, texel.a), 1);\n  } else if (layerSettings.teamColorMode == TEAMCOLOR_EMISSIVE) {\n    result = vec4(mix(u_teamColor / 255.0, result.rgb, texel.a), 1);\n  }\n  \n  if (layerSettings.invert) {\n    result = vec4(1) - result;\n  }\n  /*\n  if (layerSettings.multColor &amp;&amp; false) {\n    result *= layerSettings.multAddAlpha.x;\n  }\n  \n  if (layerSettings.addColor &amp;&amp; false) {\n    result += layerSettings.multAddAlpha.y;\n  }\n  */\n  if (layerSettings.clampResult) {\n    result = clamp(result, 0.0, 1.0);\n  }\n  /*\n  if (layerSettings.fresnelMode != FRESNELMODE_NONE) {\n    float fresnelTerm = calculateFresnelTerm(v_normal, v_eyeVec, layerSettings.fresnelExponentBiasScale.x, layerSettings.fresnelTransform, layerSettings.fresnelTransformMode, layerSettings.fresnelClamp);\n    \n    if (layerSettings.fresnelMode == FRESNELMODE_INVERTED) {\n      fresnelTerm = 1.0 - fresnelTerm;\n    }\n    \n    fresnelTerm = clamp(fresnelTerm * layerSettings.fresnelExponentBiasScale.z + layerSettings.fresnelExponentBiasScale.y, 0.0, 1.0);\n    \n    result *= fresnelTerm;\n  }\n  */\n  return result;\n}\n\nvec3 decodeNormal(sampler2D map) {\n  vec4 texel = texture2D(map, v_uv[0]);\n  vec3 normal;\n  \n  normal.xy = 2.0 * texel.wy - 1.0;\n  normal.z = sqrt(max(0.0, 1.0 - dot(normal.xy, normal.xy)));\n  \n  return normal;\n}\n\nvec4 computeSpecular(sampler2D specularMap, LayerSettings layerSettings, float specularity, float specMult, vec3 normal) {\n  vec4 color;\n  \n  if (layerSettings.enabled) {\n    color = computeLayerColor(specularMap, layerSettings);\n  } else {\n    color = vec4(0);\n  }\n  \n  float factor = pow(max(-dot(v_halfVec, normal), 0.0), specularity) * specMult;\n  \n  return color * factor;\n}",
	"spsstandard":"uniform float u_specularity;\nuniform float u_specMult;\nuniform float u_emisMult;\nuniform vec4 u_lightAmbient;\n\nuniform LayerSettings u_diffuseLayerSettings;\nuniform sampler2D u_diffuseMap;\nuniform LayerSettings u_decalLayerSettings;\nuniform sampler2D u_decalMap;\nuniform LayerSettings u_specularLayerSettings;\nuniform sampler2D u_specularMap;\nuniform LayerSettings u_glossLayerSettings;\nuniform sampler2D u_glossMap;\nuniform LayerSettings u_emissiveLayerSettings;\nuniform sampler2D u_emissiveMap;\nuniform LayerSettings u_emissive2LayerSettings;\nuniform sampler2D u_emissive2Map;\nuniform LayerSettings u_evioLayerSettings;\nuniform sampler2D u_evioMap;\nuniform LayerSettings u_evioMaskLayerSettings;\nuniform sampler2D u_evioMaskMap;\nuniform LayerSettings u_alphaLayerSettings;\nuniform sampler2D u_alphaMap;\nuniform LayerSettings u_alphaMaskLayerSettings;\nuniform sampler2D u_alphaMaskMap;\nuniform LayerSettings u_normalLayerSettings;\nuniform sampler2D u_normalMap;\nuniform LayerSettings u_heightLayerSettings;\nuniform sampler2D u_heightMap;\nuniform LayerSettings u_lightMapLayerSettings;\nuniform sampler2D u_lightMapMap;\nuniform LayerSettings u_aoLayerSettings;\nuniform sampler2D u_aoMap;\n\nvoid main() {\n  vec3 color;\n  vec4 final = u_lightAmbient;\n  vec3 normal;\n  vec3 lightMapDiffuse;\n  \n  if (u_normalLayerSettings.enabled) {\n    normal = decodeNormal(u_normalMap);\n  } else {\n    normal = v_normal;\n  }\n\n  float lambertFactor = max(dot(normal, v_lightDir), 0.0);\n  \n  if (lambertFactor > 0.0) {\n    if (u_diffuseLayerSettings.enabled) {\n      vec4 diffuseColor = computeLayerColor(u_diffuseMap, u_diffuseLayerSettings);\n      \n      color = combineLayerColor(diffuseColor, color, u_diffuseLayerSettings);\n    }\n    \n    if (u_decalLayerSettings.enabled) {\n      vec4 decalColor = computeLayerColor(u_decalMap, u_decalLayerSettings);\n      \n      color = combineLayerColor(decalColor, color, u_decalLayerSettings);\n    }\n    \n    vec4 specularColor = computeSpecular(u_specularMap, u_specularLayerSettings, u_specularity, u_specMult, normal);\n    \n    if (u_lightMapLayerSettings.enabled) {\n      vec4 lightMapColor = computeLayerColor(u_lightMapMap, u_lightMapLayerSettings) * 2.0;\n      \n      lightMapDiffuse = lightMapColor.rgb;\n    }\n    \n    //final.rgb = color * lightMapDiffuse + specularColor.rgb;\n    final.rgb = (color + specularColor.rgb) * lambertFactor;\n    \n    bool addEmissive = false;\n    vec3 emissiveColor;\n    vec4 tempColor;\n    \n    if (u_emissiveLayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissiveMap, u_emissiveLayerSettings);\n      \n        if (u_emissiveLayerSettings.op == LAYEROP_MOD || u_emissiveLayerSettings.op == LAYEROP_MOD2X || u_emissiveLayerSettings.op == LAYEROP_LERP) {\n            final.rgb = combineLayerColor(tempColor, final.rgb, u_emissiveLayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissiveLayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (u_emissive2LayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissive2Map, u_emissive2LayerSettings);\n      \n        if (!addEmissive &amp;&amp; (u_emissive2LayerSettings.op == LAYEROP_MOD || u_emissive2LayerSettings.op == LAYEROP_MOD2X || u_emissive2LayerSettings.op == LAYEROP_LERP)) {\n            final.rgb = combineLayerColor(tempColor, final.rgb, u_emissive2LayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissive2LayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (addEmissive) {\n        final.rgb += emissiveColor * u_emisMult;\n    }\n  }\n  \n  gl_FragColor = final;\n}",
	"spsspecialized":"#ifdef DIFFUSE_PASS\nuniform LayerSettings u_diffuseLayerSettings;\nuniform sampler2D u_diffuseMap;\n#endif\n#ifdef UV_PASS\nuniform LayerSettings u_diffuseLayerSettings;\nuniform sampler2D u_diffuseMap;\n#endif\n#ifdef SPECULAR_PASS\nuniform LayerSettings u_specularLayerSettings;\nuniform sampler2D u_specularMap;\nuniform float u_specularity;\nuniform float u_specMult;\n#endif\n#ifdef HIGHRES_NORMALS\nuniform LayerSettings u_normalLayerSettings;\nuniform sampler2D u_normalMap;\n#endif\n#ifdef EMISSIVE_PASS\nuniform LayerSettings u_emissiveLayerSettings;\nuniform sampler2D u_emissiveMap;\nuniform LayerSettings u_emissive2LayerSettings;\nuniform sampler2D u_emissive2Map;\nuniform float u_emisMult;\n#endif\n#ifdef DECAL_PASS\nuniform LayerSettings u_decalLayerSettings;\nuniform sampler2D u_decalMap;\n#endif\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  vec3 normal;\n  \n  #ifdef HIGHRES_NORMALS\n    normal = decodeNormal(u_normalMap);\n  #else\n    normal = v_normal;\n  #endif\n  \n  #ifdef DIFFUSE_PASS\n    color = computeLayerColor(u_diffuseMap, u_diffuseLayerSettings);\n  #endif\n  \n  #ifdef NORMALS_PASS\n    color = vec4(normal, 1);\n  #endif\n  \n  #ifdef UV_PASS\n    color = vec4(getUV(u_diffuseLayerSettings), 0, 1);\n  #endif\n  \n  #ifdef SPECULAR_PASS\n    color = computeSpecular(u_specularMap, u_specularLayerSettings, u_specularity, u_specMult, normal);\n  #endif\n  \n  #ifdef EMISSIVE_PASS\n    bool addEmissive = false;\n    vec3 emissiveColor = vec3(0);\n    vec4 tempColor;\n    \n    if (u_emissiveLayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissiveMap, u_emissiveLayerSettings);\n      \n        if (u_emissiveLayerSettings.op == LAYEROP_MOD || u_emissiveLayerSettings.op == LAYEROP_MOD2X || u_emissiveLayerSettings.op == LAYEROP_LERP) {\n            color.rgb = combineLayerColor(tempColor, color.rgb, u_emissiveLayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissiveLayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (u_emissive2LayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissive2Map, u_emissive2LayerSettings);\n      \n        if (!addEmissive &amp;&amp; (u_emissive2LayerSettings.op == LAYEROP_MOD || u_emissive2LayerSettings.op == LAYEROP_MOD2X || u_emissive2LayerSettings.op == LAYEROP_LERP)) {\n            color.rgb = combineLayerColor(tempColor, color.rgb, u_emissive2LayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissive2LayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (addEmissive) {\n        color.rgb += emissiveColor.rgb * u_emisMult;\n    }\n  #endif\n  \n  #ifdef UNSHADED_PASS\n    float lambertFactor = max(dot(normal, v_lightDir), 0.0);\n    \n    color = vec4(lambertFactor, lambertFactor, lambertFactor, 1);\n  #endif\n  \n  #ifdef DECAL_PASS\n    if (u_decalLayerSettings.enabled) {\n      vec4 decalColor = computeLayerColor(u_decalMap, u_decalLayerSettings);\n      \n      color.rgb = combineLayerColor(decalColor, color.rgb, u_decalLayerSettings);\n      color.a = 1.0;\n    }\n  #endif\n  \n  #ifdef WHITE_PASS\n  color = vec4(1.0);\n  #endif\n  \n  gl_FragColor = color;\n}",
	"svsparticles":"uniform mat4 u_mvp;\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = u_mvp * vec4(a_position, 1);\n}\n",
	"spsparticles":"void main() {\n	gl_FragColor = vec4(1);\n}\n"
};

/**
 * Used to add an asynchronous action queue to an object.
 *
 * @mixin
 * @name Async
 * @property {array} actions
 */
var Async = {
  /**
    * Creates the needed properties in the mixed object.
    *
    * @memberof Async
    * @instance
    */
  setupAsync: function () {
    this.actions = [];
  },
  
  /**
    * Adds a new action to the action queue.
    *
    * @memberof Async
    * @instance
    * @param {string} functor A function name.
    * @param {array} args The arguments that will be sent to the functor.
    */
  addAction: function (functor, args) {
    this.actions.push([functor, args]);
  },
  
  /**
    * Calls all the functors in the action queue, giving them their arguments.
    *
    * @memberof Async
    * @instance
    */
  runActions: function () {
    var i,
          l,
          actions = this.actions,
          action;
    
    for (i = 0, l = actions.length; i &lt; l; i++) {
      action = actions[i];
      
      this[action[0]].apply(this, action[1]);
    }
    
    actions = [];
  }
};

/**
 * Used to add spatial capabilities to an object.
 *
 * @mixin
 * @name Spatial
 * @property {mat4} worldMatrix
 * @property {mat4} localMatrix
 * @property {vec3} location
 * @property {quat} rotation
 * @property {vec3} eulerRotation
 * @property {vec3} scaling
 * @property {number} parentId
 * @property {number} attachmentId
 * @property {Node} parentNode
 */
var Spatial = {
  /**
    * Creates the needed properties in the mixed object.
    *
    * @memberof Spatial
    * @instance
    */
  setupSpatial: function () {
    this.worldMatrix = mat4.create();
    this.localMatrix = mat4.create();
    this.location = vec3.create();
    this.rotation = quat.create();
    this.eulerRotation = vec3.create();
    this.scaling = vec3.fromValues(1, 1, 1);
    this.parentId = -1;
    this.attachmentId = -1;
    this.parentNode = null;
  },
  
  /**
    * Recalculates the spatial's transformation.
    *
    * @memberof Spatial
    * @instance
    */
  recalculateTransformation: function () {
    mat4.fromRotationTranslationScale(this.localMatrix, this.rotation, this.location, this.scaling);
  },

  /**
    * Moves a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {vec3} v A displacement vector.
    */
  move: function (v) {
    vec3.add(this.location, this.location, v);
    
    this.recalculateTransformation();
  },

  /**
    * Sets the location of a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {vec3} v A position vector.
    */
  setLocation: function (v) {
    vec3.copy(this.location, v);
    
    this.recalculateTransformation();
  },

  /**
    * Gets a spatial's location.
    *
    * @memberof Spatial
    * @instance
    * @returns {vec3} The spatial's location.
    */
  getLocation: function () {
    return Array.copy(this.location);
  },

  /**
    * Rotates a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {quat} q A quaternion.
    */
  rotateQuat: function (q) {
    quat.multiply(this.rotation, this.rotation, q);
    
    this.recalculateTransformation();
  },

  /**
    * Sets the rotation of a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {quat} q A quaternion.
    */
  setRotationQuat: function (q) {
    quat.copy(this.rotation, q);
    
    this.recalculateTransformation();
  },

  /**
    * Gets a spatial's rotation as a quaternion.
    *
    * @memberof Spatial
    * @instance
    * @returns {quat} The spatial's quaternion rotation.
    */
  getRotationQuat: function () {
    return Array.copy(this.rotation);
  },

  /**
    * Rotates a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {vec3} v A vector of euler angles.
    */
  rotate: function (v) {
    var eulerRotation = this.eulerRotation;
    
    vec3.add(eulerRotation, eulerRotation, v);
    
    this.setRotation(eulerRotation);
  },

  /**
    * Sets the rotation of a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {quat} v A vector of euler angles.
    */
  setRotation: function (v) {
    var q = quat.create(),
          rotation = this.rotation,
          eulerRotation = this.eulerRotation;
    
    vec3.copy(eulerRotation, v);
    
    quat.identity(rotation);
    
    quat.setAxisAngle(q, xAxis, eulerRotation[0]);
    quat.multiply(rotation, q, rotation);
    
    quat.setAxisAngle(q, yAxis, eulerRotation[1]);
    quat.multiply(rotation, q, rotation);
    
    quat.setAxisAngle(q, zAxis, eulerRotation[2]);
    quat.multiply(rotation, q, rotation);
    
    this.recalculateTransformation();
  },

  /**
    * Gets a spatial's rotation as a vector of euler angles.
    *
    * @memberof Spatial
    * @instance
    * @returns {vec3} The spatial's euler angles.
    */
  getRotation: function () {
    return vec3.clone(this.eulerRotation);
  },

  /**
    * Scales a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {number} n The scale factor.
    */
  scale: function (n) {
    vec3.scale(this.scaling, this.scaling, n);
    
    this.recalculateTransformation();
  },

  /**
    * Sets the scale of a spatial.
    *
    * @memberof Spatial
    * @instance
    * @param {number} n The scale factor.
    */
  setScale: function (n) {
    vec3.set(this.scaling, n, n, n);
    
    this.recalculateTransformation();
  },

  /**
    * Gets a spatial's scale.
    *
    * @memberof Spatial
    * @instance
    * @returns {number} The scale factor.
    */
  getScale: function () {
    return this.scaling[0];
  },

  setScaleVector: function (v) {
    vec3.copy(this.scaling, v);
    
    this.recalculateTransformation();
  },

  getScaleVector: function () {
    // Note: no Array.copy because this is: function  for internal use, and I don't want garbage collection.
    return this.scaling;
  },
  
  /**
    * Sets a spatial's parent.
    *
    * @memberof Spatial
    * @instance
    * @param {Node} parent The parent.
    * @param {number} [attahmcnet] An attachment.
    */
  setParent: function (parent, attachment) {
    if (parent) {
      this.parentId = parent.id;
      this.attachmentId = attachment;
      
      parent.requestAttachment(this, attachment);
    } else {
      this.parentId = -1;
      this.attachmentId = -1;
      this.parentNode = null;
    }
  },

  // Called from the parent with the parent node.
  setParentNode: function (node) {
    this.parentNode = node;
  },

  /**
    * Gets a spatial's parent.
    *
    * @memberof Spatial
    * @instance
    * @returns {array} The parent and attachment.
    */
  getParent: function () {
    return [this.parentId, this.attachmentId];
  },

  /**
    * Gets a spatial's world transformation matrix.
    *
    * @memberof Spatial
    * @instance
    * @returns {mat4} The transformation matrix.
    */
  getTransformation: function (objects) {
    var worldMatrix = this.worldMatrix,
          parentNode = this.parentNode;
    
    mat4.identity(worldMatrix);
    
    if (parentNode) {
      mat4.copy(worldMatrix, parentNode.getTransformation());
      
      // Scale by the inverse of the parent to avoid carrying over scales through the hierarchy
      mat4.scale(worldMatrix, worldMatrix, parentNode.inverseScale);
    }
    
    mat4.multiply(worldMatrix, worldMatrix, this.localMatrix);
    
    return worldMatrix;
  }
};

var Mdx = (function () {

var Parser = (function () {
  function readExtent(reader) {
    return {boundsRadius: readFloat32(reader), minimum: readVector3(reader), maximum: readVector3(reader)};
  }
  
  var tagToTrack = {
    "LAYS": {
      "KMTF": [readUint32, "textureId", 0],
      "KMTA": [readFloat32, "alpha", 1]
    },
    
    "TXAN": {
      "KTAT": [readVector3, "translation", [0, 0, 0]],
      "KTAR": [readVector4, "rotation", [0, 0, 0, 1]],
      "KTAS": [readVector3, "scaling", [1, 1, 1]]
    },
    
    "GEOA": {
      "KGAO": [readFloat32, "alpha", 1],
      "KGAC": [readVector3, "color", [0, 0, 0]]
    },
    
    "LITE": {
      "KLAS": [readFloat32, "attenuationStart", 0],
      "KLAE": [readFloat32, "attenuationEnd", 0],
      "KLAC": [readVector3, "color", [0, 0, 0]],
      "KLAI": [readFloat32, "intensity", 0],
      "KLBI": [readFloat32, "ambientIntensity", 0],
      "KLBC": [readVector3, "ambientColor", [0, 0, 0]],
      "KLAV": [readFloat32, "visibility", 1]
    },
    
    "ATCH": {
      "KATV": [readFloat32, "visibility", 1]
    },
    
    "PREM": {
      "KPEE": [readFloat32, "emissionRate", 0],
      "KPEG": [readFloat32, "gravity", 0],
      "KPLN": [readFloat32, "longitude", 0],
      "KPLT": [readFloat32, "latitude", 0],
      "KPEL": [readFloat32, "lifespan", 0],
      "KPES": [readFloat32, "speed", 0],
      "KPEV": [readFloat32, "visibility", 1]
    },
    
    "PRE2": {
      "KP2S": [readFloat32, "speed", 0],
      "KP2R": [readFloat32, "variation", 0],
      "KP2L": [readFloat32, "latitude", 0],
      "KP2G": [readFloat32, "gravity", 0],
      "KP2E": [readFloat32, "emissionRate", 0],
      "KP2N": [readFloat32, "length", 0],
      "KP2W": [readFloat32, "width", 0],
      "KP2V": [readFloat32, "visibility", 1]
    },
    
    "RIBB": {
      "KRHA": [readFloat32, "heightAbove", 0],
      "KRHB": [readFloat32, "heightBelow", 0],
      "KRAL": [readFloat32, "alpha", 1],
      "KRCO": [readVector3, "color", [0, 0, 0]],
      "KRTX": [readUint32, "textureSlot", 0],
      "KRVS": [readFloat32, "visibility", 1]
    },
    
    "CAMS": {
      "KCTR": [readVector3, "positionTranslation", [0, 0, 0]],
      "KTTR": [readVector3, "targetTranslation", [0, 0, 0]],
      "KCRL": [readUint32, "rotation", 0]
    },
    
    "NODE": {
      "KGTR": [readVector3, "translation", [0, 0, 0]],
      "KGRT": [readVector4, "rotation", [0, 0, 0, 1]],
      "KGSC": [readVector3, "scaling", [1, 1, 1]]
    }
  };
  
  function parseChunk(reader, size, Func, nodes) {
    var totalInclusiveSize = 0;
    var elements = [];
    
    while (totalInclusiveSize !== size) {
      var element = new Func(reader, nodes);
	  
      totalInclusiveSize += element.inclusiveSize;
      
      elements[elements.length] = element;
    }
	
    return elements;
  }
  
  function parseCountChunk(reader, count, Func) {
    var elements = [];
    
    for (var i = 0; i &lt; count; i++) {
      elements[i] = new Func(reader);
    }
    
    return elements;
  }
  
  function parseCountChunkByVal(reader, count, Func) {
    var elements = [];
    
    for (var i = 0; i &lt; count; i++) {
      elements[i] = Func(reader);
    }
    
    return elements;
  }
  
  function parseTracks(reader, type) {
    var tracks = {};
    var tagTrack = tagToTrack[type];
	
    while (tagTrack[peek(reader, 4)]) {
      var trackType = tagTrack[read(reader, 4)];
	  
      tracks[trackType[1]] = new TrackChunk(reader, trackType);
    }

    return tracks;
  }
  
  function readNode(reader, nodes) {
    var node = new Node(reader);
    var length = nodes.length;
    
    nodes[length] = node;
    
    return length;
  }

  function Track(reader, interpolationType, type) {
    this.frame = readInt32(reader);
    this.vector = type(reader);

    if (interpolationType > 1) {
      this.inTan = type(reader);
      this.outTan = type(reader);
    }
  }

  function TrackChunk(reader, trackType) {
    var count = readUint32(reader);
    
    this.interpolationType = readUint32(reader);
    this.globalSequenceId = readInt32(reader);
    this.tracks = [];

    for (var i = 0; i &lt; count; i++) {
      this.tracks[i] = new Track(reader, this.interpolationType, trackType[0]);
    }
    
    // Extra information
    this.type = trackType[1];
    this.defval = trackType[2];
  }

  function Node(reader) {
    this.inclusiveSize = readUint32(reader);
    this.name = read(reader, 80);
    // Note: 1 is added here to allow the parser to inject a root node.
    this.objectId = readUint32(reader) + 1;
    this.parentId = readInt32(reader) + 1;
    
    var flags = readUint32(reader);
    
    if (flags === 0x0) {
      this.helper = true;
    } else {
      if (flags &amp; 0x1) { this.dontInheritTranslation = true; }
      if (flags &amp; 0x2) { this.dontInheritRotation = true; }
      if (flags &amp; 0x4) { this.dontInheritScaling = true; }
      if (flags &amp; 0x8) { this.billboarded = true; }
      if (flags &amp; 0x10) { this.billboardedLockX = true; }
      if (flags &amp; 0x20) { this.billboardedLockY = true; }
      if (flags &amp; 0x40) { this.billboardedLockZ = true; }
      if (flags &amp; 0x80) { this.cameraAnchored = true; }
      if (flags &amp; 0x100) { this.bone = true; }
      if (flags &amp; 0x200) { this.light = true; }
      if (flags &amp; 0x400) { this.eventObject = true; }
      if (flags &amp; 0x800) { this.attachment = true; }
      if (flags &amp; 0x1000) { this.particleEmitter = true; }
      if (flags &amp; 0x2000) { this.collisionShape = true; }
      if (flags &amp; 0x4000) { this.ribbonEmitter = true; }
      if (flags &amp; 0x8000) { this.emitterUsesMdlOrUnshaded = true; }
      if (flags &amp; 0x10000) { this.emitterUsesTgaOrSortPrimitivesFarZ = true; }
      if (flags &amp; 0x20000) { this.lineEmitter = true; }
      if (flags &amp; 0x40000) { this.unfogged = true; }
      if (flags &amp; 0x80000) { this.modelSpace = true; }
      if (flags &amp; 0x100000) { this.xYQuad = true; }
    }
    
    this.flags = flags;
    this.tracks = parseTracks(reader, "NODE");
  }
  
  function VersionChunk(reader) {
    this.version = readUint32(reader);
  }
  
  function ModelChunk(reader) {
    this.name = read(reader, 80);
    this["animationPath"] = read(reader, 260);
    this.extent = readExtent(reader);
    this["blendTime"] = readUint32(reader);
  }

  function Sequence(reader) {
    this.name = read(reader, 80);
    this.interval = readUint32Array(reader, 2);
    this.moveSpeed = readFloat32(reader);
    this.flags = readUint32(reader);
    this.rarity = readFloat32(reader);
    this.syncPoint = readUint32(reader);
    this.extent = readExtent(reader);
  }

  function SequenceChunk(reader, size) {
    this.objects = parseCountChunk(reader, size / 132, Sequence);
  }

  function GlobalSequenceChunk(reader, size) {
    this.objects = readUint32Array(reader, size / 4);
  }

  function Texture(reader) {
    this.replaceableId = readUint32(reader);
    this.path = read(reader, 260);
    this.flags = readUint32(reader);
  }

  function TextureChunk(reader, size) {
    this.objects = parseCountChunk(reader, size / 268, Texture);
  }
  /*
  function SoundTrack(reader) {
    this.path = read(reader, 260);
    this.volume = readFloat32(reader);
    this.pitch = readFloat32(reader);
    this.flags = readUint32(reader);
  }
  
  function SoundTrackChunk(reader, size) {
    this.soundTracks = parseCountChunk(reader, size / 272, SoundTrack);
  }
  */
  function Layer(reader) {
    this.inclusiveSize = readUint32(reader);
    this.filterMode = readUint32(reader);
    
    var flags = readUint32(reader);
    
    if (flags &amp; 0x1) { this.unshaded = true; }
    if (flags &amp; 0x2) { this.sphereEnvironmentMap = true; }
    //if (flags &amp; 0x4) { this.unknown0 = true; }
    //if (flags &amp; 0x8) { this.unknown1 = true; }
    if (flags &amp; 0x10) { this.twoSided = true; }
    if (flags &amp; 0x20) { this.unfogged = true; }
    if (flags &amp; 0x30) { this.noDepthTest = true; }
    if (flags &amp; 0x40) { this.noDepthSet = true; }
    
    this.shadingFlags = flags;
    this.textureId = readUint32(reader);
    this.textureAnimationId = readInt32(reader);
    this.coordId = readUint32(reader);
    this.alpha = readFloat32(reader);
    this.tracks = parseTracks(reader, "LAYS");
  }
  
  function Material(reader) {
    this.inclusiveSize = readUint32(reader);
    this["priorityPlane"] = readUint32(reader);
    this["flags"] = readUint32(reader);
	
    if (this.inclusiveSize > 12) {
      read(reader, 4); // LAYS
      this.layers = parseCountChunk(reader, readUint32(reader), Layer);
    }
  }

  function MaterialChunk(reader, size) {
    this.objects = parseChunk(reader, size, Material);
  }

  function TextureAnimation(reader) {
    this.inclusiveSize = readUint32(reader);
    this.tracks = parseTracks(reader, "TXAN");
  }

  function TextureAnimationChunk(reader, size) {
    this.objects = parseChunk(reader, size, TextureAnimation);
  }

  function Geoset(reader) {
    this.inclusiveSize = readUint32(reader);
    
    read(reader, 4); // VRTX
    this.vertexPositions = readFloat32Array(reader, readUint32(reader) * 3);

    read(reader, 4); // NRMS
    this.vertexNormals = readFloat32Array(reader, readUint32(reader) * 3);

    read(reader, 4); // PTYP
    this.faceTypeGroups = readUint32Array(reader, readUint32(reader));

    read(reader, 4); // PCNT
    this.faceGroups = readUint32Array(reader, readUint32(reader));

    read(reader, 4); // PVTX
    this.faces = readUint16Array(reader, readUint32(reader));

    read(reader, 4); // GNDX
    this.vertexGroups = readUint8Array(reader, readUint32(reader));

    read(reader, 4); // MTGC
    this.matrixGroups = readUint32Array(reader, readUint32(reader));

    read(reader, 4); // MATS
    this.matrixIndexes = readUint32Array(reader, readUint32(reader));

    this.materialId = readUint32(reader);
    this.selectionGroup = readUint32(reader);
    this.selectionFlags = readUint32(reader);
    this.extent =  readExtent(reader);
    this.extents = parseCountChunkByVal(reader, readUint32(reader), readExtent);

    read(reader, 4); // UVAS

    this.textureCoordinateSets = [];
    
    for (var i = 0, l = readUint32(reader); i &lt; l; i++) {
      read(reader, 4); // UVBS
      this.textureCoordinateSets[i] = readFloat32Array(reader, readUint32(reader) * 2);
    }
  }

  function GeosetChunk(reader, size) {
    this.objects = parseChunk(reader, size, Geoset);
  }

  function GeosetAnimation(reader) {
    this.inclusiveSize = readUint32(reader);
    this.alpha = readFloat32(reader);
    this.flags = readUint32(reader);
    this.color = readVector3(reader);
    this.geosetId = readUint32(reader);
    this.tracks = parseTracks(reader, "GEOA");
  }

  function GeosetAnimationChunk(reader, size) {
    this.objects = parseChunk(reader, size, GeosetAnimation);
  }

  function Bone(reader, nodes) {
    this.node = readNode(reader, nodes);
    this.geosetId = readUint32(reader);
    this.geosetAnimationId = readUint32(reader);
    this.inclusiveSize = nodes[this.node].inclusiveSize + 8;
  }

  function BoneChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, Bone, nodes);
  }

  function Light(reader, nodes) {
    this.inclusiveSize = readUint32(reader);
    this.node = readNode(reader, nodes);
    this.type = readUint32(reader);
    this.attenuationStart = readUint32(reader);
    this.attenuationEnd = readUint32(reader);
    this.color = readVector3(reader);
    this.intensity = readFloat32(reader);
    this.ambientColor = readVector3(reader);
    this.ambientIntensity = readFloat32(reader);
    this.tracks = parseTracks(reader, "LITE");
  }

  function LightChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, Light, nodes);
  }

  function Helper(reader, nodes) {
    this.node = readNode(reader, nodes);
    this.inclusiveSize = nodes[this.node].inclusiveSize;
  }
  
  function HelperChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, Helper, nodes);
  }
  
  function Attachment(reader, nodes) {
    this.inclusiveSize = readUint32(reader);
    this.node = readNode(reader, nodes);
    this.path = read(reader, 260);
    this.attachmentId = readUint32(reader);
    this.tracks = parseTracks(reader, "ATCH");
  }

  function AttachmentChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, Attachment, nodes);
  }
  
  function PivotPointChunk(reader, size) {
    this.objects = readFloat32Matrix(reader, size / 12, 3);
  }
  
  function ParticleEmitter(reader, nodes) {
    this.inclusiveSize = readUint32(reader);
    this.node = readNode(reader, nodes);
    this.emissionRate = readFloat32(reader);
    this.gravity = readFloat32(reader);
    this.longitude = readFloat32(reader);
    this.latitude = readFloat32(reader);
    this.spawnModelPath = read(reader, 260);
    this.lifespan = readFloat32(reader);
    this.initialVelocity = readFloat32(reader);
    this.tracks = parseTracks(reader, "PREM");
  }

  function ParticleEmitterChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, ParticleEmitter, nodes);
  }
  
  function ParticleEmitter2(reader, nodes) {
    this.inclusiveSize = readUint32(reader);
    this.node = readNode(reader, nodes);
    this.speed = readFloat32(reader);
    this.variation = readFloat32(reader);
    this.latitude = readFloat32(reader);
    this.gravity = readFloat32(reader);
    this.lifespan = readFloat32(reader);
    this.emissionRate = readFloat32(reader);
    this.width = readFloat32(reader);
    this.length = readFloat32(reader);
    this.filterMode = readUint32(reader);
    this.rows = readUint32(reader);
    this.columns = readUint32(reader);
    this.headOrTail = readUint32(reader);
    this.tailLength = readFloat32(reader);
    this.time = readFloat32(reader);
    this.segmentColor = readFloat32Matrix(reader, 3, 3);
    this.segmentAlpha = readUint8Array(reader, 3);
    this.segmentScaling = readFloat32Array(reader, 3);
    this.headInterval = readUint32Array(reader, 3);
    this.headDecayInterval = readUint32Array(reader, 3);
    this.tailInterval = readUint32Array(reader, 3);
    this.tailDecayInterval = readUint32Array(reader, 3);
    this.textureId = readUint32(reader);
    this.squirt = readUint32(reader);
    this.priorityPlane = readUint32(reader);
    this.replaceableId = readUint32(reader);
    this.tracks = parseTracks(reader, "PRE2");
  }

  function ParticleEmitter2Chunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, ParticleEmitter2, nodes);
  }
  
  function RibbonEmitter(reader, nodes) {
    this.inclusiveSize = readUint32(reader);
    this.node = readNode(reader, nodes);
    this.heightAbove = readFloat32(reader);
    this.heightBelow = readFloat32(reader);
    this.alpha = readFloat32(reader);
    this.color = readVector3(reader);
    this.lifespan = readFloat32(reader);
    this.textureSlot = readUint32(reader);
    this.emissionRate = readUint32(reader);
    this.rows = readUint32(reader);
    this.columns = readUint32(reader);
    this.materialId = readUint32(reader);
    this.gravity = readFloat32(reader);
    this.tracks = parseTracks(reader, "RIBB");
  }

  function RibbonEmitterChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, RibbonEmitter, nodes);
  }
  
  function EventObjectTracks(reader) {
    read(reader, 4); // KEVT
    
    var count = readUint32(reader);

    this.globalSequenceId = readUint32(reader);
    this.tracks = readUint32Array(reader, count);
  }
  
  function EventObject(reader, nodes) {
    this.node = readNode(reader, nodes);
    this.inclusiveSize = nodes[this.node].inclusiveSize;
    
    if (peek(reader, 4) === "KEVT") {
      this.tracks = new EventObjectTracks(reader);
      this.inclusiveSize += 12 + this.tracks.tracks.length * 4;
    }
  }

  function EventObjectChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, EventObject, nodes);
  }
  
  function Camera(reader) {
    this.inclusiveSize = readUint32(reader);
    this.name = read(reader, 80);
    this.position = readVector3(reader);
    this.fieldOfView = readFloat32(reader);
    this.farClippingPlane = readFloat32(reader);
    this.nearClippingPlane = readFloat32(reader);
    this.targetPosition = readVector3(reader);
    this.tracks = parseTracks(reader, "CAMS");
  }

  function CameraChunk(reader, size) {
    this.objects = parseChunk(reader, size, Camera);
  }
  
  function CollisionShape(reader, nodes) {
    this.node = readNode(reader, nodes);
    
    var type = readUint32(reader);
    
    this.type = type;
    this.inclusiveSize = nodes[this.node].inclusiveSize + 4;

    if (type === 0 || type === 1 || type === 3) {
      this.vertices = readFloat32Matrix(reader, 2, 3);
      this.inclusiveSize += 24;
    } else if (type === 2) {
      this.vertices = [readVector3(reader)];
      this.inclusiveSize += 12;
    }
  
    if (type === 2 || type === 3) {
      this.radius = readFloat32(reader);
      this.inclusiveSize += 4;
    }
  }

  function CollisionShapeChunk(reader, size, nodes) {
    this.objects = parseChunk(reader, size, CollisionShape, nodes);
  }
  
  var tagToChunk = {
    "VERS": [VersionChunk, "versionChunk"],
    "MODL": [ModelChunk, "modelChunk"],
    "SEQS": [SequenceChunk, "sequenceChunk"],
    "GLBS": [GlobalSequenceChunk, "globalSequenceChunk"],
    "TEXS": [TextureChunk, "textureChunk"],
    //"SNDS": [SoundTrackChunk, "soundTrackChunk"],
    "MTLS": [MaterialChunk, "materialChunk"],
    "TXAN": [TextureAnimationChunk, "textureAnimationChunk"],
    "GEOS": [GeosetChunk, "geosetChunk"],
    "GEOA": [GeosetAnimationChunk, "geosetAnimationChunk"],
    "BONE": [BoneChunk, "boneChunk"],
    "LITE": [LightChunk, "lightChunk"],
    "HELP": [HelperChunk, "helperChunk"],
    "ATCH": [AttachmentChunk, "attachmentChunk"],
    "PIVT": [PivotPointChunk, "pivotPointChunk"],
    "PREM": [ParticleEmitterChunk, "particleEmitterChunk"],
    "PRE2": [ParticleEmitter2Chunk, "particleEmitter2Chunk"],
    "RIBB": [RibbonEmitterChunk, "ribbonEmitterChunk"],
    "EVTS": [EventObjectChunk, "eventObjectChunk"],
    "CAMS": [CameraChunk, "cameraChunk"],
    "CLID": [CollisionShapeChunk, "collisionShapeChunk"]
  };
  
  function Parser(reader) {
    var tag,
          size,
          chunk;
    
    // Initialize the node list with a root node
    this["nodes"] = [{objectId: 0, parentId: -1, name: "InjectedRoot"}];
    
    while (remaining(reader) > 0) {
      tag = read(reader, 4);
      size = readUint32(reader);
      chunk = tagToChunk[tag];
  
      if (chunk) {
        this[chunk[1]] = new chunk[0](reader, size, this["nodes"]);
      } else {
        //console.log("Didn't parse chunk " + tag);
        skip(reader, size);
      }
    }
  }
  
  return (function (reader) {
    if (read(reader, 4) === "MDLX") {
      return new Parser(reader);
    }
  });
}());

function SD(tracks, model) {
  var i, l, arr, keys;
  
  this.type = tracks.type;
  this.defval = tracks.defval;
  this.interpolationType = tracks.interpolationType;
  this.globalSequenceId = tracks.globalSequenceId;
  this.sequences = model.sequences;
  this.globalSequences = model.globalSequences;
  
  arr = tracks.tracks;
  l = arr.length;
  
  keys = [];
  keys.length = l;
  
  
  for (i = 0; i &lt; l; i++) {
    keys[i] = arr[i].frame;
  }
  
  this.tracks = arr;
  this.keys = keys;
  
  // Avoid heap allocations in getInterval()
  this.interval = [0, 0];
}

SD.prototype = {
  getInterval: function (frame, start, end, interval) {
    var keys = this.keys;
    var length = keys.length;
    var a = length;
    var b = 0;
    
    while (b !== length &amp;&amp; frame > keys[b]) {
      a = b;
      b++;
    }
    
    if ((a !== length) &amp;&amp; (keys[a] &lt; start)) {
      a = length;
    }
    
    if ((b !== length) &amp;&amp; (keys[b] > end)) {
      b = length;
    }
    
    interval[0] = a;
    interval[1] = b;
  },

  getValueAtTime: function (out, frame, start, end) {
    var interval = this.interval;
    
    this.getInterval(frame, start, end, interval);
    
    var tracks = this.tracks;
    var length = tracks.length;
    var a = interval[0];
    var b = interval[1];
    
    if (a === length) {
      if (b === length) {
        return this.defval;
      } else {
        return tracks[b].vector;
      }
    }
    
    if (b === length) {
      return tracks[a].vector;
    }
    
    a = tracks[a];
    b = tracks[b];
    
    if (a.frame >= b.frame) {
      return a.vector;
    }
    
    var t = math.clamp((frame - a.frame) / (b.frame - a.frame), 0, 1);
    
    return interpolator(out, a.vector, a.outTan, b.inTan, b.vector, t, this.interpolationType);
  },
  
  // The frame argument is the current animation frame
  // The counter argument is a counter that always goes up to infinity, and is used for global sequences
  getValue: function (out, sequence, frame, counter) {
     if (this.globalSequenceId !== -1 &amp;&amp; this.globalSequences) {
      var duration = this.globalSequences[this.globalSequenceId];
      
      return this.getValueAtTime(out, counter % duration , 0, duration);
    } else if (sequence !== -1) {
      var interval = this.sequences[sequence].interval;
      
      return this.getValueAtTime(out, frame, interval[0], interval[1]);
    } else {
      return this.defval;
    }
  }
};

function getSDValue(sequence, frame, counter, sd, defval, out) {
  if (sd) {
    return sd.getValue(out, sequence, frame, counter);
  } else {
    return defval;
  }
}

function parseSDTracks(tracks, model) {
  var keys = Object.keys(tracks);
  var sds = {};
  var type;
    
  for (var i = 0, l = keys.length; i &lt; l; i++) {
    type = keys[i];
    
    sds[type] = new SD(tracks[type], model);
  }
  
  return sds;
}

var defaultTransformations = {
  translation: [0, 0, 0],
  rotation: [0, 0, 0, 1],
  scaling: [1, 1, 1]
};

function Skeleton(model) {
  var i, l;
  var pivots = model.pivots;
  var nodes = model.nodes;
  var bones = model.bones;
  var hierarchy = model.hierarchy;
  
  this.hierarchy = hierarchy;
  this.nodes = [];
  
  for (i = 0, l = nodes.length; i &lt; l; i++) {
    this.nodes[i] = new ShallowNode(nodes[i]);
  }
  
  // If there are no original bones, reference the root node injected by the parser, since the shader requires at least one bone
  this.bones = bones || [{node: 0}];
    
  this.hwbones = new Float32Array(16 + (16 * this.bones.length));
  this.boneTexture = ctx.createTexture();
  this.boneTextureSize = Math.max(2, math.powerOfTwo(this.bones.length + 1)) * 4;
  this.texelFraction = 1 / this.boneTextureSize;
  this.matrixFraction = this.texelFraction * 4;
  
  ctx.activeTexture(ctx.TEXTURE15);
  ctx.bindTexture(ctx.TEXTURE_2D, this.boneTexture);
  ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, this.boneTextureSize, 1, 0, ctx.RGBA, ctx.FLOAT, null);
  ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
  ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
  
  // To avoid heap allocations
  this.localMatrix = mat4.create();
  this.locationVec = vec3.create();
  this.scaleVec = vec3.create();
  this.rotationQuat = quat.create();
}

Skeleton.prototype = {
  update: function (sequence, frame, counter, worldMatrix) {
    var nodes = this.nodes;
    var hierarchy = this.hierarchy;
    // The root is always at index 0, since it's injected by the parser
    var root = nodes[0];
    
    mat4.copy(root.worldMatrix, worldMatrix);
    mat4.decomposeScale(root.scale, root.worldMatrix);
    vec3.inverse(root.inverseScale, root.scale);
    
    for (var i = 1, l = hierarchy.length; i &lt; l; i++) {
      this.updateNode(nodes[hierarchy[i]], sequence, frame, counter);
    }
      
    this.updateBoneTexture();
  },
  
  updateNode: function (node, sequence, frame, counter) {
    var nodeImpl = node.nodeImpl;
    var pivot = node.pivot;
    var negativePivot = node.negativePivot;
    var localMatrix = this.localMatrix;
    var translation = getSDValue(sequence, frame, counter, nodeImpl.sd.translation, defaultTransformations.translation, this.locationVec);
    var rotation = getSDValue(sequence, frame, counter, nodeImpl.sd.rotation, defaultTransformations.rotation, this.rotationQuat);
    var scale = getSDValue(sequence, frame, counter, nodeImpl.sd.scaling, defaultTransformations.scaling, this.scaleVec);
    
    mat4.fromRotationTranslationScaleOrigin(localMatrix, rotation, translation, scale, pivot);
    
    var parent = this.nodes[node.parentId];
    
    mat4.multiply(node.worldMatrix, parent.worldMatrix, localMatrix);
    
    if (nodeImpl.billboarded) {
      // TODO optimize these matrix operations
      
      mat4.identity(localMatrix);
      
      mat4.translate(localMatrix, localMatrix, pivot);
      
      if (context.instanceCamera[1] === -1) {
        // -270 degrees
        mat4.rotate(localMatrix, localMatrix, -context.camera[1][1] - 4.71238, zAxis);
        // -90 degrees
        mat4.rotate(localMatrix, localMatrix, context.camera[1][0] - 1.57079, yAxis);
      } else {
        // Nothing I do here works...........
        //mat4.rotate(localMatrix, localMatrix, -1.57079, yAxis);
        //mat4.multiply(localMatrix, inverseCameraRotation, localMatrix);
      }
      
      mat4.translate(localMatrix, localMatrix, negativePivot);
      
      mat4.multiply(node.worldMatrix, node.worldMatrix, localMatrix);
    }
    
    mat4.decomposeScale(node.scale, node.worldMatrix);
    vec3.inverse(node.inverseScale, node.scale);
  },
  
  updateBoneTexture: function () {
    var bones = this.bones;
    var hwbones = this.hwbones;
    var nodes = this.nodes;
    
    for (var i = 0, l = bones.length; i &lt; l; i++) {
      hwbones.set(nodes[bones[i].node].worldMatrix, i * 16 + 16);
    }
    
    ctx.activeTexture(ctx.TEXTURE15);
    ctx.bindTexture(ctx.TEXTURE_2D, this.boneTexture);
    ctx.texSubImage2D(ctx.TEXTURE_2D, 0, 0, 0, 4 + bones.length * 4, 1, ctx.RGBA, ctx.FLOAT, hwbones);
  },
  
  bind: function (shader) {
    ctx.activeTexture(ctx.TEXTURE15);
    ctx.bindTexture(ctx.TEXTURE_2D, this.boneTexture);
    
    ctx.uniform1i(shader.variables.u_boneMap, 15);
    ctx.uniform1f(shader.variables.u_matrix_size, this.matrixFraction);
    ctx.uniform1f(shader.variables.u_texel_size, this.texelFraction);
  }
};

function CollisionShape(collisionshape, nodes) {
  this.node = collisionshape.node;
  this.name = nodes[collisionshape.node].name;
  
  var v = collisionshape.vertices;
  var v1 = v[0];
  var v2 = v[1];
  var radius = collisionshape.radius;
  var shape;
  
  if (collisionshape.type === 0) {
    shape = gl.createCube(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
  //} else if (collisionshape.type === 1) {
    //shape = gl.newPlane(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
  } else if (collisionshape.type === 2) {
    shape = gl.createSphere(v1[0], v1[1], v1[2], 9, 9, radius);
  //} else {
    //shape = gl.newCylinder(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2], 8, 2, boundsRadius);
  }
  
  this.shape = shape;
}

CollisionShape.prototype = {
  render: function (skeleton, shader) {
    if (this.shape) {
      gl.pushMatrix();
      
      gl.multMat(skeleton.nodes[this.node].worldMatrix);
      
      ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
      
      this.shape.renderLines(shader);
      
      gl.popMatrix();
    }
  }
};

function Model(arrayBuffer, textureMap, context, onerror) {
  
  BaseModel.call(this, textureMap);
  
  var parser = Parser(new BinaryReader(arrayBuffer));
  
  if (DEBUG_MODE) {
    console.log(parser);
  }
        
  if (parser) {
    this.setup(parser);
    this.setupShaders(parser);
  }
  
  if (DEBUG_MODE) {
    console.log(this);
  }
}

var prototype = Object.create(BaseModel.prototype);
Model.prototype = prototype;

prototype.setup = function (parser) {
  var objects, i, l, j, k;
  
  this.name = parser.modelChunk.name;
  this.sequences = [];
  this.textures = [];
  this.meshes = [];
  this.cameras = [];
  this.particleEmitters = [];
  this.particleEmitters2 = [];
  this.ribbonEmitters = [];
  this.boundingShapes = [];
  this.attachments = [];
    
  if (parser.textureChunk) {
    objects = parser.textureChunk.objects;
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.loadTexture(objects[i], this.textureMap);
    }
  }
  
  if (parser.sequenceChunk) {
    this.sequences = parser.sequenceChunk.objects;
  }
  
  if (parser.globalSequenceChunk) {
    this.globalSequences = parser.globalSequenceChunk.objects;
  }
  
  var nodes = parser.nodes;
  var pivots = parser.pivotPointChunk.objects;
  
  this.nodes = [];
  
  for (i = 0, l = nodes.length; i &lt; l; i++) {
    this.nodes[i] = new Node(nodes[i], this, pivots);
  }
  
  // This list is used to access all the nodes in a loop while keeping the hierarchy in mind.
  this.hierarchy = [0];
  this.setupHierarchy(0);
  
  if (parser.boneChunk) {
    this.bones = parser.boneChunk.objects;
  }
  
  if (parser.materialChunk) {
    this.materials = parser.materialChunk.objects;
  }
  
  if (parser.geosetChunk) {
    var geosets = parser.geosetChunk.objects;
    var groups = [[], [], [], []];
    
    for (i = 0, l = geosets.length; i &lt; l; i++) {
      var g = geosets[i];
      var layers = this.materials[g.materialId].layers;
      
      this.meshes.push(new Geoset(g));
      
      for (j = 0, k = layers.length; j &lt; k; j++) {
        var layer = new Layer(layers[j], i, this);
        
        groups[layer.renderOrder].push(layer);
      }
    }
    
    this.layers = groups[0].concat(groups[1]).concat(groups[2]).concat(groups[3]);
  }
  
  if (parser.cameraChunk) {
    this.cameras = parser.cameraChunk.objects;
  }

  if (parser.geosetAnimationChunk) {
    objects = parser.geosetAnimationChunk.objects;

    this.geosetAnimations = [];
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.geosetAnimations[i] = new GeosetAnimation(objects[i], this);
    }
  }
  
  if (parser.textureAnimationChunk) {
    objects = parser.textureAnimationChunk.objects;

    this.textureAnimations = [];
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.textureAnimations[i] = new TextureAnimation(objects[i], this);
    }
  }

  if (parser.particleEmitterChunk) {
    this.particleEmitters = parser.particleEmitterChunk.objects;
  }

  if (parser.particleEmitter2Chunk) {
    this.particleEmitters2 = parser.particleEmitter2Chunk.objects;
  }

  if (parser.ribbonEmitterChunk) {
    this.ribbonEmitters = parser.ribbonEmitterChunk.objects;
  }
  
  if (parser.collisionShapeChunk) {
    objects = parser.collisionShapeChunk.objects;
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.boundingShapes[i] = new CollisionShape(objects[i], this.nodes);
    }
  }

  if (parser.attachmentChunk) {
    objects = parser.attachmentChunk.objects;
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.attachments[i] = new Attachment(objects[i], this);
    }
  }
  
  // Avoid heap allocations in render()
  this.modifier = vec4.create();
  this.uvoffset = vec3.create();
  this.defaultUvoffset = vec3.create();
  
  this.ready = true;
  
  this.setupShaders(parser);
};

prototype.setupShaders = function (parser) {
  var psmain = SHADERS["wpsmain"];
    
  if ((parser.geosetChunk || parser.particleEmitterChunk) &amp;&amp; !gl.shaderStatus("wstandard")) {
    gl.createShader("wstandard", SHADERS.vsbonetexture + SHADERS.wvsmain, psmain, ["STANDARD_PASS"]);
    gl.createShader("wuvs", SHADERS.vsbonetexture + SHADERS.wvsmain, psmain, ["UVS_PASS"]);
    gl.createShader("wnormals", SHADERS.vsbonetexture + SHADERS.wvsmain, psmain, ["NORMALS_PASS"]);
    gl.createShader("wwhite", SHADERS.vsbonetexture + SHADERS.wvsmain, psmain, ["WHITE_PASS"]);
  }
  
  // Load the particle emitters type 2 shader if it is needed
  if (parser.particleEmitter2Chunk &amp;&amp; !gl.shaderStatus("wparticles")) {
    gl.createShader("wparticles", SHADERS.decodefloat + SHADERS.wvsparticles, SHADERS.wpsparticles);
  }
  
  // Load the ribbon emitters shader if it is needed
  if (parser.ribbonEmitterChunk &amp;&amp; !gl.shaderStatus("wribbons")) {
    gl.createShader("wribbons", SHADERS.wvsribbons, psmain);
  }
  
  // Load the color shader if it is needed
  if (!gl.shaderStatus("wcolor")) {
    gl.createShader("wcolor", SHADERS.vsbonetexture + SHADERS.wvscolor, SHADERS.pscolor);
  }
};

prototype.loadTexture = function (texture, textureMap) {
  var source = texture.path;
  var path;
  var replaceableId = texture.replaceableId;
  
  if (replaceableId !== 0) {
    source = "ReplaceableTextures/" + replaceableIdToName[replaceableId] + ".blp";
  }
  
  source = source.replace(/\\/g, "/").toLowerCase();
  
  this.textures.push(source);
  
  if (textureMap[source]) {
    path = textureMap[source];
  } else {
    path = urls.mpqFile(source);
  }
  
  this.textureMap[source] = path;
  
  gl.loadTexture(path);
};

prototype.setupHierarchy = function (parent) {
  var cildren = [];
    
  for (var i = 0, l = this.nodes.length; i &lt; l; i++) {
    var node = this.nodes[i];
    
    if (node.parentId === parent) {
      this.hierarchy.push(i);
      
      this.setupHierarchy(node.objectId);
    }
  }
};

prototype.render = function (instance, context) {
  var i, l, v;
  var sequence = instance.sequence;
  var frame = instance.frame;
  var counter = instance.counter;
  var shaderName = shaders[context.shader];
  
  if (shaderName !== "uvs" &amp;&amp; shaderName !== "normals" &amp;&amp; shaderName !== "white") {
    shaderName = "standard";
  }
  
  var realShaderName = "w" + shaderName
  var shader;
  var layers = this.layers;
  
  if (layers &amp;&amp; gl.shaderStatus(realShaderName)) {
    var modifier = this.modifier;
    var uvoffset = this.uvoffset;
    var layer;
    var geoset;
    var textureId;
    var geosets = this.meshes;
    var textures = this.textures;
    var temp;
    var defaultUvoffset = this.defaultUvoffset;
    
    shader = gl.bindShader(realShaderName);
    
    ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
    ctx.uniform1i(shader.variables.u_texture, 0);
    
    instance.skeleton.bind(shader);
    
    for (i = 0, l = layers.length; i &lt; l; i++) {
      layer = layers[i];
      
      if (instance.meshVisibilities[layer.geosetId] &amp;&amp; layer.shouldRender(sequence, frame, counter) &amp;&amp; this.shouldRenderGeoset(sequence, frame, counter, layer)) {
        geoset = geosets[layer.geosetId];
        
        modifier[0] = 1;
        modifier[1] = 1;
        modifier[2] = 1;
        modifier[3] = 1;
        
        uvoffset[0] = 0;
        uvoffset[1] = 0;
        uvoffset[2] = 0;
        
        layer.setMaterial(shader);
        
        textureId = getSDValue(sequence, frame, counter, layer.sd.textureId, layer.textureId);
        
        bindTexture(textures[textureId], 0, this.textureMap, instance.textureMap);
        
        if (this.geosetAnimations) {
          for (var j = this.geosetAnimations.length; j--;) {
            var geosetAnimation = this.geosetAnimations[j];
            
            if (geosetAnimation.geosetId === layer.geosetId) {
              getSDValue(sequence, frame, counter, geosetAnimation.sd.color, geosetAnimation.color, modifier);
              
              temp = modifier[0];
              
              modifier[0] = modifier[2];
              modifier[2] = temp;
            }
          }
        }
        
        modifier[3] = getSDValue(sequence, frame, counter, layer.sd.alpha, layer.alpha);
        
        ctx.uniform4fv(shader.variables.u_modifier, modifier);
        
        if (layer.textureAnimationId !== -1 &amp;&amp; this.textureAnimations) {
          var textureAnimation = this.textureAnimations[layer.textureAnimationId];
          // What is Z used for?
          uvoffset = getSDValue(sequence, frame, counter, textureAnimation.sd.translation, defaultUvoffset, uvoffset);
        }
        
        ctx.uniform3fv(shader.variables.u_uv_offset, uvoffset);
        
        geoset.render(layer.coordId, shader, context.polygonMode);
      }
    }
  }
  
  if (context.emittersMode &amp;&amp; instance.particleEmitters &amp;&amp; gl.shaderStatus(realShaderName)) {
    for (i = 0, l = instance.particleEmitters.length; i &lt; l; i++) {
      instance.particleEmitters[i].render(context);
    }
  }
  
  ctx.depthMask(1);
  ctx.disable(ctx.BLEND);
  ctx.enable(ctx.CULL_FACE);
};

prototype.renderEmitters = function (instance, context) {
  var i, l;
  var sequence = instance.sequence;
  var frame = instance.frame;
  var counter = instance.counter;
  var shader;
  
  if (instance.ribbonEmitters &amp;&amp; gl.shaderStatus("wribbons")) {
    ctx.depthMask(1);
    ctx.disable(ctx.CULL_FACE);
    
    shader = gl.bindShader("wribbons");
    ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
    ctx.uniform1i(shader.variables.u_texture, 0);
    
    for (i = 0, l = instance.ribbonEmitters.length; i &lt; l; i++) {
      instance.ribbonEmitters[i].render(sequence, frame, counter, instance.textureMap, shader, context);
    }
  }
  
  if (instance.particleEmitters2 &amp;&amp; gl.shaderStatus("wparticles")) {
    ctx.depthMask(0);
    ctx.enable(ctx.BLEND);
    ctx.disable(ctx.CULL_FACE);
    
    shader = gl.bindShader("wparticles");
    
    ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
    ctx.uniform1i(shader.variables.u_texture, 0);
    
    for (i = 0, l = instance.particleEmitters2.length; i &lt; l; i++) {
      instance.particleEmitters2[i].render(instance.textureMap, shader, context);
    }
    
    ctx.depthMask(1);
  }
  
  ctx.depthMask(1);
  ctx.disable(ctx.BLEND);
  ctx.enable(ctx.CULL_FACE);
};

prototype.renderBoundingShapes = function (instance, context) {
  var shader;
  
  if (this.boundingShapes &amp;&amp; gl.shaderStatus("white")) {
    shader = gl.bindShader("white");
    
    for (i = 0, l = this.boundingShapes.length; i &lt; l; i++) {
      this.boundingShapes[i].render(instance.skeleton, shader);
    }
  }
};

prototype.renderColor = function (instance, color) {
  var i, l;
  var sequence = instance.sequence;
  var frame = instance.frame;
  var counter = instance.counter;
  var layer, geoset, texture;
  var shader;
  var layers = this.layers;
  
  if (layers &amp;&amp; gl.shaderStatus("wcolor")) {
    shader = gl.bindShader("wcolor");
    
    ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
    ctx.uniform3fv(shader.variables.u_color, color);
    
    instance.skeleton.bind(shader);
    
    for (i = 0, l = layers.length; i &lt; l; i++) {
      layer = layers[i];
      
      if (instance.meshVisibilities[layer.geosetId] &amp;&amp; layer.shouldRender(sequence, frame, counter) &amp;&amp; this.shouldRenderGeoset(sequence, frame, counter, layer)) {
        geoset = this.meshes[layer.geosetId];
        texture = this.textureMap[this.textures[layer.textureId]];
        
        // Avoid rendering planes.
        // Thsy are usually team glows, or other large mostly-transparent things.
        if (geoset.elements > 6) {
          geoset.renderColor(shader);
        }
      }
    }
  }
};

prototype.shouldRenderGeoset = function (sequence, frame, counter, layer) {
  var i, l, geosetAnimation, geosetAnimations = this.geosetAnimations;
  
  if (geosetAnimations) {
    for (i = 0, l = geosetAnimations.length; i &lt; l; i++) {
      geosetAnimation = geosetAnimations[i];
      
      if (geosetAnimation.geosetId === layer.geosetId &amp;&amp; geosetAnimation.sd.alpha) {
        // This handles issues when there are multiple geoset animations for one geoset.
        // This is a bug, but the game supports it.
        if (getSDValue(sequence, frame, counter, geosetAnimation.sd.alpha) &lt; VISIBILITY_CUTOFF) {
          return false;
        }
      }
    }
  }
  
  return true;
};

function ModelInstance(model, textureMap) {
  BaseModelInstance.call(this, model, textureMap);
  
  this.setup(model);
}

var prototype = Object.create(BaseModelInstance.prototype);
ModelInstance.prototype = prototype;

prototype.setup = function (model) {
  var i, l, objects;

  this.counter = 0;
  this.skeleton = new Skeleton(model);
  
  if (model.particleEmitters &amp;&amp; model.particleEmitters.length > 0) {
    objects = model.particleEmitters;

    this.particleEmitters = [];
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.particleEmitters[i] = new ParticleEmitter(objects[i], model, this);
    }
  }
  
  if (model.particleEmitters2 &amp;&amp; model.particleEmitters2.length > 0) {
    objects = model.particleEmitters2;

    this.particleEmitters2 = [];
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.particleEmitters2[i] = new ParticleEmitter2(objects[i], model, this);
    }
  }

  if (model.ribbonEmitters &amp;&amp; model.ribbonEmitters.length > 0) {
    objects = model.ribbonEmitters;

    this.ribbonEmitters = [];
    
    for (i = 0, l = objects.length; i &lt; l; i++) {
      this.ribbonEmitters[i] = new RibbonEmitter(objects[i], model, this);
    }
  }
};

prototype.updateEmitters = function (emitters, allowCreate, context) {
  if (emitters) {
    for (var i = 0, l = emitters.length; i &lt; l; i++) {
      emitters[i].update(allowCreate, this.sequence, this.frame, this.counter, context.particleRect, context.particleBillboardedRect);
    }
  }
};

prototype.update = function (worldMatrix, context) {
  var allowCreate = false;
  
  if (this.sequence !== -1) {
    var sequence = this.model.sequences[this.sequence];
    
    this.frame += context.frameTime;
    this.counter += context.frameTime;
    
    allowCreate = true;
    
    if (this.frame >= sequence.interval[1]) {
      if (this.sequenceLoopMode === 2 || (this.sequenceLoopMode === 0 &amp;&amp; sequence.flags === 0)) {
        this.frame = sequence.interval[0];
        allowCreate = true;
      } else {
        this.frame = sequence.interval[1];
        this.counter -= context.frameTime;
        allowCreate = false;
      }
    }
  }
  
  this.skeleton.update(this.sequence, this.frame, this.counter, worldMatrix);
  
  this.updateEmitters(this.particleEmitters, allowCreate, context);
  this.updateEmitters(this.particleEmitters2, allowCreate, context);
  this.updateEmitters(this.ribbonEmitters, allowCreate, context);
};

prototype.setTeamColor = function (id) {
  var idString = ((id &lt; 10) ? "0" + id : id);
  
  this.overrideTexture("replaceabletextures/teamcolor/teamcolor00.blp", urls.mpqFile("ReplaceableTextures/TeamColor/TeamColor" + idString + ".blp"));
  this.overrideTexture("replaceabletextures/teamglow/teamglow00.blp", urls.mpqFile("ReplaceableTextures/TeamGlow/TeamGlow" + idString + ".blp"));
  this.teamColor = id;
};

prototype.setSequence = function (id) {
  this.sequence = id;
  
  if (id === -1) {
    this.frame = 0;
  } else {
    var sequence = this.model.sequences[id];
    
    this.frame = sequence.interval[0];
  }
};

prototype.getAttachment = function (id) {
  var attachment = this.model.attachments[id];
  
  if (attachment) {
    console.log("attachment id=" + id, this.skeleton.nodes[attachment.node]);
    return this.skeleton.nodes[attachment.node];
  } else {
    return this.skeleton.nodes[0];
  }
};

var replaceableIdToName = {
  1: "TeamColor/TeamColor00",
  2: "TeamGlow/TeamGlow00",
  11: "Cliff/Cliff0",
  31: "LordaeronTree/LordaeronSummerTree",
  32: "AshenvaleTree/AshenTree",
  33: "BarrensTree/BarrensTree",
  34: "NorthrendTree/NorthTree",
  35: "Mushroom/MushroomTree",
  36: "RuinsTree/RuinsTree",
  37: "OutlandMushroomTree/MushroomTree"
};

function Geoset(geoset) {
  var i, l, j, k;
  var positions = geoset.vertexPositions;
  var normals = geoset.vertexNormals;
  var textureCoordinateSets = geoset.textureCoordinateSets;
  var uvsetSize = textureCoordinateSets[0].length * 2;
  var vertices = positions.length / 3;
  var uvs = new Float32Array(textureCoordinateSets.length * uvsetSize);
  var boneIndices = new Uint8Array(vertices * 4);
  var boneNumbers = new Uint8Array(vertices);
  var faces = geoset.faces;
  var edges = new Uint16Array(faces.length * 2);
  var matrixGroups = [];
  
  for (i = 0, l = faces.length, k = 0; i &lt; l; i += 3, k += 6) {
    edges[k + 0] = faces[i + 0];
    edges[k + 1] = faces[i + 1];
    edges[k + 2] = faces[i + 1];
    edges[k + 3] = faces[i + 2];
    edges[k + 4] = faces[i + 2];
    edges[k + 5] = faces[i + 0];
  }
  
  // Make one typed array for the texture coordinates, in case there are multiple ones
  for (i = 0, l = textureCoordinateSets.length; i &lt; l; i++) {
    uvs.set(textureCoordinateSets[i], i * uvsetSize);
  }
  
  // Parse the bone indices
  for (i = 0, l = geoset.matrixGroups.length, k = 0; i &lt; l; i++) {
    matrixGroups.push(geoset.matrixIndexes.subarray(k, k + geoset.matrixGroups[i]));
    k += geoset.matrixGroups[i];
  }
  
  for (i = 0, l = vertices, k = 0; i &lt; l; i++) {
    var matrixGroup = matrixGroups[geoset.vertexGroups[i]];
    var count = 0;
      
    // 1 is added to every index for shader optimization.
    for (j = 0; j &lt; 4; j++) {
      if (matrixGroup &amp;&amp; j &lt; matrixGroup.length) {
        boneIndices[k] = matrixGroup[j] + 1;
        count += 1;
      } else {
        boneIndices[k] = 0;
      }
      
      k += 1;
    }
    
    boneNumbers[i] = count;
  }
  
  var normalsOffset = positions.byteLength;
  var uvsOffset = normalsOffset + normals.byteLength;
  var boneIndicesOffset = uvsOffset + uvs.byteLength;
  var boneNumbersOffset = boneIndicesOffset + boneIndices.byteLength;
  var bufferSize = boneNumbersOffset + boneNumbers.byteLength;
  
  var arrayBuffer = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, arrayBuffer);
  ctx.bufferData(ctx.ARRAY_BUFFER,  bufferSize, ctx.STATIC_DRAW);
  ctx.bufferSubData(ctx.ARRAY_BUFFER, 0, positions);
  ctx.bufferSubData(ctx.ARRAY_BUFFER, normalsOffset, normals);
  ctx.bufferSubData(ctx.ARRAY_BUFFER, uvsOffset, uvs);
  ctx.bufferSubData(ctx.ARRAY_BUFFER, boneIndicesOffset, boneIndices);
  ctx.bufferSubData(ctx.ARRAY_BUFFER, boneNumbersOffset, boneNumbers);
  
  var elementBuffer = ctx.createBuffer();
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, elementBuffer);
  ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, faces, ctx.STATIC_DRAW);
  
  var edgeBuffer = ctx.createBuffer();
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, edgeBuffer);
  ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, edges, ctx.STATIC_DRAW);
  
  this.offsets = [0, normalsOffset, uvsOffset, boneIndicesOffset, boneNumbersOffset];
  this.uvsetSize = uvsetSize * 4;
  this.arrayBuffer = arrayBuffer;
  this.elementBuffer = elementBuffer;
  this.edgeBuffer = edgeBuffer;
  this.elements = faces.length;
}

Geoset.prototype = {
  render: function (coordId, shader, polygonMode) {
    var offsets = this.offsets;
    
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this.arrayBuffer);
    
    ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 12, offsets[0]);
    ctx.vertexAttribPointer(shader.variables.a_normal, 3, ctx.FLOAT, false, 12, offsets[1]);
    ctx.vertexAttribPointer(shader.variables.a_uv, 2, ctx.FLOAT, false, 8, offsets[2] + coordId * this.uvsetSize);
    ctx.vertexAttribPointer(shader.variables.a_bones, 4, ctx.UNSIGNED_BYTE, false, 4, offsets[3]);
    ctx.vertexAttribPointer(shader.variables.a_bone_number, 1, ctx.UNSIGNED_BYTE, false, 1, offsets[4]);
    
    if (polygonMode) {
      ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
      ctx.drawElements(ctx.TRIANGLES, this.elements, ctx.UNSIGNED_SHORT, 0);
    } else {
      ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.edgeBuffer);
      ctx.drawElements(ctx.LINES, this.elements * 2, ctx.UNSIGNED_SHORT, 0);
    }
  },
  
  renderColor: function (shader) {
    var offsets = this.offsets;
    
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this.arrayBuffer);
    
    ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 12, offsets[0]);
    ctx.vertexAttribPointer(shader.variables.a_bones, 4, ctx.UNSIGNED_BYTE, false, 4, offsets[3]);
    ctx.vertexAttribPointer(shader.variables.a_bone_number, 1, ctx.UNSIGNED_BYTE, false, 1, offsets[4]);
    
    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
    ctx.drawElements(ctx.TRIANGLES, this.elements, ctx.UNSIGNED_SHORT, 0);
  }
};

var filterModeToRenderOrder = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 3,
  5: 3,
  6: 3
};

var layerFilterTypes = [
  [0, 0, 0],
  [1, 0, 0],
  [0, 0, 0],
  [0, 1, 0],
  [0, 0, 0],
  [0, 0, 1],
  [0, 0, 1]
];

function Layer(layer, geosetId, model) {
  this.filterMode = layer.filterMode;
  this.twoSided = layer.twoSided;
  this.textureId = layer.textureId;
  this.textureAnimationId = layer.textureAnimationId;
  this.coordId = layer.coordId;
  this.alpha = layer.alpha;
  this.renderOrder = filterModeToRenderOrder[layer.filterMode] || 0;
  this.geosetId = geosetId;
  this.sd = parseSDTracks(layer.tracks, model);
}

Layer.prototype = {
  setMaterial: function (shader) {
    var filterMode = this.filterMode;
    
    ctx.uniform3fv(shader.variables.u_type, layerFilterTypes[filterMode]);
    
    if (filterMode === 1) {
      ctx.depthMask(1);
      ctx.disable(ctx.BLEND);
    } else if (filterMode === 2) {
      ctx.depthMask(0);
      ctx.enable(ctx.BLEND);
      ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
    } else if (filterMode === 3) {
      ctx.enable(ctx.BLEND);
      ctx.depthMask(0);
      ctx.blendFunc(ctx.SRC_COLOR, ctx.ONE);
    } else if (filterMode === 4) {
      ctx.depthMask(0);
      ctx.enable(ctx.BLEND);
      ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE);
    } else if (filterMode === 5 || filterMode === 6) {
      ctx.depthMask(0);
      ctx.enable(ctx.BLEND);
      ctx.blendFunc(ctx.SRC_ZERO, ctx.SRC_COLOR);
    } else {
      ctx.depthMask(1);
      ctx.disable(ctx.BLEND);
    }
    
    if (this.twoSided) {
      ctx.disable(ctx.CULL_FACE);
    } else {
      ctx.enable(ctx.CULL_FACE);
    }
  },
  
  shouldRender: function (sequence, frame, counter) {
    return getSDValue(sequence, frame, counter, this.sd.alpha, 1) > VISIBILITY_CUTOFF;
  }
};

function GeosetAnimation(geosetAnimation, model) {
  this.alpha = geosetAnimation.alpha;
  this.color = geosetAnimation.color;
  this.geosetId = geosetAnimation.geosetId;
  this.sd = parseSDTracks(geosetAnimation.tracks, model);
}

function TextureAnimation(textureAnimation, model) {
  this.sd = parseSDTracks(textureAnimation.tracks, model);
}

function Node(object, model, pivots) {
  this.name = object.name;
  this.objectId = object.objectId;
  this.parentId = object.parentId;
  this.pivot = pivots[object.objectId - 1] || [0, 0, 0];
  this.billboarded = object.billboarded;
  this.xYQuad = object.xYQuad;
  
  if (object.tracks) {
    this.sd = parseSDTracks(object.tracks, model);
  }
}

// Used by each copy of a skeleton to hold the node hierarchy
// Keeps a reference to the actual node containing the animation data, that the model owns
function ShallowNode(node) {
  this.nodeImpl = node;
  this.pivot = node.pivot;
  this.negativePivot = vec3.negate([], node.pivot);
  this.objectId = node.objectId;
  this.parentId = node.parentId;
  this.worldMatrix = mat4.create();
  this.scale = vec3.create();
  this.inverseScale = vec3.create();
  
  // To avoid heap allocations
  this.externalWorldMatrix = mat4.create();
}

ShallowNode.prototype = {
  getTransformation: function () {
    var m = this.externalWorldMatrix;
    
    mat4.copy(m, this.worldMatrix);
    mat4.translate(m, m, this.pivot);
    
    return m;
  }
};

function Attachment(attachment, model) {
  this.node = attachment.node;
  this.path = attachment.path;
  this.attachmentId = attachment.attachmentId;
  this.name = model.nodes[this.node].name;
  this.sd = parseSDTracks(attachment.tracks, model);
}

function Particle() {
  this.position = vec3.create();
  this.velocity = vec3.create();
  this.orientation = 0;
  this.gravity = 0;
}

Particle.prototype = {
  reset: function (emitter, sequence, frame, counter) {
    var scale = emitter.node.scale;
    var speed = getSDValue(sequence, frame, counter, emitter.sd.speed, emitter.initialVelocity);
    var latitude = getSDValue(sequence, frame, counter, emitter.sd.latitude, emitter.latitude);
    var longitude = getSDValue(sequence, frame, counter, emitter.sd.longitude, emitter.longitude);
    var lifespan = getSDValue(sequence, frame, counter, emitter.sd.lifespan, emitter.lifespan);
    var gravity = getSDValue(sequence, frame, counter, emitter.sd.gravity, emitter.gravity) * scale[2];
    var position = this.position;
    var worldMatrix = emitter.node.worldMatrix;
    
    this.alive = true;
    this.health = lifespan;
    
    vec3.transformMat4(position, emitter.node.pivot, emitter.node.worldMatrix);
    
    var velocity = [];
    var rotation = mat4.create();
    var velocityStart = [];
    var velocityEnd = [];
    
    mat4.identity(rotation);
    mat4.rotateZ(rotation, rotation, math.random(-Math.PI, Math.PI));
    mat4.rotateY(rotation, rotation, math.random(-latitude, latitude));
    
    vec3.transformMat4(velocity, zAxis, rotation);
    vec3.normalize(velocity, velocity);
    
    vec3.add(velocityEnd, position, velocity);
    
    vec3.transformMat4(velocityStart, position, worldMatrix);
    vec3.transformMat4(velocityEnd, velocityEnd, worldMatrix);
    
    vec3.subtract(velocity, velocityEnd, velocityStart);
    vec3.normalize(velocity, velocity);
    vec3.scale(velocity, velocity, speed);
    
    vec3.multiply(this.velocity, velocity, scale);
    
    this.orientation = math.random(0, Math.PI * 2);
    this.gravity = gravity;
  },
  
  update: function (emitter, sequence, frame, counter) {
    if (this.alive) {
      this.health -= (context.frameTime / 1000);
      
      this.velocity[2] -= this.gravity * (context.frameTime / 1000);

      vec3.scaleAndAdd(this.position, this.position, this.velocity, (context.frameTime / 1000));
    }
  }
};

function ParticleEmitter(emitter, model, instance) {
  var i, l;
  var keys = Object.keys(emitter);
  
  for (i = keys.length; i--;) {
    this[keys[i]] = emitter[keys[i]];
  }
  
  this.lastCreation = 0;
  
  var path = emitter.spawnModelPath.replace(/\\/g, "/").replace("MDL", "mdx");
  
  this.spawnModel = loadInternalModelInstance(urls.mpqFile(path));
  this.spawnModel.setSequence(0);
  
  var particles;
  
  // This is the maximum number of particles that are going to exist at the same time
  if (emitter.tracks.emissionRate) {
    var tracks = emitter.tracks.emissionRate;
    var biggest = 0;
    
    for (i = 0, l = tracks.length; i &lt; l; i++) {
      var track = tracks[i];
      
      if (track.vector > biggest) {
        biggest = track.vector;
      }
    }
    // For a reason I can't understand, biggest*lifespan isn't enough for emission rate tracks, multiplying by 2 seems to be the lowest reasonable value that works
    particles = Math.round(biggest * Math.ceil(emitter.lifespan) * 2);
  } else {
    particles = Math.round(emitter.emissionRate * Math.ceil(emitter.lifespan));
  }
  
  this.particles = [];
  this.reusables = [];
  
  for (i = particles; i--;) {
    this.particles[i] = new Particle();
    this.reusables.push(i);
  }
  
  this.node = instance.skeleton.nodes[emitter.node];
  this.sd = parseSDTracks(emitter.tracks, model);
}

ParticleEmitter.prototype = {
  update: function (allowCreate, sequence, frame, counter, baseParticle, billboardedParticle) {
    var i, l;
    
    if (this.spawnModel) {
      this.spawnModel.update();
    }
    
    for (i = 0, l = this.particles.length; i &lt; l; i++) {
      var particle = this.particles[i];
      
      if (particle.alive) {
        if (particle.health &lt;= 0) {
          particle.alive = false;
          
          this.reusables.push(i);
        } else {
          particle.update(this, sequence, frame, counter);
        }
      }
    }
    
    if (allowCreate &amp;&amp; this.shouldRender(sequence, frame, counter)) {
      this.lastCreation += 1;
      
      var amount = getSDValue(sequence, frame, counter, this.sd.emissionRate, this.emissionRate) * (context.frameTime / 1000) * this.lastCreation;
      
      if (amount >= 1) {
        this.lastCreation = 0;
        
        for (i = 0; i &lt; amount; i++) {
          if (this.reusables.length > 0) {
            this.particles[this.reusables.pop()].reset(this, sequence, frame, counter);
          }
        }
      }
    }
  },
  
  render: function (context) {
    var spawnModel = this.spawnModel;
    
    if (spawnModel) {
      for (var i = 0, l = this.particles.length; i &lt; l; i++) {
        var particle = this.particles[i];
        
        if (particle.health > 0) {
          var p = particle.position;
          
          gl.pushMatrix();
          gl.translate(p);
          gl.rotate(particle.orientation, zAxis);
          
          spawnModel.setScaleVector(this.node.scale);
          spawnModel.render(context);
          
          gl.popMatrix();
        }
      }
    }
  },
  
  shouldRender: function (sequence, frame, counter) {
    return getSDValue(sequence, frame, counter, this.sd.visibility) > VISIBILITY_CUTOFF;
  }
};

function Particle2() {
  this.id = 0;
  this.health = 0;
  this.head = true;
  this.position = [];
  this.velocity = [];
  this.color = [];
  this.gravity = 0;
  this.scale = 1;
  this.index = 0;
}

Particle2.prototype = {
  reset: function (emitter, head, id, sequence, frame, counter) {
    var pivot = emitter.node.pivot;
    var worldMatrix = emitter.node.worldMatrix;
    var scale = emitter.node.scale;
    var width = getSDValue(sequence, frame, counter, emitter.sd.width, emitter.width) * 0.5 * scale[0];
    var length = getSDValue(sequence, frame, counter, emitter.sd.length, emitter.length) * 0.5 * scale[1];
    var speed = (getSDValue(sequence, frame, counter, emitter.sd.speed, emitter.speed) + math.random(-emitter.variation, emitter.variation));
    var latitude = math.toRad(getSDValue(sequence, frame, counter, emitter.sd.latitude, emitter.latitude));
    var gravity = getSDValue(sequence, frame, counter, emitter.sd.gravity, emitter.gravity) * scale[2];
    var color = emitter.colors[0];
    var localPosition = emitter.particleLocalPosition;
    var position = emitter.particlePosition;
    var rotation = emitter.particleRotation;
    var velocity = emitter.particleVelocity;
    var velocityStart = emitter.particleVelocityStart;
    var velocityEnd = emitter.particleVelocityEnd;
    
    localPosition[0] = pivot[0] + math.random(-width, width);
    localPosition[1] = pivot[1] + math.random(-length, length);
    localPosition[2] = pivot[2];
    
    vec3.transformMat4(position, localPosition, worldMatrix);
    
    mat4.identity(rotation);
    mat4.rotateZ(rotation, rotation, math.random(-Math.PI, Math.PI));
    mat4.rotateY(rotation, rotation, math.random(-latitude, latitude));
    
    vec3.transformMat4(velocity, zAxis, rotation);
    vec3.normalize(velocity, velocity);
    
    vec3.add(velocityEnd, position, velocity);
    
    vec3.transformMat4(velocityStart, position, worldMatrix);
    vec3.transformMat4(velocityEnd, velocityEnd, worldMatrix);
    
    vec3.subtract(velocity, velocityEnd, velocityStart);
    vec3.normalize(velocity, velocity);
    vec3.scale(velocity, velocity, speed);
    
    if (!head) {
      var tailLength = emitter.tailLength * 0.5;
      
      position[0] -= tailLength * velocity[0];
      position[1] -= tailLength * velocity[1];
      position[2] -= tailLength * velocity[2];
    }
    
    this.id = id;
    this.health = emitter.lifespan;
    this.head = head;
    
    vec3.copy(this.position, position);
    vec3.multiply(this.velocity, velocity, scale);
    vec4.copy(this.color, color);
    
    this.gravity = gravity;
    this.scale = 1;
    this.index = 0;
  },
  
  update: function (emitter, sequence, frame, counter) {
    this.health -= (context.frameTime / 1000);
    this.velocity[2] -= this.gravity * (context.frameTime / 1000);
    
    vec3.scaleAndAdd(this.position, this.position, this.velocity, (context.frameTime / 1000));

    var lifeFactor = (emitter.lifespan === 0) ? 0 : 1 - (this.health / emitter.lifespan);
    var scale;
    var tempFactor;
    
    if (lifeFactor &lt; emitter.time) {
      tempFactor = lifeFactor / emitter.time;
      
      scale = math.lerp(emitter.segmentScaling[0], emitter.segmentScaling[1], tempFactor);
      
      vec4.lerp(this.color, emitter.colors[0], emitter.colors[1], tempFactor);
    } else {
      tempFactor = (lifeFactor - emitter.time) / (1 - emitter.time);
      
      scale = math.lerp(emitter.segmentScaling[1], emitter.segmentScaling[2], tempFactor);
      
      vec4.lerp(this.color, emitter.colors[1], emitter.colors[2], tempFactor);
    }
    
    var currentFrame = lifeFactor * emitter.numberOfFrames;
    var index = 0;
    
    // For some reason if I use array access here, Chrome doesn't like this function and doesn't optimize it
    if (currentFrame &lt; emitter.interval0Frames) {
      index = emitter.interval0LocalStart + ((currentFrame - emitter.interval0Start) % emitter.interval0);
    } else if (currentFrame &lt; emitter.interval1Frames) {
      index = emitter.interval1LocalStart + ((currentFrame - emitter.interval1Start) % emitter.interval1);
    } else if (currentFrame &lt; emitter.interval2Frames) {
      this.index = emitter.interval2LocalStart + ((currentFrame - emitter.interval2Start) % emitter.interval2);
    } else if (currentFrame &lt; emitter.interval3Frames) {
      index = emitter.interval3LocalStart + ((currentFrame - emitter.interval3Start) % emitter.interval3);
    }
    
    this.index = Math.floor(index);
    this.scale = scale;
  }
};

function ParticleEmitter2(emitter, model, instance) {
  var i, l;
  var keys = Object.keys(emitter);
  
  for (i = keys.length; i--;) {
    this[keys[i]] = emitter[keys[i]];
  }
  
  this.model = model;
  this.texture = model.textures[this.textureId];
  
  this.lastCreation = 1;
  
  var particles;
  
  // This is the maximum number of particles that are going to exist at the same time
  if (this.tracks.emissionRate) {
    var tracks = this.tracks.emissionRate.tracks;
    var biggest = 0;
    
    for (i = 0, l = tracks.length; i &lt; l; i++) {
      var track = tracks[i];
      
      if (track.vector > biggest) {
        biggest = track.vector;
      }
    }
    // For a reason I can't understand, biggest*lifespan isn't enough for emission rate tracks, multiplying by 2 seems to be the lowest reasonable value that works
    particles = Math.ceil(biggest) * Math.ceil(this.lifespan) * 2;
  } else {
    // +3 because for some reason rate*lifespan isn't working properly
    // Do I have a problem with the update loop?
    particles = Math.ceil(this.emissionRate) * Math.ceil(this.lifespan) + 3;
  }
  
  this.head = (this.headOrTail === 0 || this.headOrTail === 2);
  this.tail = (this.headOrTail === 1 || this.headOrTail === 2);
  
  if (this.head &amp;&amp; this.tail) {
    particles *= 2;
  }
  
  this.particles = [];
  this.reusables = [];
  this.activeParticles = [];
    
  this.buffer = ctx.createBuffer();
  this.data = new Float32Array(30 * particles);
  
  ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
  ctx.bufferData(ctx.ARRAY_BUFFER, this.data, ctx.DYNAMIC_DRAW);
  
  for (i = 0, l = particles; i &lt; l; i++) {
    this.particles[i] = new Particle2();
    this.reusables.push(particles - i - 1);
  }
  
  var headInterval = emitter.headInterval;
  var headDecayInterval = emitter.headDecayInterval;
  var tailInterval = emitter.tailInterval;
  var tailDecayInterval = emitter.tailDecayInterval;
  
  var headFrames = 0;
  var headDecayFrames = 0;
  var tailFrames = 0;
  var tailDecayFrames = 0;
  
  // The repeat variables are probably not supposed to be used like this...
  if (this.head) {
    headFrames = (headInterval[1] - headInterval[0] + 1) * headInterval[2];
    headDecayFrames = (headDecayInterval[1] - headDecayInterval[0] + 1) * headDecayInterval[2];
  }
  
  if (this.tail) {
    tailFrames = (tailInterval[1] - tailInterval[0] + 1) * tailInterval[2];
    tailDecayFrames = (tailDecayInterval[1] - tailDecayInterval[0] + 1) * tailDecayInterval[2];
  }
  
  this.interval0Frames = headFrames;
  this.interval1Frames = headFrames + headDecayFrames;
  this.interval2Frames = headFrames + headDecayFrames + tailFrames;
  this.interval3Frames = headFrames + headDecayFrames + tailFrames + tailDecayFrames;
  
  this.interval0 = headInterval[1] - headInterval[0] + 1;
  this.interval1 = headDecayInterval[1] - headDecayInterval[0] + 1;
  this.interval2 = tailInterval[1] - tailInterval[0] + 1;
  this.interval3 = tailDecayInterval[1] - tailDecayInterval[0] + 1;

  this.interval0Start = 0;
  this.interval1Start = headFrames;
  this.interval2Start = headFrames + headDecayFrames;
  this.interval3Start = headFrames + headDecayFrames + tailFrames;
  
  this.interval0LocalStart = headInterval[0];
  this.interval1LocalStart = headDecayInterval[0];
  this.interval2LocalStart = tailInterval[0];
  this.interval3LocalStart = tailDecayInterval[0];
  
  this.numberOfFrames = this.interval3Frames;
  
  this.cellWidth = 1 / this.columns;
  this.cellHeight = 1 / this.rows;
  this.colors = [];
  
  var colors = this.segmentColor;
  var alpha = this.segmentAlpha;
  
  for (i = 0; i &lt; 3; i++) {
    this.colors[i] = [Math.floor(colors[i][0] * 256), Math.floor(colors[i][1] * 256), Math.floor(colors[i][2] * 256), alpha[i]];
  }
  
  this.node = instance.skeleton.nodes[this.node];
  this.sd = parseSDTracks(emitter.tracks, model);
  
  // Avoid heap alocations in Particle2.reset
  this.particleLocalPosition = vec3.create();
  this.particlePosition = vec3.create();
  this.particleRotation = mat4.create();
  this.particleVelocity = vec3.create();
  this.particleVelocityStart = vec3.create();
  this.particleVelocityEnd = vec3.create();
  
  this.xYQuad = this.node.nodeImpl.xYQuad;
  
  this.dimensions = [this.columns, this.rows];
}

ParticleEmitter2.prototype = {
  update: function (allowCreate, sequence, frame, counter, baseParticle, billboardedParticle) {
    var particles = this.particles;
    var reusables = this.reusables;
    var activeParticles = this.activeParticles;
    var activeParticlesCount = activeParticles.length;
    var i, l;
    var particle;
    
    if (activeParticles.length > 0) {
      // First stage: remove dead particles.
      // The used particles array is a queue, dead particles will always come first.
      // As of the time of writing, the easiest and fastest way to implement a queue in Javascript is a normal array.
      // To add items, you push, to remove items, the array is reversed and you pop.
      // So the first stage reverses the array, and then keeps checking the last element for its health.
      // As long as we hit a dead particle, pop, and check the new last element.
      
      // Ready for pop mode
      activeParticles.reverse();
      
      particle = particles[activeParticles[activeParticles.length - 1]];
      
      while (particle &amp;&amp; particle.health &lt;= 0) {
        activeParticles.pop();
        this.reusables.push(particle.id);
        
        // Need to recalculate the length each time
        particle = particles[activeParticles[activeParticles.length - 1]];
      }
      
      // Ready for push mode
      activeParticles.reverse()
    
      // Second stage: update the living particles.
      // All the dead particles were removed, so a simple loop is all that's required.
      for (i = 0, l = activeParticles.length; i &lt; l; i++) {
        particle = particles[activeParticles[i]];
        
        particle.update(this, sequence, frame, counter);
      }
    }
    
    // Third stage: create new particles if needed.
    if (allowCreate &amp;&amp; this.shouldRender(sequence, frame, counter)) {
      var amount = getSDValue(sequence, frame, counter, this.sd.emissionRate, this.emissionRate) * (context.frameTime / 1000) * this.lastCreation;
      
      if (amount > 0) {
        this.lastCreation += 1;
      }
      
      if (amount >= 1) {
        amount = Math.floor(amount);
        
        var index;
        
        this.lastCreation = 1;
        
        for (i = 0; i &lt; amount; i++) {
          if (this.head &amp;&amp; reusables.length > 0) {
            index = reusables.pop();
            
            particles[index].reset(this, true, index, sequence, frame, counter);
            activeParticles.push(index);
          }
          
          if (this.tail &amp;&amp; reusables.length > 0) {
            index = reusables.pop();
            
            particles[index].reset(this, false, index, sequence, frame, counter);
            activeParticles.push(index);
          }
        }
      }
    }  
    
    this.updateHW(baseParticle, billboardedParticle);
  },
  
  updateHW: function (baseParticle, billboardedParticle) {
    var activeParticles = this.activeParticles;
    var data = this.data;
    var particles = this.particles;
    var columns = this.columns;
    var particle, index, position, color;
    var pv1, pv2, pv3, pv4, csx, csy, csz;
    var rect;
    
    // Choose between a default rectangle or billboarded one
    if (this.xYQuad) {
      rect = baseParticle;
    } else {
      rect = billboardedParticle;
    }
    
    pv1 = rect[0];
    pv2 = rect[1];
    pv3 = rect[2];
    pv4 = rect[3];
    csx = rect[4];
    csy = rect[5];
    csz = rect[6];
    
    var scale, textureIndex, left, top, right, bottom, r, g, b, a, px, py, pz;
    var v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z, v4x, v4y, v4z;
    var lta, lba, rta, rba, rgb;
    var nodeScale = this.node.scale;
    
    for (var i = 0, l = activeParticles.length; i &lt; l; i++) {
      particle = particles[activeParticles[i]];
      index = i * 30;
      
      position = particle.position;
      scale = particle.scale;
      textureIndex = particle.index;
      left = textureIndex % columns;
      top = Math.floor(textureIndex / columns);
      right = left + 1;
      bottom = top + 1;
      color = particle.color;
      r = Math.floor(color[0]);
      g = Math.floor(color[1]);
      b = Math.floor(color[2]);
      a = Math.floor(color[3]);
      px = position[0];
      py = position[1];
      pz = position[2];
      
      if (particle.head) {
        v1x = px + pv1[0] * scale * nodeScale[0];
        v1y = py + pv1[1] * scale * nodeScale[1];
        v1z = pz + pv1[2] * scale * nodeScale[2];
        v2x = px + pv2[0] * scale * nodeScale[0];
        v2y = py + pv2[1] * scale * nodeScale[1];
        v2z = pz + pv2[2] * scale * nodeScale[2];
        v3x = px + pv3[0] * scale * nodeScale[0];
        v3y = py + pv3[1] * scale * nodeScale[1];
        v3z = pz + pv3[2] * scale * nodeScale[2];
        v4x = px + pv4[0] * scale * nodeScale[0];
        v4y = py + pv4[1] * scale * nodeScale[1];
        v4z = pz + pv4[2] * scale * nodeScale[2];
      } else {
        var tailLength = this.tailLength;
        var v = particle.velocity;
        var offsetx = tailLength * v[0];
        var offsety = tailLength * v[1];
        var offsetz = tailLength * v[2];
        
        var px2 = px + offsetx;
        var py2 = py + offsety;
        var pz2 = pz + offsetz;
        
        px -= offsetx;
        py -= offsety;
        pz -= offsetz;
                /*
        v1x = px2 - csx[0] * scale + csz[0] * scale;
        v1y = py2 - csx[1] * scale + csz[1] * scale;
        v1z = pz2 - csx[2] * scale + csz[2] * scale;

        v2x = px - csx[0] * scale - csz[0] * scale;
        v2y = py - csx[1] * scale - csz[1] * scale;
        v2z = pz - csx[2] * scale - csz[2] * scale;
        v3x = px + csx[0] * scale - csz[0] * scale;
        v3y = py + csx[1] * scale - csz[1] * scale;
        v3z = pz + csx[2] * scale - csz[2] * scale;
        v4x = px2 + csx[0] * scale + csz[0] * scale;
        v4y = py2 + csx[1] * scale + csz[1] * scale;
        v4z = pz2 + csx[2] * scale + csz[2] * scale;
        */
        v1x = px2 - csx[0] * scale * nodeScale[0];
        v1y = py2 - csx[1] * scale * nodeScale[1];
        v1z = pz2 - csx[2] * scale * nodeScale[2];

        v2x = px - csx[0] * scale * nodeScale[0];
        v2y = py - csx[1] * scale * nodeScale[1];
        v2z = pz - csx[2] * scale * nodeScale[2];
        
        v3x = px + csx[0] * scale * nodeScale[0];
        v3y = py + csx[1] * scale * nodeScale[1];
        v3z = pz + csx[2] * scale * nodeScale[2];
        
        v4x = px2 + csx[0] * scale * nodeScale[0];
        v4y = py2 + csx[1] * scale * nodeScale[1];
        v4z = pz2 + csx[2] * scale * nodeScale[2];
      }
      
      lta = encodeFloat3(left, top, a);
      lba = encodeFloat3(left, bottom, a);
      rta = encodeFloat3(right, top, a);
      rba = encodeFloat3(right, bottom, a);
      rgb = encodeFloat3(r, g, b);
      
      data[index + 0] = v1x;
      data[index + 1] = v1y;
      data[index + 2] = v1z;
      data[index + 3] = lta;
      data[index + 4] = rgb;
      
      data[index + 5] = v2x;
      data[index + 6] = v2y;
      data[index + 7] = v2z;
      data[index + 8] = lba;
      data[index + 9] = rgb;
      
      data[index + 10] = v3x;
      data[index + 11] = v3y;
      data[index + 12] = v3z;
      data[index + 13] = rba;
      data[index + 14] = rgb;
      
      data[index + 15] = v1x;
      data[index + 16] = v1y;
      data[index + 17] = v1z;
      data[index + 18] = lta;
      data[index + 19] = rgb;
      
      data[index + 20] = v3x;
      data[index + 21] = v3y;
      data[index + 22] = v3z;
      data[index + 23] = rba;
      data[index + 24] = rgb;
      
      data[index + 25] = v4x;
      data[index + 26] = v4y;
      data[index + 27] = v4z;
      data[index + 28] = rta;
      data[index + 29] = rgb;
    }
  },
  
  render: function (textureMap, shader, context) {
    var particles = this.activeParticles.length;
    
    if (particles > 0) {
      var filterMode = this.filterMode;
      
      if (filterMode === 1) {
        ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE);
      } else if (filterMode === 2 || filterMode === 3) {
        ctx.blendFunc(ctx.SRC_ZERO, ctx.SRC_COLOR);
      } else if (filterMode === 4) {
        ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE);
      } else {
        ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
      }
      
      bindTexture(this.texture, 0, this.model.textureMap, textureMap, context);
      
      ctx.uniform2fv(shader.variables.u_dimensions, this.dimensions);
      
      ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
      ctx.bufferSubData(ctx.ARRAY_BUFFER, 0, this.data.subarray(0, particles * 30 + 1));
      
      ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 20, 0);
      ctx.vertexAttribPointer(shader.variables.a_uva_rgb, 2, ctx.FLOAT, false, 20, 12);
        
      ctx.drawArrays(ctx.TRIANGLES, 0, particles * 6);
    }
  },
  
  shouldRender: function (sequence, frame, counter) {
    return getSDValue(sequence, frame, counter, this.sd.visibility) > VISIBILITY_CUTOFF;
  }
};

function Ribbon(emitter, sequence, frame, counter) {
  this.alive = true;
  this.health = emitter.lifespan;
  
  var position = emitter.node.pivot;
  var heightBelow = getSDValue(sequence, frame, counter, emitter.sd.heightBelow, emitter.heightBelow);
  var heightAbove = getSDValue(sequence, frame, counter, emitter.sd.heightAbove, emitter.heightAbove);
  
  var p1 = [position[0], position[1] - heightBelow, position[2]];
  var p2 = [position[0], position[1] + heightAbove, position[2]];
  
  vec3.transformMat4(p1, p1, emitter.node.worldMatrix);
  vec3.transformMat4(p2, p2, emitter.node.worldMatrix);
  
  this.p1 = p1;
  this.p2 = p2;
}

Ribbon.prototype = {
  update: function (emitter) {
    this.health -= context.frameTime / 1000;
    
    var zvelocity = emitter.gravity * (context.frameTime / 1000) * (context.frameTime / 1000);
    
    this.p1[2] -= zvelocity;
    this.p2[2] -= zvelocity;
  }
};

function RibbonEmitter(emitter, model, instance) {
  var i, l;
  var keys = Object.keys(emitter);
  
  for (i = keys.length; i--;) {
    this[keys[i]] = emitter[keys[i]];
  }
  
  var ribbons = Math.ceil(this.emissionRate * this.lifespan);
  
  this.model = model;
  this.textures = model.textures;
  
  this.maxRibbons = ribbons;
  this.lastCreation = 0;
  this.ribbons = [];
  this.data = new Float32Array(ribbons  * 10);
  this.buffer = ctx.createBuffer();
  
  ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
  ctx.bufferData(ctx.ARRAY_BUFFER, this.data, ctx.DYNAMIC_DRAW);
  
  this.cellWidth = 1 / this.columns;
  this.cellHeight = 1 / this.rows;
  
  var groups = [[], [], [], []];
  var layers = model.materials[this.materialId].layers;
        
  for (i = 0, l = layers.length; i &lt; l; i++) {
    var layer = new Layer(layers[i], 0);
    
    groups[layer.renderOrder].push(layer);
  }
  
  this.layers = groups[0].concat(groups[1]).concat(groups[2]).concat(groups[3]);
  
  this.node = instance.skeleton.nodes[this.node];
  this.sd = parseSDTracks(emitter.tracks, model);
  
  // Avoid heap allocations
  this.colorVec = vec3.create();
  this.modifierVec = vec4.create();
  this.uvoffsetVec = vec3.create();
  this.defaultUvoffsetVec = vec3.fromValues(0, 0, 0);
}

RibbonEmitter.prototype = {
  update: function (allowCreate, sequence, frame, counter, baseParticle, billboardedParticle) {
    var i, l;
    
    for (i = 0, l = this.ribbons.length; i &lt; l; i++) {
      this.ribbons[i].update(this);
    }
    
    while (this.ribbons.length > 0 &amp;&amp; this.ribbons[0].health &lt;= 0) {
      this.ribbons.shift();
    }
    
    if (allowCreate &amp;&amp; this.shouldRender(sequence, frame, counter)) {
      this.lastCreation += 1;
      
      var amount = this.emissionRate * (context.frameTime / 1000) * this.lastCreation;
      
      if (amount >= 1) {
        this.lastCreation = 0;
        
        for (i = 0; i &lt; amount; i++) {
          this.ribbons.push(new Ribbon(this, sequence, frame, counter));
        }
      }
    }
  },
  
  render: function (sequence, frame, counter, textureMap, shader, context) {
    var i, l;
    var ribbons = Math.min(this.ribbons.length, this.maxRibbons);
    
    if (ribbons > 2) {
      var textureSlot = getSDValue(sequence, frame, counter, this.sd.textureSlot, 0);
      //var uvOffsetX = (textureSlot % this.columns) / this.columns;
      var uvOffsetY = Math.floor(textureSlot / this.rows) / this.rows;
      var uvFactor = 1 / ribbons * this.cellWidth;
      var top = uvOffsetY;
      var bottom = uvOffsetY + this.cellHeight;
      var data = this.data;
      var index, ribbon, left, right, v1, v2;
      
      for (i = 0, l = ribbons; i &lt; l; i++) {
        index = i * 10;
        ribbon = this.ribbons[i];
        left = (ribbons - i) * uvFactor;
        right = left - uvFactor;
        v1 = ribbon.p2;
        v2 = ribbon.p1;
      
        data[index + 0] = v1[0];
        data[index + 1] = v1[1];
        data[index + 2] = v1[2];
        data[index + 3] = left;
        data[index + 4] = top;
        
        data[index + 5] = v2[0];
        data[index + 6] = v2[1];
        data[index + 7] = v2[2];
        data[index + 8] = right;
        data[index + 9] = bottom;
      }
      
      ctx.bindBuffer(ctx.ARRAY_BUFFER, this.buffer);
      ctx.bufferSubData(ctx.ARRAY_BUFFER, 0, this.data);
      
      ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 20, 0);
      ctx.vertexAttribPointer(shader.variables.a_uv, 2, ctx.FLOAT, false, 20, 12);
      
      var textureId, color, uvoffset, modifier = this.modifierVec;
      var layer, layers = this.layers;
      
      for (i = 0, l = layers.length; i &lt; l; i++) {
        layer = layers[i];
        
        if (layer.shouldRender(sequence, frame, counter)) {
          layer.setMaterial(shader);
          
          textureId = getSDValue(sequence, frame, counter, layer.sd.textureId, layer.textureId);
          
          bindTexture(this.textures[textureId], 0, this.model.textureMap, textureMap, context);
          
          color = getSDValue(sequence, frame, counter, this.sd.color, this.color, this.colorVec);
          uvoffset = this.defaultUvoffsetVec;
          
          modifier[0] = color[0];
          modifier[1] = color[1];
          modifier[2] = color[2];
          modifier[3] = getSDValue(sequence, frame, counter, this.sd.alpha, this.alpha);
          
          ctx.uniform4fv(shader.variables.u_modifier, modifier);
          
          if (layer.textureAnimationId !== -1 &amp;&amp; this.model.textureAnimations) {
            var textureAnimation = this.model.textureAnimations[layer.textureAnimationId];
            // What is Z used for?
            uvoffset = getSDValue(sequence, frame, counter, textureAnimation.sd.translation, this.defaultUvoffsetVec, this.uvoffsetVec);
          }
          
          ctx.uniform3fv(shader.variables.u_uv_offset, uvoffset);
          ctx.uniform3fv(shader.variables.u_type, layerFilterTypes[0]);
          
          ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, ribbons * 2);
        }
      }
    }
  },
  
  shouldRender: function (sequence, frame, counter) {
    return getSDValue(sequence, frame, counter, this.sd.visibility) > VISIBILITY_CUTOFF;
  }
};

  return {
    Parser: Parser,
    Model: Model,
    ModelInstance: ModelInstance
  };
}());

var M3 = (function () {

var Parser = (function () {
  var MD34_HEADER = 0x4d443334;
  
  function readColor(reader) {
    return readUint8Array(reader, 4);
  }
  
  function readUint16Pair(reader) {
    return readUint16Array(reader, 2);
  }
  
  function readBoundingSphere(reader) {
    return {minBorder: readVector3(reader), maxBorder: readVector3(reader), radius: readFloat32(reader)};
  }
  
  function parseReferenceString(reader, indexEntries) {
    var reference = new Reference(reader);
    var indexEntry = indexEntries[reference.index];
    var offset = tell(reader);
    var data;
    
    seek(reader, indexEntry.offset);
    
    data = read(reader, reference.entries);
    
    seek(reader, offset);
    
    return data;
  }
  
  function parseVertices(reader, indexEntries, uvSetCount) {
    var reference = new Reference(reader);
    var offset = tell(reader);
    var indexEntry = indexEntries[reference.index];
    var entries;

    seek(reader, indexEntry.offset);
    
    entries = readUint32Array(reader, reference.entries / 4);
    
    seek(reader, offset);

    return entries;
  }
  
  function parseSingleReference(reader, indexEntries, Func) {
    var reference = new Reference(reader);
    var indexEntry = indexEntries[reference.index];
    var offset = tell(reader);
    var entry;
    
    seek(reader, indexEntry.offset);
    
    entry = new Func(reader, indexEntries, indexEntry.version);
    
    seek(reader, offset);
    
    return entry;
  }

  function parseReference(reader, indexEntries, Func) {
    var reference = new Reference(reader);
    var indexEntry = indexEntries[reference.index];
    var offset = tell(reader);
    var entries = [];
    var entriesCount = reference.entries;
    
    seek(reader, indexEntry.offset);
    
    for (var i = 0, l = entriesCount; i &lt; entriesCount; i++) {
      entries[i] = new Func(reader, indexEntries, indexEntry.version);
    }
    
    seek(reader, offset);
    
    return entries;
  }
  
  function parseReferenceByVal(reader, indexEntries, Func) {
    var reference = new Reference(reader);
    var indexEntry = indexEntries[reference.index];
    var offset = tell(reader);
    var entries = [];
    var entriesCount = reference.entries;
    
    seek(reader, indexEntry.offset);
    
    for (var i = 0, l = entriesCount; i &lt; entriesCount; i++) {
      entries[i] = Func(reader, indexEntries, indexEntry.version);
    }
    
    seek(reader, offset);
    
    return entries;
  }
  
  // Parse by value using a typed array
  function parseReferenceByValTyped(reader, indexEntries, Func) {
    var reference = new Reference(reader);
    var offset = tell(reader);
    var indexEntry = indexEntries[reference.index];
    var entries;
    
    seek(reader, indexEntry.offset);
    
    entries = Func(reader, reference.entries);
    
    seek(reader, offset);
    
    return entries;
  }
  
  function parseSeqeunceData(reader, indexEntries, Func) {
    var reference = new Reference(reader);
    var indexEntry = indexEntries[reference.index];
    var offset = tell(reader);
    var entries = [];
    
    seek(reader, indexEntry.offset);
    
    for (var i = 0, l = reference.entries; i &lt; l; i++) {
      entries[i] = SD(reader, indexEntries, Func);
    }
    
    seek(reader, offset);
    
    return entries;
  }
  
  function readEvent(reader, indexEntries, version) {
    var e = {};
    
    e.version = version;
    e.name = parseReferenceString(reader, indexEntries);
    e.unknown0 = readInt32(reader);
    e.unknown1 = readInt16(reader);
    e.unknown2 = readUint16(reader);
    e.matrix = readMatrix(reader);
    e.unknown3 = readInt32(reader);
    e.unknown4 = readInt32(reader);
    e.unknown5 = readInt32(reader);
    
    if (version > 0) {
      e.unknown6 = readInt32(reader);
      e.unknown7 = readInt32(reader);
    }
    
    if (version > 1) {
      e.unknown8 = readInt32(reader);
    }
    
    return e;
  }
  
  function SD(reader, indexEntries, Func) {
    var keys = parseReferenceByValTyped(reader, indexEntries, readInt32Array);
    var flags = readUint32(reader);
    var biggestKey = readUint32(reader);
    var values = parseReferenceByVal(reader, indexEntries, Func);
  
    return {keys: keys, flags: flags, biggestKey: biggestKey, values: values};
  }

  function AnimationReference(reader, Func) {
    this.interpolationType = readUint16(reader);
    this.animFlags = readUint16(reader);
    this.animId = readUint32(reader);
    this.initValue = Func(reader);
    this.nullValue = Func(reader);
    this.unknown0 = readFloat32(reader);
  }
  
  function TMD(reader, indexEntries, version) {
    this.version = version;
  }
  
  function BBSC(reader, indexEntries, version) {
    this.version = version;
  }
  
  function AttachmentVolume(reader, indexEntries, version) {
    this.version = version;
    this.bone0 = readUint32(reader) + 1;
    this.bone1 = readUint32(reader) + 1;
    this.type = readUint32(reader);
    this.bone2 = readUint32(reader) + 1;
    this.matrix = readMatrix(reader);
    this.unknown0 = parseReferenceByVal(reader, indexEntries, readVector3);
    this.unknown1 = parseReferenceByValTyped(reader, indexEntries, readUint16Array);
    this.size = readVector3(reader);
  }
  
  function BoundingShape(reader) {
    this.shape = readUint32(reader); // 0: cube
                                                      // 1: sphere
                                                      // 2: cylinder
    this.bone = readInt16(reader) + 1;
    this.unknown0 = readUint16(reader);
    this.matrix = readMatrix(reader);
    this.unknown1 = readUint32(reader);
    this.unknown2 = readUint32(reader);
    this.unknown3 = readUint32(reader);
    this.unknown4 = readUint32(reader);
    this.unknown5 = readUint32(reader);
    this.unknown6 = readUint32(reader);
    this.size = readVector3(reader);
  }
  
  function TRGD(reader, indexEntries, version) {
    this.version = version;
    this.unknown0 = parseReferenceByValTyped(reader, indexEntries, readUint32Array);
    this.name = parseReferenceString(reader, indexEntries);
  }
  
  function PATU(reader, indexEntries, version) {
    this.version = version;
  }
  
  function IKJT(reader, indexEntries, version) {
    this.version = version;
  }
  
  function PhysicsJoint(reader, indexEntries, version) {
    this.version = version;
  }
  
  function DMSE(reader, indexEntries, version) {
    this.version = version;
    this.unknown0 = readUint8(reader);
    this.i0 = readUint8(reader);
    this.i1 = readUint8(reader);
    this.i2 = readUint8(reader);
  }
    
  function PhysicsShape(reader, indexEntries, version) {
    this.version = version;
    this.matrix = readMatrix(reader);
    
    if (version &lt; 2) {
      this.unknown0 = readUint32(reader);
    }
    
    this.shape = readUint8(reader); // 0 box
                                              // 1 sphere
                                              // 2 capsule
                                              // 3 cylinder
                                              // 4 convex hull
                                              // 5 mesh
    this.unknown1 = readUint8(reader);
    this.unknown2 = readUint16(reader);
    
    if (version &lt; 2) {
      this.vertices = parseReferenceByVal(reader, indexEntries, readVector3);
      this.unknown3 = parseReferenceByValTyped(reader, indexEntries, readUint8Array);
      this.triangles = parseReferenceByValTyped(reader, indexEntries, readUint16Array);
      this.planeEquations = parseReferenceByVal(reader, indexEntries, readVector4);
    }
    
    if (version > 2) {
      this.unknown4 = read(reader, 24);
    }
    
    this.size0 = readFloat32(reader);
    this.size1 = readFloat32(reader);
    this.size2 = readFloat32(reader);
    
    if (version > 2) {
      this.unknown5 = parseReferenceByVal(reader, indexEntries, readVector3);
      this.unknown6 = parseReferenceByVal(reader, indexEntries, readVector4);
      this.unknown7 = parseReference(reader, indexEntries, DMSE);
      this.unknown8 = parseReferenceByValTyped(reader, indexEntries, readUint8Array);
      this.unknown9 = new Reference(reader);
      this.unknown10 = readUint32(reader);
      this.unknown11 = readUint32(reader);
      this.unknown12 = readUint32(reader);
      this.unknown13 = readUint32(reader);
      this.unknown14 = readUint32(reader);
      this.unknown15 = read(reader, 84);
      this.unknown16 = readUint32(reader);
      this.unknown17 = readUint32(reader);
      this.unknown18 = readUint32(reader);
      this.unknown19 = readUint32(reader);
      this.unknown20 = readUint32(reader);
      this.unknown21 = readUint32(reader);
      this.unknown22 = readUint32(reader);
      this.unknown23 = readUint32(reader);
    }
  }
  
  function  RigidBody(reader, indexEntries, version) {
    this.version = version;
    
    if (version &lt; 3) {
      this.unknown0To14 = readFloat32Array(reader, 15);
      this.bone = readUint16(reader) + 1;
      this.boneUnused = readUint16(reader) + 1;
      this.unknown15 = read(reader, 15);
    }
    
    if (version > 3) {
      this.unknown16 = readUint16(reader);
      this.unknown17 = readUint16(reader);
      this.unknown18 = readUint32(reader);
      this.bone = readUint32(reader) + 1;
      this.unknown19 = readFloat32(reader);
      this.unknown20 = readFloat32(reader);
      this.unknown21 = readFloat32(reader);
      this.unknown22 = readFloat32(reader);
      this.unknown23 = readFloat32(reader);
      this.unknown24 = readFloat32(reader);
      this.unknown25 = new AnimationReference(reader, readUint32); // Unknown reference type
      this.unknown26 = readFloat32(reader);
    }
    
    this.physicsShapes = parseReference(reader, indexEntries, PhysicsShape);
    this.flags = readUint32(reader); // 0x1 collidable
                                              // 0x2 walkable
                                              // 0x4 stackable
                                              // 0x8 simulateOnCollision
                                              // 0x10 ignoreLocalBodies
                                              // 0x20 alwaysExists
                                              // 0x80 doNotSimulate
    this.localForces = readUint16(reader); // 0x1 1
                                                       // 0x2 2
                                                       // 0x4 3
                                                       // 0x8 4
                                                       // 0x10 5
                                                       // 0x20 6
                                                       // 0x40 7
                                                       // 0x80 8
                                                       // 0x100 9
                                                       // 0x200 10
                                                       // 0x400 11
                                                       // 0x800 12
                                                       // 0x1000 13
                                                       // 0x2000 14
                                                       // 0x4000 15
                                                       // 0x8000 16
    this.worldForces = readUint16(reader); // 0x1 wind
                                                        // 0x2 explosion
                                                        // 0x4 energy
                                                        // 0x8 blood
                                                        // 0x10 magnetic
                                                        // 0x20 grass
                                                        // 0x40 brush
                                                        // 0x80 trees
    this.priority = readUint32(reader);
  }
  
  function Warp(reader, indexEntries, version) {
    this.version = version;
    this.unknown0 = readUint32(reader);
    this.bone = readUint32(reader) + 1;
    this.unknown1 = readUint32(reader);
    this.radius = new AnimationReference(reader, readFloat32);
    this.unknown2 = new AnimationReference(reader, readFloat32);
    this.compressionStrength = new AnimationReference(reader, readFloat32);
    this.unknown3 = new AnimationReference(reader, readFloat32);
    this.unknown4 = new AnimationReference(reader, readFloat32);
    this.unknown5 = new AnimationReference(reader, readFloat32);
  }
  
  function Force(reader, indexEntries, version) {
    this.version = version;
    this.type = readUint32(reader);
    this.unknown0 = readUint32(reader);
    this.unknown1 = readUint32(reader);
    this.bone = readUint32(reader) + 1;
    this.unknown2 = readUint32(reader);
    this.forceChannels = readUint32(reader);
    this.forceStrength = new AnimationReference(reader, readFloat32); 
    this.forceRange = new AnimationReference(reader, readFloat32); 
    this.unknown3 = new AnimationReference(reader, readFloat32); 
    this.unknown4 = new AnimationReference(reader, readFloat32); 
  }
  
  function Projection(reader, indexEntries, version) {
    this.version = version;
    this.unknown0 = readUint32(reader);
    this.bone = readUint32(reader) + 1;
    this.materialReferenceIndex = readUint32(reader); // Maybe?
    this.unknown1 = new AnimationReference(reader, readVector3); // Unknown reference type
    this.unknown2 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown3 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown4 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown5 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown6 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown7 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown8 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown9 = new AnimationReference(reader, readFloat32); 
    this.unknown10 = new AnimationReference(reader, readFloat32); 
    this.unknown11 = new AnimationReference(reader, readFloat32); 
    this.unknown12 = new AnimationReference(reader, readFloat32); 
    this.unknown13 = new AnimationReference(reader, readFloat32); 
    this.unknown14 = new AnimationReference(reader, readFloat32); 
    this.unknown15 = readUint32(reader);
    this.unknown16 = readFloat32(reader);
    this.unknown17 = readFloat32(reader);
    this.unknown18 = readFloat32(reader);
    this.unknown19 = readFloat32(reader);
    this.unknown20 = readUint32(reader);
    this.unknown21 = readFloat32(reader);
    this.unknown22 = readUint32(reader);
    this.unknown23 = readFloat32(reader);
    this.unknown24 = readUint32(reader);
    this.unknown25 = readFloat32(reader);
    this.unknown26 = new AnimationReference(reader, readUint32); 
    this.unknown27 = readUint32(reader);
    this.unknown28 = readUint32(reader);
    this.unknown29 = readUint32(reader);
    this.unknown30 = readUint32(reader);
  }
  
  function SRIB(reader, indexEntries, version) {
    this.version = version;
  }
  
  function RibbonEmitter(reader, indexEntries, version) {
    this.version = version;
    this.bone = readUint8(reader) + 1;
    this.short1 = readUint8(reader);
    this.short2 = readUint8(reader);
    this.short3 = readUint8(reader);
    this.materialReferenceIndex = readUint32(reader);
    
    if (version > 7) {
      this.unknown0 = readUint32(reader);
    }
    
    this.waveLength = new AnimationReference(reader, readFloat32); 
    this.unknown1 = new AnimationReference(reader, readUint32); // Unknown reference type
    
    if (version &lt; 7) {
      this.unknown2 = readInt32(reader);
    }
    
    this.unknown3 = new AnimationReference(reader, readFloat32); 
    this.unknown4 = new AnimationReference(reader, readFloat32); 
    this.unknown5 = new AnimationReference(reader, readFloat32); 
    this.unknown6 = new AnimationReference(reader, readFloat32); 
    this.unknown7 = new AnimationReference(reader, readFloat32); 
    this.unknown8 = new AnimationReference(reader, readFloat32); 
    this.unknown9 = readUint32(reader);
    this.unknown10 = readUint32(reader);
    this.unknown11 = readFloat32(reader);
    this.unknown12 = readFloat32(reader);
    this.tipOffsetZ = readFloat32(reader);
    this.centerBias = readFloat32(reader);
    this.unknown13 = readFloat32(reader);
    this.unknown14 = readFloat32(reader);
    this.unknown15 = readFloat32(reader);
    
    if (version > 7) {
      this.unknown16 = new Reference(reader); // Reference?
    }
    
    this.radiusScale = new AnimationReference(reader, readVector3); 
    this.twist = new AnimationReference(reader, readFloat32); 
    this.unknown17 = readUint32(reader);
    this.unknown18 = readUint32(reader);
    this.unknown19 = readUint32(reader);
    this.unknown20 = readUint32(reader);
    this.baseColoring = new AnimationReference(reader, readColor);  
    this.centerColoring = new AnimationReference(reader, readColor);  
    this.tipColoring = new AnimationReference(reader, readColor);  
    this.stretchAmount = readFloat32(reader);
    
    if (version &lt; 7) {
      this.unknown21 = readFloat32(reader);
    }
    
    if (version > 7) {
      this.unknown22 = readFloat32(reader);
    }
    
    this.stretchLimit = readFloat32(reader);
    this.unknown23 = readFloat32(reader);
    this.unknown24 = readFloat32(reader);
    this.unknown25 = readUint32(reader);
    
    if (version &lt; 7) {
      this.unknown26 = readUint32(reader);
      this.unknown27 = readUint32(reader);
    }
    
    this.surfaceNoiseAmplitude = readFloat32(reader);
    this.surfaceNoiseNumberOfWaves = readFloat32(reader);
    this.surfaceNoiseFrequency = readFloat32(reader);
    this.surfaceNoiseScale = readFloat32(reader);
    this.unknown28 = readUint32(reader);
    this.ribbonType = readUint32(reader);
    this.unknown29 = readUint32(reader);
    this.ribbonDivisions = readFloat32(reader);
    this.ribbonSides = readUint32(reader);
    this.unknown30 = readFloat32(reader);
    this.ribbonLength = new AnimationReference(reader, readFloat32); 
    
    if (version &lt; 7) {
      this.filler1 = readInt32(reader);
    }
    
    this.srib = parseReference(reader, indexEntries, SRIB);
    this.unknown31 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.flags = readUint32(reader); // 0x2 collideWithTerrain
                                              // 0x4 collideWithObjects
                                              // 0x8 edgeFalloff
                                              // 0x10 inheritParentVelocity
                                              // 0x20 smoothSize
                                              // 0x40 bezierSmoothSize
                                              // 0x80 useVertexAlpha
                                              // 0x100 scaleTimeByParent
                                              // 0x200 forceLegacy
                                              // 0x400 useLocaleTime
                                              // 0x800 simulateOnInitialization
                                              // 0x1000 useLengthAndTime
    this.unknown32 = readUint32(reader);
    this.unknown33 = readFloat32(reader);
    this.unknown34 = readUint32(reader);
    this.unknown35 = readUint32(reader);
            
    if (version > 7) {
      this.unknown36 = read(reader, 8);
    }
    
    this.directionVariationBool = readUint32(reader);
    this.directionVariationAmount = new AnimationReference(reader, readFloat32); 
    this.directionVariationFrequency = new AnimationReference(reader, readFloat32); 
    this.amplitudeVariationBool = readUint32(reader);
    this.amplitudeVariationAmount = new AnimationReference(reader, readFloat32); 
    this.amplitudeVariationFrequency = new AnimationReference(reader, readFloat32); 
    this.lengthVariationBool = readUint32(reader);
    this.lengthVariationAmount = new AnimationReference(reader, readFloat32); 
    this.lengthVariationFrequency = new AnimationReference(reader, readFloat32); 
    this.radiusVariationBool = readUint32(reader);
    this.radiusVariationAmount = new AnimationReference(reader, readFloat32); 
    this.radiusVariationFrequency = new AnimationReference(reader, readFloat32); 
    this.unknown37 = readInt32(reader);
    this.unknown38 = new AnimationReference(reader, readFloat32); 
    this.unknown39 = new AnimationReference(reader, readFloat32); 
    this.unknown40 = new AnimationReference(reader, readFloat32); 
    this.unknown41 = new AnimationReference(reader, readFloat32); 
  }
  
  function ParticleEmitterCopy(reader, indexEntries, version) {
    this.version = version;
    this.emissionRate = new AnimationReference(reader, readFloat32);
    this.partEmit = new AnimationReference(reader, readInt16);
    this.bone = readUint32(reader) + 1;
  }
  
  function ParticleEmitter(reader, indexEntries, version) {
    this.version = version;
    this.bone = readUint32(reader) + 1;
    this.materialReferenceIndex = readUint32(reader);
    
    if (version > 16) {
      this.additionalFlags = readUint32(reader); // 0x1 randomizeWithEmissionSpeed2
                                                               // 0x1 randomizeWithLifespan2
                                                               // 0x1 randomizeWithMass2
                                                               // 0x1 trailingEnabled
    }

    this.emissionSpeed1 = new AnimationReference(reader, readFloat32);
    this.emissionSpeed2 = new AnimationReference(reader, readFloat32);
    
    if (version &lt; 13) {
      this.randomizeWithEmissionSpeed2 = readUint32(reader);
    }
    
    this.emissionAngleX = new AnimationReference(reader, readFloat32);
    this.emissionAngleY = new AnimationReference(reader, readFloat32);
    this.emissionSpreadX = new AnimationReference(reader, readFloat32);
    this.emissionSpreadY = new AnimationReference(reader, readFloat32);
    this.lifespan1 = new AnimationReference(reader, readFloat32);
    this.lifespan2 = new AnimationReference(reader, readFloat32);
    
    if (version &lt; 13) {
      this.randomizeWithLifespan2 = readUint32(reader);
    }
    
    this.unknown0 = new Reference(reader);
    this.zAcceleration = readFloat32(reader);
    this.sizeAnimationMiddle = readFloat32(reader);
    this.colorAnimationMiddle = readFloat32(reader);
    this.alphaAnimationMiddle = readFloat32(reader);
    this.rotationAnimationMiddle = readFloat32(reader);
    
    if (version > 16) {
      this.sizeHoldTime = readFloat32(reader);
      this.colorHoldTime = readFloat32(reader);
      this.alphaHoldTime = readFloat32(reader);
      this.rotationHoldTime = readFloat32(reader);
    }

    this.particleSizes1 = new AnimationReference(reader, readVector3);
    this.rotationValues1 = new AnimationReference(reader, readVector3);
    this.initialColor1 = new AnimationReference(reader, readColor);
    this.middleColor1 = new AnimationReference(reader, readColor);
    this.finalColor1 = new AnimationReference(reader, readColor);
    this.slowdown = readFloat32(reader);
    this.mass = readFloat32(reader);
    this.mass2 = readFloat32(reader);
    this.unknown1 = readFloat32(reader);
    
    if (version &lt; 13) {
      this.unknown2 = readUint32(reader);
      this.trailingEnabled = readUint32(reader);
    }
    
    this.localForceChannels = readUint16(reader);
    this.worldForceChannels = readUint16(reader);
    this.forceChannelsFillerBytes = readUint16(reader);
    this.worldForceChannelsCopy = readUint16(reader);
    this.noiseAmplitude = readFloat32(reader);
    this.noiseFrequency = readFloat32(reader);
    this.noiseCohesion = readFloat32(reader);
    this.noiseEdge = readFloat32(reader);
    this.indexPlusHighestIndex = readUint32(reader);
    this.maxParticles = readUint32(reader);
    this.emissionRate = new AnimationReference(reader, readFloat32);
    this.emissionAreaType = readUint32(reader);
    this.emissionAreaSize = new AnimationReference(reader, readVector3);
    this.emissionAreaCutoutSize = new AnimationReference(reader, readVector3);
    this.emissionAreaRadius = new AnimationReference(reader, readFloat32);
    this.emissionAreaCutoutRadius = new AnimationReference(reader, readFloat32);
    
    if (version > 16) {
      this.unknown3 = parseReferenceByVal(reader, indexEntries, readUint32);
    }
    
    this.emissionType = readUint32(reader);
    this.randomizeWithParticleSizes2 = readUint32(reader);
    this.particleSizes2 = new AnimationReference(reader, readVector3);
    this.randomizeWithRotationValues2 = readUint32(reader);
    this.rotationValues2 = new AnimationReference(reader, readVector3);
    this.randomizeWithColor2 = readUint32(reader);
    this.initialColor2 = new AnimationReference(reader, readColor);
    this.middleColor2 = new AnimationReference(reader, readColor);
    this.finalColor2 = new AnimationReference(reader, readColor);
    this.unknown4 = readUint32(reader);
    this.partEmit = new AnimationReference(reader, readInt16);
    this.phase1StartImageIndex = readUint8(reader);
    this.phase1EndImageIndex = readUint8(reader);
    this.phase2EndImageIndex = readUint8(reader);
    this.phase2StartImageIndex = readUint8(reader);
    this.relativePhase1Length = readFloat32(reader);
    this.numberOfColumns = readUint16(reader);
    this.numberOfRows = readUint16(reader);
    this.columnWidth = readFloat32(reader);
    this.rowHeight = readFloat32(reader);
    this.unknown5 = readFloat32(reader);
    this.unknown6 = readFloat32(reader);
    this.unknown7 = readInt32(reader);
    this.unknown8 = read(reader, 20);
    this.particleType = readUint32(reader); // 0, 2, 3, 4, 5 square billboards
                                                        // 1 speed scaled and rotated billboards influenced by lengthWidhtRatio
                                                        // 6 rectangular billboards using lengthWidhtRatio
                                                        // 7 quads with normal speed
                                                        // 9 quads that stretch between the spawn point and current location
    this.lengthWidthRatio = readFloat32(reader);
    this.unknown9 = read(reader, 8);
    this.unknown10 = readFloat32(reader);
    
    if (version > 16) {
      this.unknown11 = readFloat32(reader);
    }
    
    this.unknown12 = readUint32(reader);
    this.unknown13 = new AnimationReference(reader, readFloat32);
    this.unknown14 = new AnimationReference(reader, readFloat32);
    this.unknown15 = readUint32(reader);
    this.unknown16 = new AnimationReference(reader, readFloat32);
    this.unknown17 = new AnimationReference(reader, readFloat32);
    this.unknown18 = readUint32(reader);
    this.unknown19 = new AnimationReference(reader, readFloat32);
    this.unknown20 = new AnimationReference(reader, readFloat32);
    this.unknown21 = readUint32(reader);
    this.unknown22 = new AnimationReference(reader, readFloat32);
    this.unknown23 = new AnimationReference(reader, readFloat32);
    this.unknown24 = readUint32(reader);
    this.unknown25 = new AnimationReference(reader, readFloat32);
    this.unknown26 = new AnimationReference(reader, readFloat32);
    this.unknown27 = readUint32(reader);
    this.unknown28 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown29 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown30 = read(reader, 4);
    this.unknown31 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown32 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown33 = read(reader, 4);
    this.unknown34 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown35 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown36 = read(reader, 4);
    this.unknown37 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown38 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown39 = new AnimationReference(reader, readFloat32);

    if (version > 21) {
      this.unknown40 = new AnimationReference(reader, readUint32); // Unknown reference type
    }
    
    this.flags = readUint32(reader); // 0x1 sort
                                              // 0x2 collideTerrain
                                              // 0x4 collideObjects
                                              // 0x8 spawnOnBounce
                                              // 0x10 cutoutEmissionArea
                                              // 0x20 inheritEmissionParams
                                              // 0x40 inheritParentVel
                                              // 0x80 sortByZHeight
                                              // 0x100 reverseIteration
                                              // 0x200 smoothRotation
                                              // 0x400 bezSmoothRotation
                                              // 0x800 smoothSize
                                              // 0x1000 bezSmoothSize
                                              // 0x2000 smoothColor
                                              // 0x4000 bezSmoothColor
                                              // 0x8000 litParts
                                              // 0x10000 randFlipBookStart
                                              // 0x20000 multiplyByGravity
                                              // 0x40000 clampTailParts
                                              // 0x80000 spawnTrailingParts
                                              // 0x100000 fixLengthTailParts
                                              // 0x200000 useVertexAlpha
                                              // 0x400000 modelParts
                                              // 0x800000 swapYZonModelParts
                                              // 0x1000000 scaleTimeByParent
                                              // 0x2000000 useLocalTime
                                              // 0x4000000 simulateOnInit
                                              // 0x8000000 copy
    
    if (version > 17) {
      this.rotationFlags = readUint32(reader); // 0x2 relativeRotation
                                                            // 0x4 alwaysSet
   }
   
   if (version > 16) {
      this.colorSmoothingType = readUint32(reader);      // 0 linear
      this.sizeSmoothingType = readUint32(reader);       // 1 smooth
      this.rotationSmoothingType = readUint32(reader); // 2 bezier
                                                                           // 3 linear hold
                                                                           // 4 bezier hold
      this.unknown41 = new AnimationReference(reader, readFloat32);
      this.unknown42 = new AnimationReference(reader, readVector2);
      this.unknown43 = new AnimationReference(reader, readVector3);
      this.unknown44 = new AnimationReference(reader, readVector2);
    }

    // NOTE: m3addon says this is an animation reference, but that causes parsing errors. Is this a reference?
    this.spawnPoints = parseReferenceByVal(reader, indexEntries, readVector3);//new AnimationReference(reader, readVector3);
    this.unknown45 = readFloat32(reader);
    this.unknown46 = readUint32(reader);
    this.unknown47 = readUint32(reader);
    this.unknown48 = new AnimationReference(reader, readUint32); // Unknown reference type
    this.unknown49 = new AnimationReference(reader, readFloat32);
    this.trailingParticlesIndex = readInt32(reader);
    this.trailingParticlesChance = readFloat32(reader);
    this.trailingParticlesRate = new AnimationReference(reader, readFloat32);
    this.unknown50 = read(reader, 8);
    this.usedModel = parseReferenceString(reader, indexEntries);
    this.copyIndices = parseReferenceByVal(reader, indexEntries, readUint32);
  }
  
  function Layer(reader, indexEntries, version) {
    this.version = version;
    this.unknown0 = readUint32(reader);
    this.imagePath = parseReferenceString(reader, indexEntries);
    this.color = new AnimationReference(reader, readColor);
    this.flags = readUint32(reader); // 0x4 textureWrapX
                                              // 0x8 textureWrapY
                                              // 0x10 invertColor
                                              // 0x20 clamp
                                              // 0x100 useParticleFlipbook
                                              // 0x400 colorEnabled
    this.uvSource = readUint32(reader); // 0 explicitUnwrap1
                                                     // 1 explicitUnwrap2
                                                     // 2 reflectiveCubeEnv
                                                     // 3 reflectiveSphereEnv
                                                     // 4 planarLocalZ
                                                     // 5 planarWorldZ
                                                     // 6 Particle Flipbook
                                                     // 7 cubicEnv
                                                     // 8 sphereEnv
                                                     // 9 explicitUnwrap3
                                                     // 10 explicitUnwrap4
                                                     // 11 planarLocalX
                                                     // 12 planarLocalY
                                                     // 13 planarWorldX
                                                     // 14 planarWorldY
                                                     // 15 screenSpace
                                                     // 16 triPlanarLocal
                                                     // 17 triPlanerWorld
                                                     // 18 triPlayedWorldLocalZ
    this.colorChannels = readUint32(reader); // 0 RGB
                                                           // 1 RGBA
                                                           // 2 A
                                                           // 3 R
                                                           // 4 G
                                                           // 5 B
    this.rgbMultiply = new AnimationReference(reader, readFloat32);
    this.rgbAdd = new AnimationReference(reader, readFloat32);
    this.unknown1 = readUint32(reader);
    this.unknown2 = readInt32(reader);
    this.unknown3 = readUint32(reader);
    this.replaceableChannel = readUint32(reader); // -1 noReplaceable
                                                                   // 0 channel 1
                                                                   // 1 channel 2
                                                                   // 2 channel 3
                                                                   // 3 channel 4
                                                                   // 4 channel 5
                                                                   // 5 channel 6
                                                                   // 6 channel 7
    this.unknown4 = readInt32(reader);
    this.unknown5 = readUint32(reader);
    this.unknown6 = readUint32(reader);
    this.unknown7 = new AnimationReference(reader, readUint32);
    this.unknown8 = new AnimationReference(reader, readVector2);
    this.flipBook = new AnimationReference(reader, readInt16);
    this.uvOffset = new AnimationReference(reader, readVector2);
    this.uvAngle = new AnimationReference(reader, readVector3);
    this.uvTiling = new AnimationReference(reader,  readVector2);
    this.unknown9 = new AnimationReference(reader, readUint32);
    this.unknown10 = new AnimationReference(reader, readFloat32);
    this.brightness = new AnimationReference(reader, readFloat32);
    this.unknown11 = readInt32(reader);
    this.fresnelFlags = readUint32(reader); // 0x1 ?
                                                         // 0x2 ?
                                                         // 0x4 colorEnabled
    this.fresnelStrength = readFloat32(reader);
    this.fresnelStart = readFloat32(reader);
    this.triPlannarOffset = readVector3(reader);
    this.triPlannarScale = readVector3(reader);
  }
  
  function CreepMaterial(reader, indexEntries) {
    this.name = parseReferenceString(reader, indexEntries);
    this.creepLayer = parseSingleReference(reader, indexEntries, Layer);
  }
  
  function VolumeNoiseMaterial(reader, indexEntries, version) {
    this.version = version;
  }
  
  function VolumeMaterial(reader, indexEntries, version) {
    this.version = version;
    this.name = parseReferenceString(reader, indexEntries);
    this.unknown0 = readUint32(reader);
    this.unknown1 = readUint32(reader);
    this.volumeDensity = new AnimationReference(reader, readFloat32);
    this.colorDefiningLayer = parseSingleReference(reader, indexEntries, Layer);
    this.unknown2 = parseSingleReference(reader, indexEntries, Layer);
    this.unknown3 = parseSingleReference(reader, indexEntries, Layer);
    this.unknown4 = readUint32(reader);
    this.unknown5 = readUint32(reader);
  }
  
  function TerrainMaterial(reader, indexEntries, version) {
    this.version = version;
    this.name = parseReferenceString(reader, indexEntries);
    this.terrainLayer = parseSingleReference(reader, indexEntries, Layer);
  }
  
  function CompositeMaterialSection(reader, indexEntries, version) {
    this.version = version;
    this.materialReferenceIndex = readUint32(reader);
    this.alphaFactor = new AnimationReference(reader, readFloat32);
  }
  
  function CompositeMaterial(reader, indexEntries, version) {
    this.version = version;
    this.name = parseReferenceString(reader, indexEntries);
    this.unknown0 = readUint32(reader);
    this.sections = parseReference(reader, indexEntries, CompositeMaterialSection);
  }
  
  function DisplacementMaterial(reader, indexEntries, version) {
    this.version = version;
    this.name = parseReferenceString(reader, indexEntries);
    this.unknown0 = readUint32(reader);
    this.strengthFactor = new AnimationReference(reader, readFloat32);
    this.normalLayer = parseSingleReference(reader, indexEntries, Layer);
    this.strengthLayer = parseSingleReference(reader, indexEntries, Layer);
    this.flags = readUint32(reader);
    this.priority = readInt32(reader);
  }
  
  function StandardMaterial(reader, indexEntries, version) {
    this.name = parseReferenceString(reader, indexEntries);
    this.specialFlags = readUint32(reader); // 0x1 useDepthBlend
                                                        // 0x4 useVertexColor
                                                        // 0x8 useVertexAlpha
                                                        // 0x200 useTransparentShadows
    this.flags = readUint32(reader); // 0x1 useVertexColor
                                              // 0x2 useVertexAlpha
                                              // 0x4 unfogged
                                              // 0x8 twoSided
                                              // 0x10 unshaded
                                              // 0x20 noShadowsCast
                                              // 0x40 noHitTest
                                              // 0x80 noShadowsReceived
                                              // 0x100 depthPrepass
                                              // 0x200 useTerrainHDR
                                              // 0x800 splatUVfix
                                              // 0x1000 softBlending
                                              // 0x4000 transparentShadows
                                              // 0x8000 decalLighting
                                              // 0x10000 transparencyAffectsDepth
                                              // 0x20000 localLightsOnTransparencies
                                              // 0x40000 disableSoftDepthBlend
                                              // 0x80000 doubleLambert
                                              // 0x100000 hairLayerSorting
                                              // 0x200000 acceptsSplats
                                              // 0x400000 decalRequiredOnLowEnd
                                              // 0x800000 emissiveRequiredOnLowEnd
                                              // 0x1000000 specularRequiredOnLowEnd
                                              // 0x2000000 acceptSplatsOnly
                                              // 0x4000000 isBackgroundObject
                                              // 0x10000000 zfillRequiredOnLowEnd
                                              // 0x20000000 excludeFromHighlighting
                                              // 0x40000000 clampOutput
                                              // 0x80000000 visible
    this.blendMode = readUint32(reader); // 0 opaque
                                                       // 1 blend
                                                       // 2 additive
                                                       // 3 probably addAlpha
                                                       // 4 mod
                                                       // 5 mod2x
                                                       
    this.priority = readInt32(reader);
    this.unknown0 = readUint32(reader);
    this.specularity = readFloat32(reader);
    this.depthBlend = readFloat32(reader);
    this.alphaTestThreshold = readUint8(reader);
    this.unknown1 = readUint8(reader);
    this.unknown2 = readUint8(reader);
    this.unknown3 = readUint8(reader);
    this.specMult = readFloat32(reader);
    this.emisMult = readFloat32(reader);
    this.diffuseLayer = parseSingleReference(reader, indexEntries, Layer);
    this.decalLayer = parseSingleReference(reader, indexEntries, Layer);
    this.specularLayer = parseSingleReference(reader, indexEntries, Layer);
    
    if (version > 15) {
      this.glossLayer = parseSingleReference(reader, indexEntries, Layer);
    }
    
    this.emissiveLayer = parseSingleReference(reader, indexEntries, Layer);
    this.emissive2Layer = parseSingleReference(reader, indexEntries, Layer);
    this.evioLayer = parseSingleReference(reader, indexEntries, Layer);
    this.evioMaskLayer = parseSingleReference(reader, indexEntries, Layer);
    this.alphaMaskLayer = parseSingleReference(reader, indexEntries, Layer);
    this.alphaMask2Layer = parseSingleReference(reader, indexEntries, Layer);
    this.normalLayer = parseSingleReference(reader, indexEntries, Layer);
    this.heightLayer = parseSingleReference(reader, indexEntries, Layer);
    this.lightMapLayer = parseSingleReference(reader, indexEntries, Layer);
    this.ambientOcclusionLayer = parseSingleReference(reader, indexEntries, Layer);
    this.unknown4 = readUint32(reader);
    this.layerBlendType = readUint32(reader);
    this.emisBlendType = readUint32(reader);
    this.emisMode = readUint32(reader);
    this.specType = readUint32(reader);
    this.unknown5 = new AnimationReference(reader, readUint32);
    this.unknown6 = new AnimationReference(reader, readUint32);
  }
  
  function MaterialMap(reader) {
    this.materialType = readUint32(reader);
    this.materialIndex = readUint32(reader);
  }

  function Camera(reader, indexEntries, version) {
    this.version = version;
    this.bone = readUint32(reader) + 1;
    this.name = parseReferenceString(reader, indexEntries);
    this.fieldOfView = new AnimationReference(reader, readFloat32);
    this.unknown0 = readUint32(reader);
    this.farClip = new AnimationReference(reader, readFloat32);
    this.nearClip = new AnimationReference(reader, readFloat32);
    this.clip2 = new AnimationReference(reader, readFloat32);
    this.focalDepth = new AnimationReference(reader, readFloat32);
    this.falloffStart = new AnimationReference(reader, readFloat32);
    this.falloffEnd = new AnimationReference(reader, readFloat32);
    this.depthOfField = new AnimationReference(reader, readFloat32);
  }
  /*
  function SHBX(reader, indexEntries, version) {
    this.version = version;
  }
  */
  function Light(reader, indexEntries, version) {
    this.version = version;
    this.type = readUint8(reader);
    this.unknown0 = readUint8(reader);
    this.bone = readInt16(reader) + 1;
    this.flags = readUint32(reader); // 0x1 shadowCast
                                              // 0x2 specular
                                              // 0x4 unknown
                                              // 0x8 turnOn
    this.unknown1 = readUint32(reader);
    this.unknown2 = readInt32(reader);
    this.lightColor = new AnimationReference(reader, readVector3);
    this.lightIntensity = new AnimationReference(reader, readFloat32);
    this.specularColor = new AnimationReference(reader, readVector3);
    this.specularIntensity = new AnimationReference(reader, readFloat32);
    this.attenuationFar = new AnimationReference(reader, readFloat32);
    this.unknown3 = readFloat32(reader);
    this.attenuationNear = new AnimationReference(reader, readFloat32);
    this.hotSpot = new AnimationReference(reader, readFloat32);
    this.falloff = new AnimationReference(reader, readFloat32);
  }
  
  function AttachmentPoint(reader, indexEntries, version) {
    this.version = version;
    this.unknown = readInt32(reader);
    this.name = parseReferenceString(reader, indexEntries);
    this.bone = readUint32(reader) + 1;
  }
  
  function MSEC(reader) {
    this.unknown0 = readUint32(reader);
    this.boundings = new AnimationReference(reader, readBoundingSphere);
  }

  function Batch(reader) {
    this.unknown0 = readUint32(reader);
    this.regionIndex = readUint16(reader);
    this.unknown1 = readUint32(reader);
    this.materialReferenceIndex = readUint16(reader);
    this.unknown2 = readUint16(reader);
  }
  
  function Region(reader) {
    this.unknown0 = readUint32(reader);
    this.unknown1 = readUint32(reader);
    this.firstVertexIndex = readUint32(reader);
    this.verticesCount = readUint32(reader);
    this.firstTriangleIndex = readUint32(reader);
    this.triangleIndicesCount = readUint32(reader);
    this.bonesCount = readUint16(reader);
    this.firstBoneLookupIndex = readUint16(reader);
    this.boneLookupIndicesCount = readUint16(reader);
    this.unknown2 = readUint16(reader);
    this.boneWeightPairsCount = readUint8(reader);
    this.unknown3 = readUint8(reader);
    this.rootBoneIndex = readUint16(reader);
  }
  
  function Division(reader, indexEntries, version) {
    this.version = version;
    this.triangles = parseReferenceByValTyped(reader, indexEntries, readUint16Array);
    this.regions = parseReference(reader, indexEntries, Region);
    this.batches = parseReference(reader, indexEntries, Batch);
    this.MSEC = parseReference(reader, indexEntries, MSEC);
    this.unknown0 = readUint32(reader);
  }
  
  function Bone(reader, indexEntries, version) {
    this.version = version;
    this.unknown0 = readInt32(reader);
    this.name = parseReferenceString(reader, indexEntries);
    this.flags = readUint32(reader); // 0x1 inheritTranslation
                                              // 0x2 inheritScale
                                              // 0x4 inheritRotation
                                              // 0x10 billboard1
                                              // 0x40 billboard2
                                              // 0x100 twoDProjection
                                              // 0x200 animated
                                              // 0x400 inverseKinematics
                                              // 0x800 skinned
                                              // 0x2000 real -- what does this mean?
    // Note: 1 is added here to allow the parser to inject a root node.
    this.parent = readInt16(reader) + 1;
    this.unknown1 = readUint16(reader);
    this.location = new AnimationReference(reader, readVector3);
    this.rotation = new AnimationReference(reader, readVector4);
    this.scale = new AnimationReference(reader, readVector3);
    this.visibility = new AnimationReference(reader, readUint32);
  }
  
  function STS(reader, indexEntries, version) {
    this.version = version;
    this.animIds = parseReferenceByValTyped(reader, indexEntries, readUint32Array);
    this.unknown0 = readInt32(reader);
    this.unknown1 = readInt32(reader);
    this.unknown2 = readInt32(reader);
    this.unknown3 = readInt16(reader);
    this.unknown4 = readUint16(reader);
  }
  
  function STG(reader, indexEntries, version) {
    this.version = version;
    this.name = parseReferenceString(reader, indexEntries);
    this.stcIndices = parseReferenceByValTyped(reader, indexEntries, readUint32Array);
  }
  
  function STC(reader, indexEntries, version) {
    this.version = version;
    this.name = parseReferenceString(reader, indexEntries);
    this.runsConcurrent = readUint16(reader);
    this.priority = readUint16(reader);
    this.stsIndex = readUint16(reader);
    this.stsIndexCopy = readUint16(reader);
    this.animIds = parseReferenceByValTyped(reader, indexEntries, readUint32Array);
    this.animRefs = parseReferenceByVal(reader, indexEntries, readUint16Pair);
    this.unknown0 = readUint32(reader);
    this.sd = [
      parseSeqeunceData(reader, indexEntries, readEvent),
      parseSeqeunceData(reader, indexEntries, readVector2),
      parseSeqeunceData(reader, indexEntries, readVector3),
      parseSeqeunceData(reader, indexEntries, readVector4),
      parseSeqeunceData(reader, indexEntries, readColor),
      parseSeqeunceData(reader, indexEntries, readFloat32),
      new Reference(reader),
      parseSeqeunceData(reader, indexEntries, readInt16),
      parseSeqeunceData(reader, indexEntries, readUint16),
      new Reference(reader),
      new Reference(reader),
      parseSeqeunceData(reader, indexEntries, readUint32),
      parseSeqeunceData(reader, indexEntries, readBoundingSphere)
    ];
  }
  
  function Sequence(reader, indexEntries, version) {
    this.version = version;
    this.unknown0 = readInt32(reader);
    this.unknown1 = readInt32(reader);
    this.name = parseReferenceString(reader, indexEntries);
    this.animationStart = readUint32(reader);
    this.animationEnd = readUint32(reader);
    this.movementSpeed = readFloat32(reader);
    this.flags = readUint32(reader); // 0x1 notLooping
                                              // 0x2 alwaysGlobal
                                              // 0x8 globalInPreviewer
    this.frequency = readUint32(reader);
    this.unknown2 = readUint32(reader);
    this.unknown3 = readUint32(reader);
    this.unknown4 = readUint32(reader);
    
    if (version &lt; 2) {
      this.unknown5 = readUint32(reader);
    }
    
    this.boundingSphere = readBoundingSphere(reader);
    this.unknown6 = readUint32(reader);
    this.unknown7 = readUint32(reader);
    this.unknown8 = readUint32(reader);
  }
  
  function ModelHeader(reader, indexEntries, version) {
    this.version = version;
    this.name = parseReferenceString(reader, indexEntries);
    this.flags = readUint32(reader); // 0x100000 hasMesh
    this.sequences = parseReference(reader, indexEntries, Sequence);
    this.stc = parseReference(reader, indexEntries, STC);
    this.stg = parseReference(reader, indexEntries, STG);
    this.unknown0 = readFloat32(reader);
    this.unknown1 = readFloat32(reader);
    this.unknown2 = readFloat32(reader);
    this.unknown3 = readFloat32(reader);
    this.sts = parseReference(reader, indexEntries, STS);
    this.bones = parseReference(reader, indexEntries, Bone);
    this.skinBones = readUint32(reader);
    
    var vertexFlags = readUint32(reader);
    var uvSetCount = 1;
    
    if (vertexFlags &amp; 0x40000) {
      uvSetCount = 2;
    } else if (vertexFlags &amp; 0x80000) {
      uvSetCount = 3;
    } else if (vertexFlags &amp; 0x100000) {
      uvSetCount = 4;
    }
    
    this.vertexFlags = vertexFlags;
    this.uvSetCount = uvSetCount;
    this.vertices = parseVertices(reader, indexEntries, uvSetCount);
    this.divisions = parseReference(reader, indexEntries, Division);
    this.boneLookup = parseReferenceByValTyped(reader, indexEntries, readUint16Array);
    this.boundings = readBoundingSphere(reader);
    this.unknown4To19 = readFloat32Array(reader, 16);
    this.attachmentPoints = parseReference(reader, indexEntries, AttachmentPoint);
    this.attachmentPointAddons = new Reference(reader);//parseReferenceByVal(reader, indexEntries, readUint16);
    this.ligts = parseReference(reader, indexEntries, Light);
    this.shbx = new Reference(reader);//parseReference(reader, indexEntries, SHBX);
    this.cameras = parseReference(reader, indexEntries, Camera);
    this.unknown20 = new Reference(reader);//parseReferenceByVal(reader, indexEntries, readUint16);
    this.materialMaps = parseReference(reader, indexEntries, MaterialMap);
    this.materials = [
      parseReference(reader, indexEntries, StandardMaterial),
      parseReference(reader, indexEntries, DisplacementMaterial),
      parseReference(reader, indexEntries, CompositeMaterial),
      parseReference(reader, indexEntries, TerrainMaterial),
      parseReference(reader, indexEntries, VolumeMaterial),
      parseReference(reader, indexEntries, VolumeNoiseMaterial),
      parseReference(reader, indexEntries, CreepMaterial)
    ];
    
    if (version > 24) {
      this.unknown21 = new Reference(reader);
    }
    
    if (version > 25) {
      this.unknown22 = new Reference(reader);
    }
    
    this.particleEmitters = new Reference(reader);//parseReference(reader, indexEntries, ParticleEmitter);
    this.particleEmitterCopies = new Reference(reader);//parseReference(reader, indexEntries, ParticleEmitterCopy);
    this.ribbonEmitters = new Reference(reader);//parseReference(reader, indexEntries, RibbonEmitter);
    this.projections = new Reference(reader);//parseReference(reader, indexEntries, Projection);
    this.forces = new Reference(reader);//parseReference(reader, indexEntries, Force);
    this.warps = new Reference(reader);//parseReference(reader, indexEntries, Warp);
    this.unknown23 = new Reference(reader);
    this.rigidBodies = new Reference(reader);//parseReference(reader, indexEntries, RigidBody);
    this.unknown24 = new Reference(reader);
    this.physicsJoints = new Reference(reader);//parseReference(reader, indexEntries, PhysicsJoint);
    this.unknown25 = new Reference(reader);
    this.ikjt = new Reference(reader);//parseReference(reader, indexEntries, IKJT);
    this.unknown26 = new Reference(reader);
    
    if (version > 24) {
      this.unknown27 = new Reference(reader);
    }
    
    this.patu = new Reference(reader);//parseReference(reader, indexEntries, PATU);
    this.trgd = new Reference(reader);//parseReference(reader, indexEntries, TRGD);
    this.initialReference = parseReferenceByVal(reader, indexEntries, readMatrix);
    this.tightHitTest = new BoundingShape(reader);
    this.fuzzyHitTestObjects = parseReference(reader, indexEntries, BoundingShape);
    this.attachmentVolumes = new Reference(reader);//parseReference(reader, indexEntries, AttachmentVolume);
    this.attachmentVolumesAddon0 = new Reference(reader);//parseReferenceByVal(reader, indexEntries, readUint16);
    this.attachmentVolumesAddon1 = new Reference(reader);//parseReferenceByVal(reader, indexEntries, readUint16);
    this.bbsc = new Reference(reader);//parseReference(reader, indexEntries, BBSC);
    this.tmd = new Reference(reader);//parseReference(reader, indexEntries, TMD);
    this.unknown28 = readUint32(reader);
    this.unknown29 = new Reference(reader);//parseReferenceByVal(reader, indexEntries, readUint32);
  }
  
  function Reference(reader) {
    this.entries = readUint32(reader);
    this.index = readUint32(reader);
    this.flags = readUint32(reader);
  }
  
  function IndexEntry(reader) {
    this.tag = readUint32(reader);
    this.offset = readUint32(reader);
    this.entries = readUint32(reader);
    this.version = readUint32(reader);
  }
  
  function MD34(reader) {
    this.indexOffset = readUint32(reader);
    this.entries = readUint32(reader);
    this.modelHeader = new Reference(reader);
  }

  return (function (reader, onprogress) {
    if (readUint32(reader) === MD34_HEADER) {
      var header = new MD34(reader)
      
      seek(reader, header.indexOffset);
      
      var indexEntries = [];
      
      for (var i = 0; i &lt; header.entries; i++) {
        indexEntries[i] = new IndexEntry(reader);
      }
      
      var modelHeader = indexEntries[header.modelHeader.index];
      
      seek(reader, modelHeader.offset);
      
      var parser = new ModelHeader(reader, indexEntries, modelHeader.version);
      
      parser.bones.unshift({name: "InjectedRoot", parent: -1});
      
      return parser;
    }
  });
}());

function SD(sd) {
  this.sd = sd;
  
  // Avoid heap allocations in getInterval()
  this.interval = [0, 0];
}

SD.prototype = {
  getValue: function (out, index, animationReference, frame, runsConcurrent) {
    var sd = this.sd[index];
    
    if (runsConcurrent === 1) {
      frame = frame % sd.biggestKey;
    }
    
    var interval = this.interval;
    var keys = sd.keys;
    var values = sd.values;
    
    this.getInterval(keys, frame, interval);
    
    var a = interval[0];
    var b = interval[1];
    var length = keys.length;
    
    if (a === length) {
      if (b === length) {
        return animationReference.initValue;
      } else {
        return values[b];
      }
    }
    
    if (b === length || a >= b) {
      return values[a];
    }
    
    var t = math.clamp((frame - keys[a]) / (keys[b] - keys[a]), 0, 1);
    
    // M3 doesn't seem to have hermite/bezier interpolations, so just feed 0 to the in/out tangents since they are not used anyway
    return interpolator(out, values[a], 0, 0, values[b], t, animationReference.interpolationType);
  },
  
  getInterval: function (keys, frame, interval) {
    var a = keys.length;
    var b = 0;
    
    while (b !== keys.length &amp;&amp; frame > keys[b]) {
      a = b;
      b++;
    }
    
    interval[0] = a;
    interval[1] = b;
  }
};

function STS(sts) {
  var i, l;
  var animIds = sts.animIds;
  
  this.animIds = {};
    
  // Allows direct checks instead of loops
  for (i = 0, l = animIds.length; i &lt; l; i++) {
    this.animIds[animIds[i]] = i;
  }
}

STS.prototype = {
  hasData: function (animationReference) {
    return !!this.animIds[animationReference.animId];
  }
};

function STC(stc) {
  var i, l;
  var animIds = stc.animIds;
  
  this.name = stc.name;
  this.runsConcurrent = stc.runsConcurrent;
  this.priority = stc.priority;
  this.stsIndex = stc.stsIndex;
  this.animIds = {};
  
  // Allows direct checks instead of loops
  for (i = 0, l = animIds.length; i &lt; l; i++) {
    this.animIds[animIds[i]] = i;
  }
  
  this.animRefs = stc.animRefs;
  
  var sd = stc.sd;
  
  this.sd = [
    new SD(sd[0]),
    new SD(sd[1]),
    new SD(sd[2]),
    new SD(sd[3]),
    new SD(sd[4]),
    new SD(sd[5]),
    1, // Unknown SD
    new SD(sd[7]),
    new SD(sd[8]),
    1, // Unknown SD
    1, // Unknown SD,
    new SD(sd[11]),
    new SD(sd[12])
  ];
}

STC.prototype = {
  getValue: function (out, animationReference, frame) {
    var animRef = this.animRefs[this.animIds[animationReference.animId]];
    
    if (animRef) {
      return this.sd[animRef[1]].getValue(out, animRef[0], animationReference, frame, this.runsConcurrent);
    }
    
    return animationReference.initValue;
  }
};

function STG(stg, sts, stc) {
  this.name = stg.name;
  this.stcIndices = stg.stcIndices;
  this.sts = sts;
  this.stc = stc;
}

STG.prototype = {
  getValue: function (out, animationReference, frame) {
    var i, l;
    var stcIndices = this.stcIndices;
    var stc;
    var sts;
    
    for (i = 0, l = stcIndices.length; i &lt; l; i++) {
      stc = this.stc[stcIndices[i]];
      sts = this.sts[stc.stsIndex];
      
       // First check if this STC actually has data for this animation reference
        if (sts.hasData(animationReference)) {
          // Since this STC has data for this animation reference, return it
          return stc.getValue(out, animationReference, frame);
        }
    }
    
    // No STC referenced by the STG had data for this animation reference
    return animationReference.initValue;
  }
};

function ShallowBone (bone) {
  this.boneImpl = bone;
  this.parent = bone.parent;
  this.worldMatrix = mat4.create();
  this.scale = vec3.create();
  this.inverseScale = vec3.create();
  this.externalWorldMatrix = mat4.create();
}

ShallowBone.prototype = {
  getTransformation: function () {
    var m = this.externalWorldMatrix;
    
    mat4.copy(m, this.worldMatrix);
    // Remove the local rotation as far as external objects know
    mat4.rotateZ(m, m, -Math.PI / 2);
    
    return m;
  }
};

function Skeleton(model) {
  var i, l;
  var bones = model.bones;
  var boneLookup = model.boneLookup;
  
  this.initialReference = model.initialReference;
  this.sts = model.sts;
  this.stc = model.stc;
  this.stg = model.stg;
  this.bones = [];
  
  this.boneLookup = boneLookup;
  this.hwbones = new Float32Array(16 * boneLookup.length);
  this.boneTexture = ctx.createTexture();
  this.boneTextureSize = Math.max(2, math.powerOfTwo(boneLookup.length + 1)) * 4;
  this.texelFraction = 1 / this.boneTextureSize;
  this.matrixFraction = this.texelFraction * 4;
  
  ctx.activeTexture(ctx.TEXTURE15);
  ctx.bindTexture(ctx.TEXTURE_2D, this.boneTexture);
  ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, this.boneTextureSize, 1, 0, ctx.RGBA, ctx.FLOAT, null);
  ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
  ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
  
  for (i = 0, l = bones.length; i &lt; l; i++) {
    this.bones[i] = new ShallowBone(bones[i]);
  }
  
  this.localMatrix = mat4.create();
  this.rotationMatrix = mat4.create();
  
  this.locationVec = vec3.create();
  this.scaleVec = vec3.create();
  this.rotationQuat = quat.create();
  
  this.rootScaler = vec3.fromValues(100, 100, 100);
}

Skeleton.prototype = {
  // NOTE: This function assumes that the bones are sorted in such way that a child would always be after its parent. Is this true?
  update: function (sequence, frame, worldMatrix) {
    var root = this.bones[0];
    
    mat4.copy(root.worldMatrix, worldMatrix);
    
    // Transform the skeleton to approximately match the size of Warcraft 3 models, and to have the same rotation
    mat4.scale(root.worldMatrix, root.worldMatrix, this.rootScaler);
    mat4.rotateZ(root.worldMatrix, root.worldMatrix, Math.PI / 2);
    
    mat4.decomposeScale(root.scale, root.worldMatrix);
    vec3.inverse(root.inverseScale, root.scale);
    
    for (var i = 1, l = this.bones.length; i &lt; l; i++) {
      this.updateBone(this.bones[i], sequence, frame);
    }
    
    this.updateBoneTexture(sequence);
  },
  
  getValue: function (out, animRef, sequence, frame) {
    if (sequence !== -1) {
      return this.stg[sequence].getValue(out, animRef, frame)
    }
    
    return animRef.initValue;
  },
  
  updateBone: function (bone, sequence, frame) {
    var localMatrix = this.localMatrix;
    var rotationMatrix = this.rotationMatrix;
    var location = this.getValue(this.locationVec, bone.boneImpl.location, sequence, frame);
    var rotation = this.getValue(this.rotationQuat, bone.boneImpl.rotation, sequence, frame);
    var scale = this.getValue(this.scaleVec, bone.boneImpl.scale, sequence, frame);
    
    mat4.fromRotationTranslationScale(localMatrix, rotation, location, scale);
    mat4.multiply(bone.worldMatrix, this.bones[bone.parent].worldMatrix, localMatrix);
    
    mat4.decomposeScale(bone.scale, bone.worldMatrix);
    vec3.inverse(bone.inverseScale, bone.scale);
  },
  
  updateBoneTexture: function (sequence) {
    var bones = this.bones;
    var hwbones = this.hwbones;
    var initialReferences = this.initialReference;
    var boneLookup = this.boneLookup;
    var bone;
    var finalMatrix;
    
    if (sequence === -1) {
      finalMatrix = this.bones[0].worldMatrix;
    } else {
      finalMatrix = this.localMatrix;
    }
    
    for (var i = 0, l = boneLookup.length; i &lt; l; i++) {
      if (sequence !== -1) {
        bone = boneLookup[i];
        // 1 added to account for the injected root
        mat4.multiply(finalMatrix, bones[bone + 1].worldMatrix, initialReferences[bone]);
      } 
      
      hwbones.set(finalMatrix, i * 16);
    }
  
    ctx.activeTexture(ctx.TEXTURE15);
    ctx.bindTexture(ctx.TEXTURE_2D, this.boneTexture);
    ctx.texSubImage2D(ctx.TEXTURE_2D, 0, 0, 0, boneLookup.length * 4, 1, ctx.RGBA, ctx.FLOAT, hwbones);
  },
  
  bind: function (shader) {
    ctx.activeTexture(ctx.TEXTURE15);
    ctx.bindTexture(ctx.TEXTURE_2D, this.boneTexture);
    
    ctx.uniform1i(shader.variables.u_boneMap, 15);
    ctx.uniform1f(shader.variables.u_matrix_size, this.matrixFraction);
    ctx.uniform1f(shader.variables.u_texel_size, this.texelFraction);
  }
};

function BoundingShape(boundingshape, bones) {
  this.bone = boundingshape.bone;
  this.matrix = boundingshape.matrix;
  this.name = bones[boundingshape.bone].name;
  
  var size = boundingshape.size;
  var shape;
  
  if (boundingshape.shape === 0) {
    shape = gl.createCube(-size[0], -size[1], -size[2], size[0], size[1], size[2]);
  } else if (boundingshape.shape === 1) {
    shape = gl.createSphere(0, 0, 0, 9, 9, size[0]);
  } else {
    shape = gl.createCylinder(0, 0, 0, size[0], size[1], 9);
  }
  
  this.shape = shape;
}

BoundingShape.prototype = {
  render: function (shader, bones) {
    if (this.shape) {
      gl.pushMatrix();
        
      gl.multMat(bones[this.bone].worldMatrix);
      gl.multMat(this.matrix);
      
      ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
      
      gl.popMatrix();
      
      this.shape.renderLines(shader);
    }
  }
};

function Region(region, triangles, elementArray, edgeArray, offset) {
  var i, j, k;
  var firstVertexIndex = region.firstVertexIndex;
  var triangleIndicesCount = region.triangleIndicesCount;
  var firstTriangleIndex = region.firstTriangleIndex;
  
  // Note for implementors: the one original vertex indices array could be used with access to the base-vertex draw elements function.
  // See https://www.opengl.org/sdk/docs/man3/xhtml/glDrawElementsBaseVertex.xml
  // firstTriangleIndex is the indices offset.
  // firstVertexIndex is the base vertex.
  for (i = 0; i &lt; triangleIndicesCount; i++) {
    elementArray[offset + i] = triangles[firstTriangleIndex + i] + firstVertexIndex;
  }
  
  for (i = 0, k = 0; i &lt; triangleIndicesCount; i += 3, k += 6) {
    edgeArray[offset * 2 + k + 0] = triangles[firstTriangleIndex + i + 0] + firstVertexIndex;
    edgeArray[offset * 2 + k + 1] = triangles[firstTriangleIndex + i + 1] + firstVertexIndex;
    edgeArray[offset * 2 + k + 2] = triangles[firstTriangleIndex + i + 1] + firstVertexIndex;
    edgeArray[offset * 2 + k + 3] = triangles[firstTriangleIndex + i + 2] + firstVertexIndex;
    edgeArray[offset * 2 + k + 4] = triangles[firstTriangleIndex + i + 2] + firstVertexIndex;
    edgeArray[offset * 2 + k + 5] = triangles[firstTriangleIndex + i + 0] + firstVertexIndex;
  }
  
  this.firstBoneLookupIndex = region.firstBoneLookupIndex;
  this.offset = offset * 2;
  this.elements = triangleIndicesCount;
}

Region.prototype = {
  render: function (shader, polygonMode) {
    ctx.uniform1f(shader.variables.u_firstBoneLookupIndex, this.firstBoneLookupIndex);
    
    if (polygonMode) {
      ctx.drawElements(ctx.TRIANGLES, this.elements, ctx.UNSIGNED_SHORT, this.offset);
    } else {
      ctx.drawElements(ctx.LINES, this.elements * 2, ctx.UNSIGNED_SHORT, this.offset * 2);
    }
  },
  
  renderColor: function (shader) {
    ctx.uniform1f(shader.variables.u_firstBoneLookupIndex, this.firstBoneLookupIndex);
    
    ctx.drawElements(ctx.TRIANGLES, this.elements, ctx.UNSIGNED_SHORT, this.offset);
  }
};

function Layer(layer, type, op, model, textureMap) {
  this.active = false;
  
  // Since Gloss doesn't exist in all versions
  if (layer) {
    var uvSource = layer.uvSource;
    var flags = layer.flags;
    
    this.flags = flags;
    this.colorChannels = layer.colorChannels;
    
    this.model = model;
    this.type = type;
    this.op = op;
    
    var uvCoordinate = 0;
    
    if (uvSource === 1) {
      uvCoordinate = 1;
    } else if (uvSource === 9) {
      uvCoordinate = 2;
    } else if (uvSource === 10) {
      uvCoordinate = 3;
    }
    
    this.uvCoordinate = uvCoordinate;
    
    var uniform = "u_" + type;
    
    var settings = uniform + "LayerSettings.";
    
    this.uniforms = {
      map: uniform + "Map",
      enabled: settings + "enabled",
      op: settings + "op",
      channels: settings + "channels",
      teamColorMode: settings + "teamColorMode",
      invert: settings + "invert",
      clampResult: settings + "clampResult",
      uvCoordinate: settings + "uvCoordinate"
    };
    
    this.invert = flags &amp; 0x10;
    this.clampResult = flags &amp; 0x20;
    
    // I am not sure if the emissive team color mode is even used, since so far combineColors takes care of it.
    this.teamColorMode = (type === "diffuse") &amp; 1;
      
    // The path is overrided with the lower case because some models have the same texture multiple times but with different letter cases, which causes multiple fetches = wasted bandwidth, memory and time.
    var source = layer.imagePath.toLowerCase();
    
    if (source !== "") {
      this.source = source;
      
      var path;
      var fileName = getFileName(source);
      
      if (textureMap[fileName]) {
        path = textureMap[fileName];
      } else {
        path = urls.mpqFile(source);
      }
      
      model.textureMap[source] = path;
      
      gl.loadTexture(path, {clampS: !(flags &amp; 0x4), clampT: !(flags &amp; 0x8)});
      
      this.active = true;
    }
  }
}

Layer.prototype = {
  bind: function (unit, sequence, frame, textureMap, shader) {
    var variables = shader.variables;
    var uniforms = this.uniforms;
    
    if (this.active) {
      ctx.uniform1i(variables[uniforms.map], unit);
      bindTexture(this.source, unit, this.model.textureMap, textureMap);
      
      ctx.uniform1f(variables[uniforms.enabled], 1);
      ctx.uniform1f(variables[uniforms.op], this.op);
      ctx.uniform1f(variables[uniforms.channels], this.colorChannels);
      ctx.uniform1f(variables[uniforms.teamColorMode], this.teamColorMode);
      
      // Alpha is probably unknown12. Can this be confirmed?
      // Many of these flags seem to be incorrect
      //gl.setParameter(uniform + "multAddAlpha", [this.model.getValue(this.rgbMultiply, sequence, frame), this.model.getValue(this.rgbAdd, sequence, frame), 0]);
      //gl.setParameter(uniform + "useAlphaFactor", 0);
      
      ctx.uniform1f(variables[uniforms.invert], this.invert);
      
      //gl.setParameter(uniform + "multColor", 0);
      //gl.setParameter(uniform + "addColor", 0);
      
      ctx.uniform1f(variables[uniforms.clampResult], this.clampResult);
      
      //gl.setParameter(uniform + "useConstantColor", this.flags &amp;&amp; 0x400);
      //gl.setParameter(uniform + "constantColor", this.model.getValue(this.color, sequence, frame));
      //gl.setParameter(settings + "uvSource", this.uvSource);
      
      ctx.uniform1f(variables[uniforms.uvCoordinate], this.uvCoordinate);
    } else {
      ctx.uniform1f(variables[uniforms.enabled], 0);
    }
  },
  
  unbind: function (shader) {
    if (this.active) {
      ctx.uniform1f(shader.variables[this.uniforms.enabled], 0);
    }
  }
};

function StandardMaterial(material, model, textureMap) {
  this.name = material.name;
  this.specialFlags = material.specialFlags;
  this.flags = material.flags;
  this.blendMode = material.blendMode;
  this.priority = material.priority;
  this.specularity = material.specularity;
  this.specMult = material.specMult;
  this.emisMult = material.emisMult;
  this.layerBlendType = material.layerBlendType;
  this.emisBlendType = material.emisBlendType;
  this.emisMode = material.emisMode;
  
  this.layers = [
    new Layer(material.diffuseLayer, "diffuse", 2, model, textureMap),
    new Layer(material.decalLayer, "decal", 2, model, textureMap),
    new Layer(material.specularLayer, "specular", 2, model, textureMap),
    new Layer(material.glossLayer, "gloss", 2, model, textureMap),
    new Layer(material.emissiveLayer, "emissive", material.emisBlendType, model, textureMap),
    new Layer(material.emissive2Layer, "emissive2", material.emisMode, model, textureMap),
    new Layer(material.evioLayer, "evio", 2, model, textureMap),
    new Layer(material.evioMaskLayer, "evioMask", 2, model, textureMap),
    new Layer(material.alphaMaskLayer, "alphaMask", 2, model, textureMap),
    new Layer(material.alphaMask2Layer, "alphaMask2", 2, model, textureMap),
    new Layer(material.normalLayer, "normal", 2, model, textureMap),
    new Layer(material.heightLayer, "heightMap", 2, model, textureMap),
    new Layer(material.lightMapLayer, "lightMap", 2, model, textureMap),
    new Layer(material.ambientOcclusionLayer, "ao", 2, model, textureMap)
  ];
}

StandardMaterial.prototype = {
  bindCommon: function () {
     if (this.blendMode === 1) {
      ctx.enable(ctx.BLEND);
      ctx.blendFunc(ctx.ONE, ctx.ONE);
    } else if (this.blendMode === 2) {
      ctx.enable(ctx.BLEND);
      ctx.blendFunc(ctx.ONE, ctx.ONE);
    } else {
      ctx.disable(ctx.BLEND);
    }
      
    if (this.flags &amp; 0x8) {
      ctx.disable(ctx.CULL_FACE);
    } else {
      ctx.enable(ctx.CULL_FACE);
    }
  },
  
  bind: function (sequence, frame, textureMap, shader) {
    this.bindCommon();
    
    ctx.uniform1f(shader.variables.u_specularity, this.specularity);
    ctx.uniform1f(shader.variables.u_specMult, this.specMult);
    ctx.uniform1f(shader.variables.u_emisMult, this.emisMult);
    ctx.uniform4fv(shader.variables.u_lightAmbient, [0.02, 0.02, 0.02, 0]);
    
    var layers = this.layers;
    
    layers[0].bind(1, sequence, frame, textureMap, shader);
    layers[1].bind(2, sequence, frame, textureMap, shader);
    layers[2].bind(3, sequence, frame, textureMap, shader);
    layers[4].bind(5, sequence, frame, textureMap, shader);
    layers[5].bind(6, sequence, frame, textureMap, shader);
    layers[10].bind(11, sequence, frame, textureMap, shader);
    layers[12].bind(13, sequence, frame, textureMap, shader);
  },
  
  unbind: function (shader) {
    ctx.disable(ctx.BLEND);
    ctx.enable(ctx.CULL_FACE);
    
    var layers = this.layers;
    
    layers[0].unbind(shader);
    layers[1].unbind(shader);
    layers[2].unbind(shader);
    layers[4].unbind(shader);
    layers[5].unbind(shader);
    layers[10].unbind(shader);
    layers[12].unbind(shader);
  },
  
  bindDiffuse: function (sequence, frame, textureMap, shader) {
    this.bindCommon();
    
    this.layers[0].bind(1, sequence, frame, textureMap, shader);
  },
  
  bindSpecular: function (sequence, frame, textureMap, shader) {
    this.bindCommon();
    
    ctx.uniform1f(shader.variables.u_specularity, this.specularity);
    ctx.uniform1f(shader.variables.u_specMult, this.specMult);
    
    this.layers[2].bind(3, sequence, frame, textureMap, shader);
  },
  
  bindNormalMap: function (sequence, frame, textureMap, shader) {
    this.bindCommon();
    
    this.layers[10].bind(11, sequence, frame, textureMap, shader);
  },
  
  bindEmissive: function (sequence, frame, textureMap, shader) {
    this.bindCommon();
    
    ctx.uniform1f(shader.variables.u_emisMult, this.emisMult);
    
    this.layers[4].bind(5, sequence, frame, textureMap, shader);
    this.layers[5].bind(6, sequence, frame, textureMap, shader);
  },
  
  bindDecal: function (sequence, frame, textureMap, shader) {
    this.bindCommon();
    
    this.layers[1].bind(2, sequence, frame, textureMap, shader);
  }
};

function Model(arrayBuffer, textureMap, context, onerror) {
  BaseModel.call(this, textureMap);
  
  var parser = Parser(new BinaryReader(arrayBuffer));
  
  if (DEBUG_MODE) {
    console.log(parser);
  }
        
  if (parser) {
    this.setup(parser);
    this.setupShaders(parser);
  }
  
  if (DEBUG_MODE) {
    console.log(this);
  }
}

var prototype = Object.create(BaseModel.prototype);
Model.prototype = prototype;

prototype.setup = function (parser) {
  var i, l;
  var material;
  var div = parser.divisions[0];
  
  this.name = getFileName(parser.name);
  
  this.setupGeometry(parser, div);
  
  this.batches = [];
  this.materials = [[], []]; // 2D array for the possibility of adding more material types in the future
  this.materialMaps = parser.materialMaps;

  var materialMaps = parser.materialMaps;
  var materials = parser.materials;
  var batches = [];
  
  // Create concrete material objects for standard materials
  for (i = 0, l = materials[0].length; i &lt; l; i++) {
    material = materials[0][i];
    
    this.materials[1][i] = new StandardMaterial(material, this, this.textureMap);
  }
  
  // Create concrete batch objects
  for (i = 0, l = div.batches.length; i &lt; l; i++) {
    var batch = div.batches[i];
    var regionId = batch.regionIndex;
    var materialMap = materialMaps[batch.materialReferenceIndex];
    
    if (materialMap.materialType === 1) {
      batches.push({regionId: regionId, region: this.meshes[regionId], material: this.materials[1][materialMap.materialIndex]});
    }
  }

/*
  var batchGroups = [[], [], [], [], [], []];
  
  for (i = 0, l = batches.length; i &lt; l; i++) {
    var blendMode = batches[i].material.blendMode;
    
    batchGroups[blendMode].push(batches[i]);
  }
  
  function sortByPriority(a, b) {
    var a = a.material.priority;
    var b = b.material.priority;
    
    if (a &lt; b) {
      return 1;
    } else if (a == b) {
      return 0;
    } else {
      return -1;
    }
  }
  
  for (i = 0; i &lt; 6; i++) {
    batchGroups[i].sort(sortByPriority);
  }
*/
  /*
  // In the EggPortrait model the batches seem to be sorted by blend mode. Is this true for every model?
  this.batches.sort(function (a, b) {
    var ba = a.material.blendMode;
    var bb = b.material.blendMode;
    
    if (ba &lt; bb) {
      return -1;
    } else if (ba == bb) {
      return 0;
    } else {
      return 1;
    }
  });
  */
  
  //this.batches = batchGroups[0].concat(batchGroups[1]).concat(batchGroups[2]).concat(batchGroups[3]).concat(batchGroups[4]).concat(batchGroups[5]);
  this.batches = batches;
  
  var sts = parser.sts;
  var stc = parser.stc;
  var stg = parser.stg;
  
  this.initialReference = parser.initialReference;
  this.bones = parser.bones;
  this.boneLookup = parser.boneLookup;
  this.sequences = parser.sequences;
  this.sts = [];
  this.stc = [];
  this.stg = [];
  
  for (i = 0, l = sts.length; i &lt; l; i++) {
    this.sts[i] = new STS(sts[i]);
  }
  
  for (i = 0, l = stc.length; i &lt; l; i++) {
    this.stc[i] = new STC(stc[i]);
  }
  
  for (i = 0, l = stg.length; i &lt; l; i++) {
    this.stg[i] = new STG(stg[i], this.sts, this.stc);
  }
  
  this.addGlobalAnims();
  
  if (parser.fuzzyHitTestObjects.length > 0) {
    for (i = 0, l = parser.fuzzyHitTestObjects.length; i &lt; l; i++) {
      this.boundingShapes[i] = new BoundingShape(parser.fuzzyHitTestObjects[i], parser.bones);
    }
  }
  /*
  if (parser.particleEmitters.length > 0) {
    this.particleEmitters = [];
    
    for (i = 0, l = parser.particleEmitters.length; i &lt; l; i++) {
      this.particleEmitters[i] = new ParticleEmitter(parser.particleEmitters[i], this);
    }
  }
  */
 
  this.attachments = parser.attachmentPoints;
  this.cameras = parser.cameras;
    
  this.ready = true;
};

prototype.setupShaders = function (parser) {
  // Shader setup
  var uvSetCount = this.uvSetCount;
  var uvSets = "EXPLICITUV" + (uvSetCount - 1);
  var vscommon = SHADERS.vsbonetexture + SHADERS.svscommon + "\n";
  var vsstandard = vscommon + SHADERS.svsstandard;
  var pscommon = SHADERS.spscommon + "\n";
  var psstandard = pscommon + SHADERS.spsstandard;
  var psspecialized = pscommon + SHADERS.spsspecialized;
  var NORMALS_PASS = "NORMALS_PASS";
  var HIGHRES_NORMALS = "HIGHRES_NORMALS";
  var SPECULAR_PASS = "SPECULAR_PASS";
  var UNSHADED_PASS = "UNSHADED_PASS";
  
  // Load all the M3 shaders.
  // All of them are based on the uv sets of this specific model.
  if (!gl.shaderStatus("sstandard" + uvSetCount)) {
    gl.createShader("sstandard" + uvSetCount, vsstandard, psstandard, [uvSets]);
  }
  
  if (!gl.shaderStatus("sdiffuse" + uvSetCount)) {
    gl.createShader("sdiffuse" + uvSetCount, vsstandard, psspecialized, [uvSets, "DIFFUSE_PASS"]);
  }
  
  if (!gl.shaderStatus("snormals" + uvSetCount)) {
    gl.createShader("snormals" + uvSetCount, vsstandard, psspecialized, [uvSets, NORMALS_PASS]);
  }
  
  if (!gl.shaderStatus("suvs" + uvSetCount)) {
    gl.createShader("suvs" + uvSetCount, vsstandard, psspecialized, [uvSets, "UV_PASS"]);
  }
  
  if (!gl.shaderStatus("snormalmap" + uvSetCount)) {
    gl.createShader("snormalmap" + uvSetCount, vsstandard, psspecialized, [uvSets, NORMALS_PASS, HIGHRES_NORMALS]);
  }
  
  if (!gl.shaderStatus("sspecular" + uvSetCount)) {
    gl.createShader("sspecular" + uvSetCount, vsstandard, psspecialized, [uvSets, SPECULAR_PASS]);
  }
  
  if (!gl.shaderStatus("sspecular_normalmap" + uvSetCount)) {
    gl.createShader("sspecular_normalmap" + uvSetCount, vsstandard, psspecialized, [uvSets, SPECULAR_PASS, HIGHRES_NORMALS]);
  }
  
  if (!gl.shaderStatus("semissive" + uvSetCount)) {
    gl.createShader("semissive" + uvSetCount, vsstandard, psspecialized, [uvSets, "EMISSIVE_PASS"]);
  }
  
  if (!gl.shaderStatus("sunshaded" + uvSetCount)) {
    gl.createShader("sunshaded" + uvSetCount, vsstandard, psspecialized, [uvSets, UNSHADED_PASS]);
  }
  
  if (!gl.shaderStatus("sunshaded_normalmap" + uvSetCount)) {
    gl.createShader("sunshaded_normalmap" + uvSetCount, vsstandard, psspecialized, [uvSets, UNSHADED_PASS, HIGHRES_NORMALS]);
  }
  
  if (!gl.shaderStatus("sdecal" + uvSetCount)) {
    gl.createShader("sdecal" + uvSetCount, vsstandard, psspecialized, [uvSets, "DECAL_PASS"]);
  }
  
  if (!gl.shaderStatus("swhite" + uvSetCount)) {
    gl.createShader("swhite" + uvSetCount, vsstandard, psspecialized, [uvSets, "WHITE_PASS"]);
  }
  
  if (!gl.shaderStatus("sparticles" + uvSetCount)) {
    gl.createShader("sparticles" + uvSetCount, SHADERS.svsparticles, SHADERS.spsparticles);
  } 
  
  if (!gl.shaderStatus("scolor")) {
    gl.createShader("scolor", SHADERS.vsbonetexture + SHADERS.svscolor, SHADERS.pscolor);
  }
};

prototype.setupGeometry = function (parser, div) {
  var i, l;
  var uvSetCount = parser.uvSetCount;
  var regions = div.regions;
  var totalElements = 0;
  var offsets = [];
  
  for (i = 0, l = regions.length; i &lt; l; i++) {
    offsets[i] = totalElements;
    totalElements += regions[i].triangleIndicesCount;
  }
  
  var elementArray = new Uint16Array(totalElements);
  var edgeArray = new Uint16Array(totalElements * 2);
  
  this.meshes = [];
  
  for (i = 0, l = regions.length; i &lt; l; i++) {
    this.meshes.push(new Region(regions[i], div.triangles, elementArray, edgeArray, offsets[i]));
  }
  
  this.elementBuffer = ctx.createBuffer();
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
  ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, elementArray, ctx.STATIC_DRAW);
  
  this.edgeBuffer = ctx.createBuffer();
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.edgeBuffer);
  ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, edgeArray, ctx.STATIC_DRAW);
  
  var arrayBuffer = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, arrayBuffer);
  ctx.bufferData(ctx.ARRAY_BUFFER, parser.vertices, ctx.STATIC_DRAW);
  
  this.arrayBuffer = arrayBuffer;
  this.vertexSize = (7 + uvSetCount) * 4;
  this.uvSetCount = uvSetCount;
};

prototype.mapMaterial =function (index) {
  var materialMap = this.materialMaps[index];
  
  return this.materials[materialMap.materialType][materialMap.materialIndex];
};

prototype.addGlobalAnims = function () {
  /*
  var i, l;
  var glbirth, glstand, gldeath;
  var stgs = this.stg;
  var stg, name;
  
  for (i = 0, l = stgs.length; i &lt; l; i++) {
    stg = stgs[i];
    name = stg.name.toLowerCase(); // Because obviously there will be a wrong case in some model...
    
    if (name === "glbirth") {
      glbirth = stg;
    } else if (name === "glstand") {
      glstand = stg;
    } else if (name === "gldeath") {
      gldeath = stg;
    }
  }
  
  for (i = 0, l = stgs.length; i &lt; l; i++) {
    stg = stgs[i];
    name = stg.name.toLowerCase(); // Because obviously there will be a wrong case in some model...
    
    if (name !== "glbirth" &amp;&amp; name !== "glstand" &amp;&amp; name !== "gldeath") {
      if (name.indexOf("birth") !== -1 &amp;&amp; glbirth) {
        stg.stcIndices = stg.stcIndices.concat(glbirth.stcIndices);
      } else  if (name.indexOf("death") !== -1 &amp;&amp; gldeath) {
        stg.stcIndices = stg.stcIndices.concat(gldeath.stcIndices);
      } else if (glstand) {
        stg.stcIndices = stg.stcIndices.concat(glstand.stcIndices);
      }
    }
  }
  */
};

prototype.getValue = function (animRef, sequence, frame) {
  if (sequence !== -1) {
    return this.stg[sequence].getValue(animRef, frame)
  } else {
    return animRef.initValue;
  }
};

prototype.bind = function (shader, context) {
  var vertexSize = this.vertexSize;
  var uvSetCount = this.uvSetCount;
  var buffer = context.polygonMode ? this.elementBuffer : this.edgeBuffer;
  
  ctx.bindBuffer(ctx.ARRAY_BUFFER, this.arrayBuffer);
  
  ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, vertexSize, 0);
  ctx.vertexAttribPointer(shader.variables.a_weights, 4, ctx.UNSIGNED_BYTE, false, vertexSize, 12);
  ctx.vertexAttribPointer(shader.variables.a_bones, 4, ctx.UNSIGNED_BYTE, false, vertexSize, 16);
  ctx.vertexAttribPointer(shader.variables.a_normal, 4, ctx.UNSIGNED_BYTE, false, vertexSize, 20);
  
  for (var i = 0; i &lt; uvSetCount; i++) {
    ctx.vertexAttribPointer(shader.variables["a_uv" + i], 2, ctx.SHORT, false, vertexSize, 24 + i * 4);
  }
  
  ctx.vertexAttribPointer(shader.variables.a_tangent, 4, ctx.UNSIGNED_BYTE, false, vertexSize, 24 + uvSetCount * 4);
  
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, buffer);
};

prototype.bindColor = function (shader) {
  var vertexSize = this.vertexSize;
  
  ctx.bindBuffer(ctx.ARRAY_BUFFER, this.arrayBuffer);
  
  ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, vertexSize, 0);
  ctx.vertexAttribPointer(shader.variables.a_weights, 4, ctx.UNSIGNED_BYTE, false, vertexSize, 12);
  ctx.vertexAttribPointer(shader.variables.a_bones, 4, ctx.UNSIGNED_BYTE, false, vertexSize, 16);
  
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
};

prototype.render = function (instance, context) {
  var i, l;
  var sequence = instance.sequence;
  var frame = instance.frame;
  var tc;
  var teamId = instance.teamColor;
  var shaderName = shaders[context.shader];
  var realShaderName = "s" + shaderName + this.uvSetCount;
  // Instance-based texture overriding
  var textureMap = instance.textureMap;
  
  if (gl.shaderStatus(realShaderName)) {
    // Use a black team color if team colors are disabled
    if (!context.teamColorsMode) {
      teamId = 13;
    }
    
    var shader = gl.bindShader(realShaderName);
    
    instance.skeleton.bind(shader);
    
    ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
    ctx.uniformMatrix4fv(shader.variables.u_mv, false, gl.getViewMatrix());
    
    ctx.uniform3fv(shader.variables.u_teamColor, teamColors[teamId]);
    ctx.uniform3fv(shader.variables.u_eyePos, cameraPosition);
    ctx.uniform3fv(shader.variables.u_lightPos, lightPosition);
    
    // Bind the vertices
    this.bind(shader, context);
    
    for (i = 0, l = this.batches.length; i &lt; l; i++) {
      var batch = this.batches[i];
     
      if (instance.meshVisibilities[batch.regionId]) {
        var region = batch.region;
        var material = batch.material;
        
        if (shaderName === "standard" || shaderName === "uvs") {
          material.bind(sequence, frame, textureMap, shader);
        } else if (shaderName === "diffuse") {
          material.bindDiffuse(sequence, frame, textureMap, shader);
        } else if (shaderName === "normalmap" || shaderName === "unshaded_normalmap") {
          material.bindNormalMap(sequence, frame, textureMap, shader);
        } else if (shaderName === "specular") {
          material.bindSpecular(sequence, frame, textureMap, shader);
        } else if (shaderName === "specular_normalmap") {
          material.bindSpecular(sequence, frame, textureMap, shader);
          material.bindNormalMap(sequence, frame, textureMap, shader);
        } else if (shaderName === "emissive") {
          material.bindEmissive(sequence, frame, textureMap, shader);
        } else if (shaderName === "decal") {
          material.bindDecal(sequence, frame, textureMap, shader);
        }
        
        region.render(shader, context.polygonMode);
        
        material.unbind(shader); // This is required to not use by mistake layers from this material that were bound and are not overwritten by the next material
      }
    }
  }
  /*
  if (this.particleEmitters) {
    ctx.disable(ctx.CULL_FACE);
    
    for (i = 0, l = this.particleEmitters.length; i &lt; l; i++) {
      gl.bindShader("particles");
      
      gl.bindMVP("u_mvp");
      
      this.particleEmitters[i].render();
    }
    
    ctx.enable(ctx.CULL_FACE);
  }
*/
};

prototype.renderEmitters = function (instance, context) {
  
};

prototype.renderBoundingShapes = function (instance, context) {
  var shader,
        fuzzyHitTestObject;
  
   if (this.boundingShapes &amp;&amp; gl.shaderStatus("white")) {
    ctx.depthMask(1);
    
    shader = gl.bindShader("white");
    
    for (i = 0, l = this.boundingShapes.length; i &lt; l; i++) {
      this.boundingShapes[i].render(shader, instance.skeleton.bones);
    }
  }
};

prototype.renderColor = function (instance, color) {
  var i, l;
  var batch, region;
  
  if (gl.shaderStatus("scolor")) {
    var shader = gl.bindShader("scolor");
    
    instance.skeleton.bind(shader);
    
    ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
    ctx.uniform3fv(shader.variables.u_color, color);
    
    // Bind the vertices
    this.bindColor(shader);
    
    for (i = 0, l = this.batches.length; i &lt; l; i++) {
      batch = this.batches[i];
      
      if (instance.meshVisibilities[batch.regionId]) {
        region = batch.region;
        
        region.renderColor(shader);
      }
    }
  }
};

function ModelInstance(model, textureMap) {
  BaseModelInstance.call(this, model, textureMap);
  
  this.setup(model);
}

var prototype = Object.create(BaseModelInstance.prototype);
ModelInstance.prototype = prototype;

prototype.setup = function (model) {
  this.skeleton = new Skeleton(model);
};

prototype.update = function (worldMatrix, context) {
  var i, l;
  var sequenceId = this.sequence;
  var allowCreate = false;

  if (sequenceId !== -1) {
    var sequence = this.model.sequences[sequenceId];
    
    this.frame += context.frameTime;
    
    if (this.frame > sequence.animationEnd) {
      if ((this.sequenceLoopMode === 0 &amp;&amp; !(sequence.flags &amp; 0x1)) || this.sequenceLoopMode === 2) {
        this.frame = 0;
      }
    }
  
    allowCreate = true;
  }
  
  this.skeleton.update(sequenceId, this.frame, worldMatrix);
  
  /*
  if (this.particleEmitters) {
    for (i = 0, l = this.particleEmitters.length; i &lt; l; i++) {
      this.particleEmitters[i].update(allowCreate, sequenceId, this.frame);
    }
  }
  */
};

prototype.setSequence = function (sequence) {
  this.sequence = sequence;
  this.frame = 0;
};

prototype.setTeamColor = function (id) {
  this.teamColor = id;
};

prototype.getAttachment = function (id) {
  var attachment = this.model.getAttachment(id);
  
  if (attachment) {
    return this.skeleton.bones[attachment.bone];
  } else {
    return this.skeleton.root;
  }
};

  return {
    Parser: Parser,
    Model: Model,
    ModelInstance: ModelInstance
  };
}());

/**
 * Creates a new AsyncModel.
 *
 * @class The parent of {@link BaseModel}. Takes care of all the asynchronous aspects of loading models.
 * @name AsyncModel
 * @mixes Async
 * @param {string} source The source url that this model will be loaded from.
 * @param {number} id The id of this model.
 * @param {object} textureMap An object with texture path -> absolute urls mapping.
 */
function AsyncModel(source, id, textureMap) {
  this.ready = false;
  this.fileType = getFileExtension(source).toLowerCase();
  this.isModel = true;
  this.id = id;
  this.source = source;
  
  // All the instances owned by this model
  this.instances = [];
  
  this.setupAsync();
  
  getFile(source, !!AsyncModel.handlers[this.fileType][1], this.setup.bind(this, textureMap || {}), onerror.bind(undefined, this), onprogress.bind(undefined, this));
}

AsyncModel.handlers = {
  "mdx": [Mdx.Model, 1],
  "m3": [M3.Model, 1]
};

AsyncModel.prototype = {
  /**
    * Setup a model once it finishes loading.
    *
    * @memberof AsyncModel
    * @instance
    * @param {object} textureMap An object with texture path -> absolute urls mapping.
    * @param {XMLHttpRequestProgressEvent} e The XHR event.
    */
  setup: function (textureMap, e) {
    var status = e.target.status;
    console.log(e);
    if (status === 200) {
      var model = new AsyncModel.handlers[this.fileType][0](e.target.response, textureMap, context, onerror.bind(undefined, {isModel: 1, source: this.source, id: this.id}));
      
      if (model.ready) {
        this.model = model;
        this.ready = true;
      
        this.runActions();
        
        onload(this);
      }
    } else {
      onerror(this, "" + status);
    }
  },
 
  /**
    * Request a model to setup a model instance.
    *
    * @memberof AsyncModel
    * @instance
    * @param {AsyncModelInstance} instance The requester.
    * @param {object} textureMap The requester's texture map.
    */
  setupInstance: function (instance, textureMap) {
    if (this.ready) {
      this.instances.push(instance);
      
      instance.setup(this.model, textureMap);
    } else {
      this.addAction("setupInstance", arguments);
    }
  },
  
  /**
    * Gets the name of a model.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {string} The model's name.
    */
  getName: function () {
    if (this.ready) {
      return this.model.getName();
    }
  },
  
  /**
    * Gets the source that a model was loaded from.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {string} The model's source.
    */
  getSource: function () {
    return this.source;
  },
  
  /**
    * Gets a model's attachment.
    *
    * @memberof AsyncModel
    * @instance
    * @param {number} id The id of the attachment.
    * @returns {Node} The attachment.
    */
  getAttachment: function (id) {
    if (this.ready) {
      return this.model.getAttachment(id);
    }
  },
  
  /**
    * Gets a model's camera.
    *
    * @memberof AsyncModel
    * @instance
    * @param {number} id The id of the camera.
    * @returns {Camera} The camera.
    */
  getCamera: function (id) {
    if (this.ready) {
      return this.model.getCamera(id);
    }
  },
  
  /**
    * Overrides a texture used by a model.
    *
    * @memberof AsyncModel
    * @instance
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  overrideTexture: function (path, override) {
    if (this.ready) {
      this.model.overrideTexture(path, override);
    } else {
      this.addAction("overrideTexture", arguments);
    }
  },
  
  /**
    * Gets a model's texture map.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {object} The texture map.
    */
  getTextureMap: function () {
    if (this.ready) {
      var textureMap = this.model.getTextureMap();
      
      // Avoid reporting the team color textures, since they are internal.
      // Is there any nicer way to do this?
      delete textureMap["replaceabletextures/teamcolor/teamcolor00.blp"];
      delete textureMap["replaceabletextures/teamglow/teamglow00.blp"];
      
      return textureMap;
    }
  },
  
  /**
    * Gets a model's sequences list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of sequence names.
    */
  getSequences: function () {
    if (this.ready) {
      return this.model.getSequences();
    }
  },
  
  /**
    * Gets a model's attachments list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of attachment names.
    */
  getAttachments: function () {
    if (this.ready) {
      return this.model.getAttachments();
    }
  },
  
  /**
    * Gets a model's bounding shapes list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of bounding shape names.
    */
  getBoundingShapes: function () {
    if (this.ready) {
      return this.model.getBoundingShapes();
    }
  },
  
  /**
    * Gets a model's cameras list.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The list of camera names.
    */
  getCameras: function () {
    if (this.ready) {
      return this.model.getCameras();
    }
  },
  
  /**
    * Gets a model's number of meshes.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {number} The number of meshes.
    */
  getMeshCount: function () {
    if (this.ready) {
      return this.model.getMeshCount();
    }
  },
  
  /**
    * Gets a list of instances that a model owns.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {array} The instance list.
    */
  getInstances: function () {
    if (this.ready) {
      var i,
            l,
            instances = this.instances,
            instance,
            ids = [];
      
      for (i = 0, l = instances.length; i &lt; l; i++) {
        instance = instances[i];
        
        if (instance.ready) {
          ids.push(instance.id);
        }
      }
      
      return ids;
    }
  },
  
  /**
    * Gets a model's information. This includes most of the getters.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {object} The model information.
    */
  getInfo: function () {
    if (this.ready) {
      var model = this.model;
      
      return {
        name: model.getName(),
        source: this.source,
        attachments: model.getAttachments(),
        sequences: model.getSequences(),
        cameras: model.getCameras(),
        textureMap: model.getTextureMap(),
        boundingShapes: model.getBoundingShapes(),
        meshCount: model.getMeshCount(),
        instances: this.getInstances()
      };
    }
  },
  
  /**
    * Gets a model's representation as an object that will be converted to JSON.
    *
    * @memberof AsyncModel
    * @instance
    * @returns {object} The JSON representation.
    */
  toJSON: function () {
    var textureMap = {},
          localTextureMap = this.getTextureMap(),
          keys = Object.keys(localTextureMap),
          key,
          i,
          l;
    
    // This code avoids saving redundant texture paths.
    // Only textures that have been overriden are saved.
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      if (urls.mpqFile(key) !== localTextureMap[key]) {
        textureMap[key] = localTextureMap[key];
      }
    }
    
    return [
      this.id,
      this.source,
      textureMap
    ];
  },
  
  fromJSON: function (object) {
    
  }
};

mixin(Async, AsyncModel.prototype);

/**
 * Creates a new AsyncModelInstance.
 *
 * @class The parent of {@link BaseModelInstance}. Takes care of all the asynchronous aspects of loading model instances. 
 * @name AsyncModelInstance
 * @mixes Async
 * @mixes Spatial
 * @param {AsyncModel} model The model this instance points to.
 * @param {number} id The id of this instance.
 * @param {vec3} color The color this instance uses for {@link AsyncModelInstance.renderColor}.
 * @param {object} textureMap An object with texture path -> absolute urls mapping.
 */
function AsyncModelInstance(asyncModel, id, color, textureMap) {
  this.ready = false;
  this.fileType = asyncModel.fileType;
  this.isInstance = true;
  this.asyncModel = asyncModel;
  this.id = id;
  
  this.source = asyncModel.source;
  this.visible = 1;
  
  // Used for color picking
  this.color = color;
  
  // If the model is already ready, the onload message from setup() must be delayed, since this instance wouldn't be added to the cache yet.
  if (asyncModel.ready) {
    this.delayOnload = true;
  }
  
  this.setupAsync();
  this.setupSpatial();
  
  // Request the setup function to be called by the model when it can.
  // If the model is loaded, setup runs instantly, otherwise it runs when the model finishes loading.
  asyncModel.setupInstance(this, textureMap || {});
}

AsyncModelInstance.handlers = {
  "mdx": Mdx.ModelInstance,
  "m3": M3.ModelInstance
};

AsyncModelInstance.prototype = {
  /**
    * Setup a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {BaseModel} model The model implementation this instance points to.
    * @param {object} textureMap An object with texture path -> absolute urls mapping.
    */
  setup: function (model, textureMap) {
    this.instance = new AsyncModelInstance.handlers[this.fileType](model, textureMap);
    
    this.ready = true;
    
    this.runActions();
    
    this.recalculateTransformation();
    
    if (!this.delayOnload) {
      onload(this);
    }
    
    if (DEBUG_MODE) {
      console.log(this.instance);
    }
  },
  
  /**
    * Updates a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  update: function (context) {
    if (this.ready) {
      this.instance.update(this.getTransformation(), context);
    }
  },
  
  /**
    * Render a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  render: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.render(context);
    }
  },
  
  /**
    * Render the particle emitters of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderEmitters: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderEmitters(context);
    }
  },
  
  /**
    * Render the bounding shapes of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderBoundingShapes: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderBoundingShapes(context);
    }
  },
  
  /**
    * Render a model instance with a specific color.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {object} context An object containing the global state of the viewer.
    */
  renderColor: function (context) {
    if (this.ready &amp;&amp; this.visible) {
      this.instance.renderColor(this.color, context);
    }
  },
  
  /**
    * Gets the name of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {string} The instance's name.
    */
  getName: function () {
    if (this.ready) {
      return this.instance.getName() + "[" + this.id + "]";
    }
  },
  
  /**
    * Gets the source of the model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {string} The model's source.
    */
  getSource: function () {
    return this.asyncModel.source;
  },
  
  // Sets the parent value of a requesting Spatial.
  setRequestedAttachment: function (requester, attachment) {
    requester.setParentNode(this.instance.getAttachment(attachment));
  },
  
  requestAttachment: function (requester, attachment) {
    if (this.ready) {
      return this.setRequestedAttachment(requester, attachment);
    } else {
      this.addAction("setRequestedAttachment", [requester, attachment]);
    }
  },
  
  /**
    * Overrides a texture used by a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  overrideTexture: function (path, override) {
    if (this.ready) {
      this.instance.overrideTexture(path, override);
    } else {
      this.addAction("overrideTexture", [path, override]);
    }
  },
  
  /**
    * Gets a model instance's texture map.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The texture map.
    */
  getTextureMap: function () {
    if (this.ready) {
      var textureMap = this.instance.getTextureMap();
      
      // Avoid reporting the team color textures, since they are internal.
      // Is there any nicer way to do this?
      delete textureMap["replaceabletextures/teamcolor/teamcolor00.blp"];
      delete textureMap["replaceabletextures/teamglow/teamglow00.blp"];
      
      return textureMap;
    }
  },
  
  /**
    * Set the team color of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The team color.
    */
  setTeamColor: function (id) {
    if (this.ready) {
      this.instance.setTeamColor(id);
    } else {
      this.addAction("setTeamColor", [id]);
    }
  },
  
  /**
    * Gets the team color of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The team.
    */
  getTeamColor: function () {
    if (this.ready) {
      return this.instance.getTeamColor();
    }
  },
  
  /**
    * Set the sequence of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The sequence.
    */
  setSequence: function (id) {
    if (this.ready) {
      this.instance.setSequence(id);
    } else {
      this.addAction("setSequence", [id]);
    }
  },
  
  /**
    * Gets the sequence of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The sequence.
    */
  getSequence: function () {
    if (this.ready) {
      return this.instance.getSequence();
    }
  },
  
  /**
    * Set the sequence loop mode of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} mode The sequence loop mode.
    */
  setSequenceLoopMode: function (mode) {
    if (this.ready) {
      this.instance.setSequenceLoopMode(mode);
    } else {
      this.addAction("setSequenceLoopMode", [mode]);
    }
  },
  
  /**
    * Gets the sequence loop mode of a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The sequence loop mode.
    */
  getSequenceLoopMode: function () {
    if (this.ready) {
      return this.instance.getSequenceLoopMode();
    }
  },
  
  /**
    * Gets a model instance's attachment.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The id of the attachment.
    * @returns {Node} The attachment.
    */
  getAttachment: function (id) {
    if (this.ready) {
      return this.instance.getAttachment(id);
    }
  },
  
  /**
    * Gets a model instance's camera.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The id of the camera.
    * @returns {Camera} The camera.
    */
  getCamera: function (id) {
    if (this.ready) {
      return this.instance.getCamera(id);
    }
  },
  
  /**
    * Set a model instance's mesh's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @param {boolean} mode The visibility mode
    */
  setMeshVisibility: function (id, mode) {
    if (this.ready) {
      this.instance.setMeshVisibility(id, mode);
    } else {
      this.addAction("setMeshVisibility", [id, mode]);
    }
  },
  
  /**
    * Gets a model instance's mesh's visibility
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @returns {boolean} The mesh's visiblity.
    */
  getMeshVisibility: function (id) {
    if (this.ready) {
      return this.instance.getMeshVisibility(id);
    }
  },
  
  /**
    * Gets a model instance's mesh's visibility
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {number} id The mesh.
    * @returns {boolean} The mesh's visiblity.
    */
  getMeshVisibilities: function () {
    if (this.ready) {
      return this.instance.getMeshVisibilities();
    }
  },
  
  /**
    * Gets the sequences of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of sequence names.
    */
  getSequences: function () {
    if (this.ready) {
      return this.asyncModel.getSequences();
    }
  },
  
  /**
    * Gets the attachments of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of attachment names.
    */
  getAttachments: function () {
    if (this.ready) {
      return this.asyncModel.getAttachments();
    }
  },
  
  /**
    * Gets the bounding shapes of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of bounding shape names.
    */
  getBoundingShapes: function() {
    if (this.ready) {
      return this.asyncModel.getBoundingShapes();
    }
  },
  
  /**
    * Gets the cameras of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {array} The list of camera names.
    */
  getCameras: function () {
    if (this.ready) {
      return this.asyncModel.getCameras();
    }
  },
  
  /**
    * Gets the number of meshes of a model a model instance points to.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {number} The number of meshes.
    */
  getMeshCount: function () {
    if (this.ready) {
      return this.asyncModel.getMeshCount();
    }
  },
  
  /**
    * Sets a model instance's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @param {boolean} mode The visibility.
    */
  setVisibility: function (mode) {
    this.visible = mode;
  },
  
  /**
    * Gets a model instance's visibility.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {boolean} The visibility.
    */
  getVisibility: function () {
    return this.visible;
  },
  
  /**
    * Gets a model instance's information. This includes most of the getters, and also the information from {@link AsyncModel.getInfo}.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The model instance information.
    */
  getInfo: function () {
    return {
      modelInfo: this.asyncModel.getInfo(),
      visible: this.getVisibility(),
      sequence: this.getSequence(),
      sequenceLoopMode: this.getSequenceLoopMode(),
      location: this.getLocation(),
      rotation: this.getRotation(),
      rotationQuat: this.getRotationQuat(),
      scale: this.getScale(),
      parent: this.getParent(),
      teamColor: this.getTeamColor(),
      textureMap: this.getTextureMap(),
      meshVisibilities: this.getMeshVisibilities(),
      name: this.getName()
    };
  },
  
  /**
    * Gets a model instance's representation as an object that will be converted to JSON.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @returns {object} The JSON representation.
    */
  toJSON: function () {
    // For some reason, when typed arrays are JSON stringified they change to object notation rather than array notation.
    // This is why I don't bother to access the location and rotation directly.
    var location = this.getLocation(),
          rotation = math.toDeg(this.getRotation()),
          scale = this.getScale(),
          textureMap = {},
          localTextureMap = this.getTextureMap(),
          modelTextureMap = this.asyncModel.getTextureMap(),
          keys = Object.keys(localTextureMap),
          key,
          i,
          l,
          visibilities = this.getMeshVisibilities();
          
    // This code avoids saving instance overrides that match the model's texture map.
    // For example, when the client overrides a texture and then sets it back to the original value.
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      if (localTextureMap[key] !== modelTextureMap[key]) {
        textureMap[key] = localTextureMap[key];
      }
    }
    
    // To avoid silly numbers like 1.0000000000000002
    location = math.floatPrecisionArray(location, 2);
    rotation = math.floatPrecisionArray(rotation, 0);
    scale = math.floatPrecision(scale, 2);
    
    // Turn booleans to numbers to shorten the string.
    for (i = 0, l = visibilities.length; i &lt; l; i++) {
      visibilities[i] = visibilities[i] &amp; 1;
    }
    
    return [
      this.id,
      this.asyncModel.id,
      this.getVisibility() &amp; 1,
      this.getSequence(),
      this.getSequenceLoopMode(),
      location,
      rotation,
      scale,
      this.getParent(),
      this.getTeamColor(),
      textureMap,
      visibilities
    ];
  },
  
  /**
    * Applies the settings of a JSON representation to a model instance.
    *
    * @memberof AsyncModelInstance
    * @instance
    * @object {object} The JSON representation.
    */
  fromJSON: function (object) {
    var textureMap = object[10],
          visibilities = object[11],
          keys = Object.keys(textureMap),
          key,
          i,
          l;
          
    this.setVisibility(!!object[2]);
    this.setSequence(object[3]);
    this.setSequenceLoopMode(object[4]);
    this.setLocation(object[5]);
    this.rotate(math.toRad(object[6]));
    this.setScale(object[7]);
    this.setTeamColor(object[9]);
    
    for (i = 0, l = keys.length; i &lt; l; i++) {
      key = keys[i];
      
      this.overrideTexture(key, textureMap[key]);
    }
    
    for (i = 0, l = visibilities.length; i &lt; l; i++) {
      this.setMeshVisibility(i, visibilities[i]);
    }
  }
};

mixin(Async, AsyncModelInstance.prototype);
mixin(Spatial, AsyncModelInstance.prototype);

function setupColor(width, height) {
    // Color texture
    var color = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, color);
    gl.textureOptions(ctx.REPEAT, ctx.REPEAT, ctx.NEAREST, ctx.NEAREST);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, width, height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    
    // Depth render buffer
    var depth = ctx.createRenderbuffer();
    ctx.bindRenderbuffer(ctx.RENDERBUFFER, depth);
    ctx.renderbufferStorage(ctx.RENDERBUFFER, ctx.DEPTH_COMPONENT16, width, height);
    
    // FBO
    var fbo = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, fbo);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, color, 0);
    ctx.framebufferRenderbuffer(ctx.FRAMEBUFFER, ctx.DEPTH_ATTACHMENT, ctx.RENDERBUFFER, depth);
  
    ctx.bindTexture(ctx.TEXTURE_2D, null);
    ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
    
    return fbo;
  }
  
  // Used for color picking
  //var colorFBO = setupColor(512, 512);
  
  function resetViewport() {
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    
    ctx.viewport(0, 0, width, height);
    gl.setPerspective(45, width / height, 0.1, 5E4);
  }
  
  resetViewport();
  
  addEvent(window, "resize", resetViewport);
  
  // Used by Mdx.ParticleEmitter since they don't need to be automatically updated and rendered
  function loadInternalModelInstance(source) {
    if (!modelMap[source]) {
      modelMap[source] = new AsyncModel(source);
    }
    
    var instance = new AsyncModelInstance(modelMap[source]);
    
    // Avoid reporting this instance since it's internal
    instance.delayOnload = true;
    
    return instance;
  }
  
  resetCamera();
  
  var number;
  
  for (var i = 0; i &lt; 13; i++) {
    number = ((i &lt; 10) ? "0" + i : i);
    
    gl.loadTexture(urls.mpqFile("ReplaceableTextures/TeamColor/TeamColor" + number + ".blp"));
    gl.loadTexture(urls.mpqFile("ReplaceableTextures/TeamGlow/TeamGlow" + number + ".blp"));
  }
      
  gl.createShader("world", SHADERS.vsworld, SHADERS.psworld);
  gl.createShader("white", SHADERS.vswhite, SHADERS.pswhite);
  
  gl.loadTexture(grassPath);
  gl.loadTexture(waterPath);
  gl.loadTexture(bedrockPath);
  gl.loadTexture(skyPath);
  
  grass_water = gl.createRect(0, 0, -3, context.groundSize, context.groundSize, 6);
  bedrock = gl.createRect(0, 0, -35, context.groundSize, context.groundSize, 6);
  sky = gl.createSphere(0, 0, 0, 5, 40, 2E3);
  
  function updateParticleRect() {
    for (var i = 0; i &lt; 7; i++) {
      vec3.transformMat4(context.particleBillboardedRect[i], context.particleRect[i], inverseCameraRotation);
    }
  }
  
  function transformCamera() {
    mat4.identity(cameraMatrix);
    mat4.identity(inverseCameraRotation);
    
    if (context.instanceCamera[1] === -1) {
      var z = context.camera[1][1];
      var x = context.camera[1][0];

      mat4.translate(cameraMatrix, cameraMatrix, context.camera[0]);
      mat4.rotate(cameraMatrix, cameraMatrix, x, xAxis);
      mat4.rotate(cameraMatrix, cameraMatrix, z, zAxis);
      
      mat4.rotate(inverseCameraRotation, inverseCameraRotation, -z, zAxis);
      mat4.rotate(inverseCameraRotation, inverseCameraRotation, -x, xAxis);
      
      mat4.invert(inverseCamera, cameraMatrix);
      vec3.transformMat4(cameraPosition, zAxis, inverseCamera);
    } else {
      var instance = modelInstanceMap[context.instanceCamera[0]];
      
      if (instance) {
        var cam = instance.getCamera(context.instanceCamera[1]);
        
        if (cam) {
          var targetPosition = cam.targetPosition;
          
          mat4.lookAt(cameraMatrix, cam.position, targetPosition, upDir);
          mat4.toRotationMat4(inverseCameraRotation, cameraMatrix);
          
          cameraPosition[0] = targetPosition[0];
          cameraPosition[1] = targetPosition[1];
          cameraPosition[2] = targetPosition[2];
        }
      }
    }
    
    gl.loadIdentity();
    gl.multMat(cameraMatrix);
  }
  
  function update() {
    for (var i = 0, l = instanceArray.length; i &lt; l; i++) {
      instanceArray[i].update(context);
    }
    
    transformCamera();
    
    updateParticleRect();
  }
  
  function renderGround(isWater) {
    if (context.worldMode > 1 &amp;&amp; gl.shaderStatus("world")) {
      var shader = gl.bindShader("world");
      
      ctx.disable(ctx.CULL_FACE);
      
      ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
      
      if (isWater) {
        uvOffset[0] += uvSpeed[0];
        uvOffset[1] += uvSpeed[1];
        
        ctx.uniform2fv(shader.variables.u_uv_offset, uvOffset);
        ctx.uniform1f(shader.variables.u_a, 0.6);
      } else {
        ctx.uniform2fv(shader.variables.u_uv_offset, [0, 0]);
        ctx.uniform1f(shader.variables.u_a, 1);
      }
      
      if (context.worldMode > 2) {
        if (isWater) {
          ctx.enable(ctx.BLEND);
          ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
          
          gl.bindTexture(waterPath, 0);
          grass_water.render(shader);
          
          ctx.disable(ctx.BLEND);
        } else {
          gl.bindTexture(bedrockPath, 0);
          bedrock.render(shader);
        }
      } else {
        gl.bindTexture(grassPath, 0);
        grass_water.render(shader);
      }
    }
  }
  
  function renderSky() {
    if (context.worldMode > 0 &amp;&amp; gl.shaderStatus("world")) {
      var shader = gl.bindShader("world");
      
      ctx.uniform2fv(shader.variables.u_uv_offset, [0, 0]);
      ctx.uniform1f(shader.variables.u_a, 1);
      ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getProjectionMatrix());
      
      gl.bindTexture(skyPath, 0);
      sky.render(shader);
    }
  }
  
  function render() {
    var i,
          l = instanceArray.length;
    
    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
    
    renderSky();
    renderGround();
    
    // Render geometry
    if (context.meshesMode) {
      for (i = 0; i &lt; l; i++) {
        instanceArray[i].render(context);
      }
    }
    
    // Render particles
    if (context.emittersMode) {
      for (i = 0; i &lt; l; i++) {
        instanceArray[i].renderEmitters(context);
      }
    }
    
    // Render bounding shapes
    if (context.boundingShapesMode) {
      for (i = 0; i &lt; l; i++) {
        instanceArray[i].renderBoundingShapes(context);
      }
    }
    
    if (context.worldMode > 2) {
      renderGround(true);
    }
  }
  
  function renderColor() {
    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
    
    ctx.disable(ctx.CULL_FACE);
    
    for (var i = 0, l = instanceArray.length; i &lt; l; i++) {
      instanceArray[i].renderColor(context);
    }
    
    ctx.enable(ctx.CULL_FACE);
  }
  
  // The main loop of the viewer
  function step() {
    update();
    render();
    
    requestAnimationFrame(step);
  }

  step();
  
  // Generate a unique color
  var generateColor = (function () {
    var index = 1;
    
    return function () {
      var a = index % 10;
      var b = Math.floor(index / 10) % 10;
      var c = Math.floor(index / 100) % 10;
      
      index += 1;
      
      return [a / 10, b / 10, c / 10];
    };
  }());
  
  function colorString(color) {
    var r = Math.floor(color[0] * 255);
    var g = Math.floor(color[1] * 255);
    var b = Math.floor(color[2] * 255);
    
    return "" + r + g + b;
  }
  
  function loadModel(source, textureMap) {
    if (!modelMap[source]) {
      var object;
      
      idFactory += 1;
      object = new AsyncModel(source, idFactory, textureMap);
      
      modelMap[source] = object;
      modelArray.push(object);
      modelInstanceMap[idFactory] = object;
      
      onloadstart(object);
    }
    
    return modelMap[source];
  }
  
  function loadInstance(source, hidden) {
    var object,
          color = generateColor();
    
    idFactory += 1;
    object = new AsyncModelInstance(modelMap[source], idFactory, color);
    
    if (hidden) {
      object.setVisibility(false);
    }
    
    modelInstanceMap[idFactory] = object;
    instanceArray.push(object);
    instanceMap[colorString(color)] = object;
    
    if (object.delayOnload) {
      onload(object);
    }
    
    return object;
  }
  
  // Load a model or texture from an absolute url, with an optional texture map, and an optional hidden parameter
  function loadResourceImpl(source, textureMap, hidden) {
    var fileType = getFileExtension(source).toLowerCase();
    
    if (supportedModelFileTypes[fileType]) {
      loadModel(source, textureMap);
      loadInstance(source, hidden);
    } else {
      gl.loadTexture(source);
    }
  }
  
  function loadResourceFromId(e) {
    var status = e.target.status;
    
    if (status === 200) {
      onload(this);
      
      var i, l;
      var object = JSON.parse(e.target.responseText);
      var keys = Object.keys(object.textures);
      var textureMap = {};
      
      if (DEBUG_MODE) {
        console.log(object);
      }
      
      for (i = 0, l = keys.length; i &lt; l; i++) {
        var key = keys[i];
        var texture = object.textures[key];
        
        textureMap[key] = texture.url;
        
        gl.loadTexture(textureMap[key]);
      }
      
      var models = object.models;
      
      for (i = 0, l = object.models.length; i &lt; l; i++) {
        loadResourceImpl(models[i].url, textureMap, models[i].hidden);
      }
    }
  }
  
  function unloadInstance(instance, unloadingModel) {
    var i,
          l,
          instances = instance.asyncModel.instances;
    
    // Remove from the instance array
    for (i = 0, l = instanceArray.length; i &lt; l; i++) {
      if (instanceArray[i] === instance) {
        instanceArray.splice(i, 1);
      }
    }
    
    // Remove from the instance map
    delete instanceMap[colorString(instance.color)];
    
    // Remove from the model-instance map
    delete modelInstanceMap[instance.id];
    
    // Don't remove from the model if the model itself is unloaded
    if (!unloadingModel) {
      // Remove from the instances list of the owning model
      for (i = 0, l = instances.length; i &lt; l; i++) {
        if (instances[i] === instance) {
          instances.splice(i, 1);
        }
      }
    }
    
    onunload(instance);
  }
  
  function unloadModel(model) {
    var i,
          l,
          instances = model.instances;
    
    // Remove all instances owned by this model
    for (i = 0, l = instances.length; i &lt; l; i++) {
      unloadInstance(instances[i], true);
    }
    
    // Remove from the model array
    for (i = 0, l = modelArray.length; i &lt; l; i++) {
      if (modelArray[i] === model) {
        modelArray.splice(i, 1);
      }
    }
    
    // Remove from the model-instance map
    delete modelInstanceMap[model.id];
    
    onunload(model);
  }
  
  // ---------------------
  // Model loading API
  // ---------------------
  
  /**
    * Loads a resource.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} source The source to load from. Can be an absolute url, a path to a file in the MPQ files of Warcraft 3 and Starcraft 2, or a form of identifier to be used for headers.
    */
  function loadResource(source) {
    var isSupported = supportedFileTypes[getFileExtension(source).toLowerCase()];
    
    if (source.startsWith("http://") &amp;&amp; isSupported) {
      loadResourceImpl(source);
    } else if (isSupported) {
      loadResourceImpl(urls.mpqFile(source));
    } else {
      var object = {isHeader: 1, source: source};
      
      onloadstart(object);
      
      getFile(urls.header(source), false, loadResourceFromId.bind(object), onerror.bind(undefined, object), onprogress.bind(undefined, object));
    }
  }
  
  /**
    * Unloads a resource.
    *
    * @memberof ModelViewer
    * @instance
    * @param {(string|number)} source The source to unload from. Can be the source of a previously loaded resource, or a valid model or instance ID.
    */
  function unloadResource(source) {
    var object;
    
    if (typeof source === "number") {
      object = modelInstanceMap[source];
      
      if (object &amp;&amp; object.ready) {
        if (object.isModel) {
          unloadModel(object);
        } else {
          unloadInstance(object);
        }
      }
    } else {
      object = modelMap[source];
      
      if (object) {
        if (object.ready) {
          unloadModel(object);
        }
      } else {
        gl.unloadTexture(source);
      }
    }
  }
  
  // ------------------
  // Instance visibility
  // ------------------
  
  /**
    * Sets the visiblity of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {boolean} mode The visibility mode.
    */
  function setVisibility(objectId, mode) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setVisibility(mode);
    }
  }
  
  /**
    * Gets the visiblity of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {boolean} The visibility mode.
    */
  function getVisibility(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getVisibility();
    }
  }
  
  /**
    * Sets the visiblity of a model instance's mesh.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} meshId The ID of the mesh.
    * @param {boolean} mode The visibility mode.
    */
  function setMeshVisibility(objectId, meshId, mode) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.setMeshVisibility(meshId, mode);
    }
  }
  
  /**
    * Gets the visiblity of a model instance's mesh.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} meshId The ID of the mesh.
    * @return {boolean} The visibility mode.
    */
  function getMeshVisibility(objectId, meshId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getMeshVisibility(meshId);
    }
  }
  
  // ------------------
  // Transform API
  // ------------------
  
  /**
    * Sets the location of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v The location.
    */
  function setLocation(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setLocation(v);
    }
  }
  
  /**
    * Moves a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v The displacement.
    */
  function move(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.move(v);
    }
  }
  
  /**
    * Gets the location of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {vec3} The location.
    */
  function getLocation(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getLocation();
    }
  }
  
  /**
    * Sets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v A vector of euler angles.
    */
  function setRotation(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setRotation(v);
    }
  }
  
  /**
    * Rotates a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {vec3} v A vector of euler angles.
    */
  function rotate(objectId, v) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.rotate(v);
    }
  }
  
  /**
    * Gets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {vec3} A vector of euler angles.
    */
  function getRotation(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getRotation();
    }
  }
  
  /**
    * Sets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {quat} v A quaternion.
    */
  function setRotationQuat(objectId, q) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setRotationQuat(quat.normalize(q, q));
    }
  }
  
  /**
    * Rotates a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {quat} v A quaternion.
    */
  function rotateQuat(objectId, q) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.rotate(quat.normalize(q, q));
    }
  }
  
  /**
    * Gets the rotation of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {quat} A quaternion.
    */
  function getRotationQuat(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getRotationQuat();
    }
  }
  
  /**
    * Sets the scale of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} n The scale factor.
    */
  function setScale(objectId, n) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setScale(n);
    }
  }
  
  /**
    * Scales a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} n The scale factor.
    */
  function scale(objectId, n) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.scale(n);
    }
  }
  
  /**
    * Gets the scale of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} The scale factor.
    */
  function getScale(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getScale();
    }
  }
  
  /**
    * Sets the parent of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} parentId The ID of the parent model instance.
    * @param {number} [attachmentId] The ID of an attachment owned by the parent.
    */
  function setParent(objectId, parentId, attachmentId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      if (parentId === -1) {
        object.setParent();
      } else {
        var parent = modelInstanceMap[parentId];
        
        if (parent &amp;&amp; parent.isInstance) {
          object.setParent(parent, attachmentId);
        }
      }
    }
  }
  
  /**
    * Gets the parent of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {array} The parent and attachment IDs as an array.
    */
  function getParent(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getParent();
    }
  }
  
  // -----------------------------
  // Team colors and textures
  // -----------------------------
  
  /**
    * Sets the team color of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} teamID The team color.
    */
  function setTeamColor(objectId, teamId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setTeamColor(teamId);
    }
  }
  
  /**
    * Gets the team color of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} The team color.
    */
  function getTeamColor(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getTeamColor();
    }
  }
  
  /**
    * Overrides a texture of a model or model instance.
    * If overriding the texture of a model, it will affect all of its instances who don't explicitly override this texture too.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @param {string} path The texture path that gets overriden.
    * @paran {string} override The new absolute path that will be used.
    */
  function overrideTexture(objectId, path, override) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      object.overrideTexture(path, override);
    }
  }
  
  /**
    * Gets the texture map of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {object} The texture map.
    */
  function getTextureMap(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getTextureMap();
    }
  }
  
  // ------------
  // Sequences
  // ------------
  
  /**
    * Sets the sequence of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} sequenceId The sequence.
    */
  function setSequence(objectId, sequenceId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setSequence(sequenceId);
    }
  }
  
  /**
    * Stops the sequence of a model instance.
    * Equivalent to setSequence(objectId, -1).
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    */
  function stopSequence(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setSequence(-1);
    }
  }
  
  /**
    * Gets the sequence of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} The sequence.
    */
  function getSequence(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getSequence();
    }
  }
  
  /**
    * Sets the sequence loop mode of a model instance.
    * Possible values are 0 for default, 1 for never loop, and 2 for always loop.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} mode The loop mode.
    */
  function setSequenceLoopMode(objectId, mode) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      object.setSequenceLoopMode(mode);
    }
  }
  
  /**
    * Gets the sequence loop mode of a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @returns {number} sequenceId The loop mode.
    */
  function getSequenceLoopMode(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isInstance) {
      return object.getSequenceLoopMode();
    }
  }
  
  // ----------
  // Getters
  // ----------
  
  /**
    * Gets all the information of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {object} The information.
    */
  function getInfo(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getInfo();
    }
  }
  
  /**
    * Gets a model ID from a valid source or model instance ID.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} source The source.
    * @returns {number} The model ID.
    */
  function getModel(source) {
    var object;
    
    if (typeof source === "string") {
      object = modelMap[source];
    
      if (object) {
        return object.id;
      }
    } else {
      object = modelInstanceMap[source];
      
      if (object) {
        if (object.isInstance) {
          return object.asyncModel.id;
        }
        
        return source;
      }
    }
  }
  
  /**
    * Gets the source of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The source.
    */
  function getSource(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getSource();
    }
  }
  
  /**
    * Gets the sequence list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getSequences(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getSequences();
    }
  }
  
  /**
    * Gets the attachment list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getAttachments(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getAttachments();
    }
  }
  
  /**
    * Gets the camera list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getCameras(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getCameras();
    }
  }
  
  /**
    * Gets the bounding shape list of a model or a model instance.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The list.
    */
  function getBoundingShapes(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getBoundingShapes();
    }
  }
  
  /**
    * Gets the number of meshes a model or a model instance owns.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model or a model instance.
    * @returns {number} The number of meshes.
    */
  function getMeshCount(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object) {
      return object.getMeshCount();
    }
  }
  
  /**
    * Gets a list of all model instances that a model owns.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model.
    * @returns {number} The list.
    */
  function getInstances(objectId) {
    var object = modelInstanceMap[objectId];
    
    if (object &amp;&amp; object.isModel) {
      return object.getInstances();
    }
  }
  
  // -------------------
  // General settings
  // -------------------
  
  /**
    * Sets the animation speed.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} ratio The speed.
    */
  function setAnimationSpeed(ratio) {
    context.frameTime = ratio / 60 * 1000;
  }
  
  /**
    * Gets the animation speed.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {number} The speed.
    */
  function getAnimationSpeed() {
    return context.frameTime / 1000 * 60;
  }
  
  /**
    * Sets the world mode.
    * Possible values are 0 for nothing, 1 for sky, 2 for sky and ground, and 3 for sky and water.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} mode The world mode.
    */
  function setWorldMode(mode) {
    context.worldMode = mode;
  }
  
  /**
    * Gets the world mode.
    * Possible values are 0 for nothing, 1 for sky, 2 for sky and ground, and 3 for sky and water.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} The world mode.
    */
  function getWorldMode() {
    return context.worldMode;
  }
  
  /**
    * Sets the ground size.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} size The ground size.
    */
  function setGroundSize(size) {
    size /= 2;
    
    context.groundSize = size;
    
    grass_water.resize(size, size);
    bedrock.resize(size, size);
  }
  
  /**
    * Gets the ground size.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {number} The ground size.
    */
  function getGroundSize() {
    return context.groundSize * 2;
  }
  
  /**
    * Sets the mesh mode. If false, no meshes will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setMeshesMode(mode) {
    context.meshesMode = mode;
  }
  
  /**
    * Gets the mesh mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getMeshesMode() {
    return context.meshesMode;
  }
  
  /**
    * Sets the particle emitters mode. If false, no particle emitters will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setEmittersMode(b) {
    context.emittersMode = b;
  }
  
  /**
    * Gets the particle emitters mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getEmittersMode() {
    return context.emittersMode;
  }
  
  /**
    * Sets the bounding shapes mode. If false, no bounding shapes will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setBoundingShapesMode(b) {
    context.boundingShapesMode = b;
  }
  
  /**
    * Gets the bounding shapes mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getBoundingShapesMode() {
    return context.boundingShapesMode;
  }
  
  /**
    * Sets the team colors mode. If false, no team colors will be shown.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setTeamColorsMode(b) {
    context.teamColorsMode = b;
  }
  
  /**
    * Gets the team colors mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getTeamColorsMode() {
    return context.teamColorsMode;
  }
  
  /**
    * Sets the polygon mode. If false, models will render as wireframe.
    *
    * @memberof ModelViewer
    * @instance
    * @param {boolean} mode The mode.
    */
  function setPolygonMode(b) {
    context.polygonMode = b;
  }
  
  /**
    * Gets the polygon mode.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {boolean} The mode.
    */
  function getPolygonMode() {
    return context.polygonMode;
  }
  
  /**
    * Sets the shader.
    * Possible values are 0 for `standard`, 1 for `diffuse`, 2 for `normals`, 3 for `uvs`, 4 for `normal map`, 5 for `specular map`, 6 for `specular map + normal map`, 7 for `emissive`, 8 for `unshaded`, 9 for `unshaded + normal map`, 10 for `decal`, and finally 11 for `white`.
    * Note: only the normals, uvs, and white shaders affect Warcraft 3 models, the rest only affect Starcraft 2 models.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} id The shader.
    */
  function setShader(id) {
    context.shader = id;
  }
  
  /**
    * Gets the shader.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {number} The shader.
    */
  function getShader() {
    return context.shader;
  }
  
  // -------------------
  // Camera settings
  // -------------------
  
  /**
    * Sets the camera.
    * If either of the arguments is -1, the normal free form camera is used.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} objectId The ID of a model instance.
    * @param {number} cameraId The camera.
    */
  function setCamera(objectId, cameraId) {
    context.instanceCamera[0] = objectId;
    context.instanceCamera[1] = cameraId;
  }
  
  /**
    * Gets the camera.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {array} The model instance ID and camera. If the free form camera is used, both will be -1.
    */
  function getCamera() {
    return [context.instanceCamera[0], context.instanceCamera[1]];
  }
  
  /**
    * Pans the camera on the x and y axes.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} x Amount to pan on the X axis.
    * @param {number} y Amount to pan on the Y axis.
    */
  function panCamera(x, y) {
    context.instanceCamera[1] = -1;
    context.camera[0][0] += x;
    context.camera[0][1] -= y;
  }
  
  /**
    * Rotates the camera on the x and y axes.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} x Amount to rotate on the X axis.
    * @param {number} y Amount to rotate on the Y axis.
    */
  function rotateCamera(x, y) {
    context.instanceCamera[1] = -1;
    context.camera[1][0] += math.toRad(x);
    context.camera[1][1] += math.toRad(y);
  }
  
  /**
    * Zooms the camera by a factor.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} n Zoom factor.
    */
  function zoomCamera(n) {
    context.instanceCamera[1] = -1;
    context.camera[0][2] = Math.floor(context.camera[0][2] * n);
  }
  
  /**
    * Resets the camera to the initial state.
    *
    * @memberof ModelViewer
    * @instance
    */
  function resetCamera() {
    context.instanceCamera[1] = -1;
    context.camera[0][0] = 0;
    context.camera[0][1] = 0;
    context.camera[0][2] = -300;
    context.camera[1] = [math.toRad(315), math.toRad(225)];
  }
  
  // ------
  // Misc
  // ------
  
  /**
    * Selects a model instance given a screen-space position.
    *
    * @memberof ModelViewer
    * @instance
    * @param {number} x X coordinate.
    * @param {number} y Y coordinate.
    * @returns {number} The ID of the selected model instance, or -1 if no model instance was selected.
    */
  function selectInstance(x, y) {
    //var date = new Date();
    var pixel = new Uint8Array(4);
    
    //var dx = canvas.clientWidth / 512;
    //var dy = canvas.clientHeight / 512;
    
    //console.log(x, y);
    //x = Math.round(x / dx);
    //y = canvas.height - y;
    //y = Math.round(y / dy);
    //console.log(x, y);
    
    //ctx.bindFramebuffer(ctx.FRAMEBUFFER, colorFBO);
    
    //ctx.viewport(0, 0, 512, 512);
    //gl.setPerspective(45, 1, 0.1, 5E4);
    
    renderColor();
    
    // The Y axis of the WebGL viewport is inverted compared to screen space
    y = canvas.clientHeight - y;
    
    ctx.readPixels(x, y, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, pixel);
    
    //ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
    
    //ctx.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
    //gl.setPerspective(45, canvas.clientWidth / canvas.clientHeight, 0.1, 5E4);
    
    //console.log(pixel);
    
    // WebGL sometimes rounds down and sometimes up, so this code takes care of that.
    // E.g.: 0.1*255 = 25.5, WebGL returns 25
    // E.g.: 0.5*255 = 127.5, WebGL returns 128
    var r = Math.floor(Math.round(pixel[0] / 25.5) * 25.5);
    var g = Math.floor(Math.round(pixel[1] / 25.5) * 25.5);
    var b = Math.floor(Math.round(pixel[2] / 25.5) * 25.5);
    
    var color = "" + r + g + b;
    var instance = instanceMap[color];
    
    //console.log("selectInstance", new Date() - date);
    
    if (instance) {
      return instance.id;
    }
    
    return -1;
  }
  
  /**
    * Saves the scene as a JSON string.
    *
    * @memberof ModelViewer
    * @instance
    * @returns {string} The JSON string.
    */
  function saveScene() {
    var i, 
          l,
          models = [],
          instances = [],
          object;
    
    for (i = 0, l = modelArray.length; i &lt; l; i++) {
      object = modelArray[i];
      
      if (object.ready) {
        models.push(object);
      }
    }
    
    for (i = 0, l = instanceArray.length; i &lt; l; i++) {
      object = instanceArray[i];
      
      if (object.ready) {
        instances.push(object);
      }
    }
    
    return JSON.stringify([saveContext(), models, instances]);
  }
  
  /**
    * Loads a scene from JSON string.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} scene The JSON string.
    */
  function loadScene(scene) {
    var i,
          l,
          idMap = [], // Map from object IDs in the scene to actual indices in the object array.
          id,
          models,
          instances,
          object,
          owningModel,
          instance;
    
    scene = JSON.parse(scene);
    
    loadContext(scene[0]);
    
    models = scene[1];
    instances = scene[2];
    
    // Load all the models
    for (i = 0, l = models.length; i &lt; l; i++) {
      // object[0] = id
      // object[1] = source
      // object[2] = texture map
      object = models[i];
      
      loadModel(object[1], object[2]);
      
      idMap[object[0]] = idFactory;
    }
    
    // Load all the instances
    for (i = 0, l = instances.length; i &lt; l; i++) {
      // object[0] = id
      // object[1] = model id
      // ...
      object = instances[i];
      
      owningModel = modelInstanceMap[idMap[object[1]]];
      
      instance = loadInstance(owningModel.getSource());
      instance.fromJSON(object);
      
      idMap[object[0]] = idFactory;
    }
    
    // The parenting must be applied after all instances are loaded
    for (i = 0, l = instances.length; i &lt; l; i++) {
      // object[0] = id
      // object[8] = parent
      object = instances[i];
      parent = object[8];
      
      setParent(idMap[object[0]], idMap[parent[0]], parent[1]);
    }
  }
  
  /**
    * Registers external handlers for an unspported model type.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} fileType The file format the handlers handle.
    * @param {BaseModel} modelHandler A BaseModel-like object.
    * @param {BaseModelInstance} modelInstanceHandler A BaseModelInstance-like object.
    * @param {boolean} binary Determines what type of input the model handler will get - a string, or an ArrayBuffer.
    */
  function registerModelHandler(fileType, modelHandler, modelInstanceHandler, binary) {
    AsyncModel.handlers[fileType] = [modelHandler, binary];
    AsyncModelInstance.handlers[fileType] = modelInstanceHandler;
    
    supportedModelFileTypes[fileType] = 1;
    supportedFileTypes[fileType] = 1;
  }
  
  /**
    * Registers an external handler for an unsupported texture type.
    *
    * @memberof ModelViewer
    * @instance
    * @param {string} fileType The file format the handler handles.
    * @param {function} textureHandler
    */
  function registerTextureHandler(fileType, textureHandler) {
    gl.registerTextureHandler(fileType, textureHandler);
    
    supportedTextureFileTypes[fileType] = 1;
    supportedFileTypes[fileType] = 1;
  }
  
  return {
    // Resource API
    loadResource: loadResource,
    unloadResource: unloadResource,
    // Instance visibility
    setVisibility: setVisibility,
    getVisibility: getVisibility,
    setMeshVisibility: setMeshVisibility,
    getMeshVisibility: getMeshVisibility,
    // Transform API
    setLocation: setLocation,
    move: move,
    getLocation: getLocation,
    setRotation: setRotation,
    rotate: rotate,
    getRotation: getRotation,
    setRotationQuat: setRotationQuat,
    rotateQuat: rotateQuat,
    getRotationQuat: getRotationQuat,
    setScale: setScale,
    scale: scale,
    getScale: getScale,
    setParent: setParent,
    getParent: getParent,
    // Team colors and textures
    setTeamColor: setTeamColor,
    getTeamColor: getTeamColor,
    overrideTexture: overrideTexture,
    getTextureMap: getTextureMap,
    // Sequences
    setSequence: setSequence,
    stopSequence: stopSequence,
    getSequence: getSequence,
    setSequenceLoopMode: setSequenceLoopMode,
    // Information getters
    getInfo: getInfo,
    getModel: getModel,
    getSource: getSource,
    getSequences: getSequences,
    getAttachments: getAttachments,
    getCameras: getCameras,
    getBoundingShapes: getBoundingShapes,
    getMeshCount: getMeshCount,
    getInstances: getInstances,
    // General settings
    setAnimationSpeed: setAnimationSpeed,
    getAnimationSpeed: getAnimationSpeed,
    setWorldMode: setWorldMode,
    getWorldMode: getWorldMode,
    setGroundSize: setGroundSize,
    getGroundSize: getGroundSize,
    setMeshesMode: setMeshesMode,
    getMeshesMode: getMeshesMode,
    setEmittersMode: setEmittersMode,
    getEmittersMode: getEmittersMode,
    setBoundingShapesMode: setBoundingShapesMode,
    getBoundingShapesMode: getBoundingShapesMode,
    setTeamColorsMode: setTeamColorsMode,
    getTeamColorsMode: getTeamColorsMode,
    setPolygonMode: setPolygonMode,
    getPolygonMode: getPolygonMode,
    setShader: setShader,
    getShader: getShader,
    // Camera settings
    setCamera: setCamera,
    getCamera: getCamera,
    panCamera: panCamera,
    rotateCamera: rotateCamera,
    zoomCamera: zoomCamera,
    resetCamera: resetCamera,
    // Misc
    selectInstance: selectInstance,
    saveScene: saveScene,
    loadScene: loadScene,
    // Extending
    registerModelHandler: registerModelHandler,
    registerTextureHandler: registerTextureHandler
  };
};

/**
 * @class This isn't an actual class, but rather something you must implement if you want to use cameras from custom models.
 * @name Camera
 * @property {vec3} position
 * @property {vec3} targetPosition
 */
function DocCamera() {
  
}

/**
 * @class This isn't an actual class, but rather something you must implement if you want to transform custom model instances.
 * @name Node
 */
function DocNode() {
  
}

/**
 * Gets the node's transformation.
 *
 * @memberof Node
 * @instance
 * @returns {mat4} The node's transformation
 */
function docGetTransformation() {
  
}

/**
 * A texture.
 * 
 * @memberof GL
 * @class This isn't an actual class, but rather something you must implement if you want to implement custom textures.
 * @name Texture
 * @param {ArrayBuffer} arrayBuffer The raw texture data.
 * @param {object} options An object containing options.
 * @param {function} onerror A function that allows to report errors.
 * @property {WebGLTexture} id
 * @property {boolean} ready
 */
function DocTexture() {
  
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="AsyncModel.html">AsyncModel</a></li><li><a href="AsyncModelInstance.html">AsyncModelInstance</a></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="BaseModelInstance.html">BaseModelInstance</a></li><li><a href="BinaryReader.html">BinaryReader</a></li><li><a href="Camera.html">Camera</a></li><li><a href="GL.html">GL</a></li><li><a href="GL.BLPTexture.html">BLPTexture</a></li><li><a href="GL.Cube.html">Cube</a></li><li><a href="GL.Cylinder.html">Cylinder</a></li><li><a href="GL.DDSTexture.html">DDSTexture</a></li><li><a href="GL.Rect.html">Rect</a></li><li><a href="GL.Shader.html">Shader</a></li><li><a href="GL.ShaderUnit.html">ShaderUnit</a></li><li><a href="GL.Sphere.html">Sphere</a></li><li><a href="GL.Texture.html">Texture</a></li><li><a href="GL.TGATexture.html">TGATexture</a></li><li><a href="ModelViewer.html">ModelViewer</a></li><li><a href="Node.html">Node</a></li></ul><h3>Mixins</h3><ul><li><a href="Async.html">Async</a></li><li><a href="Spatial.html">Spatial</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bytesToString">bytesToString</a></li><li><a href="global.html#decodeFloat2">decodeFloat2</a></li><li><a href="global.html#decodeFloat3">decodeFloat3</a></li><li><a href="global.html#encodeFloat2">encodeFloat2</a></li><li><a href="global.html#encodeFloat3">encodeFloat3</a></li><li><a href="global.html#getDom">getDom</a></li><li><a href="global.html#getFile">getFile</a></li><li><a href="global.html#getFileExtension">getFileExtension</a></li><li><a href="global.html#getFileName">getFileName</a></li><li><a href="global.html#getUrlVariables">getUrlVariables</a></li><li><a href="global.html#mixin">mixin</a></li><li><a href="global.html#peek">peek</a></li><li><a href="global.html#read">read</a></li><li><a href="global.html#readFloat32">readFloat32</a></li><li><a href="global.html#readFloat32Array">readFloat32Array</a></li><li><a href="global.html#readFloat32Matrix">readFloat32Matrix</a></li><li><a href="global.html#readFloat64">readFloat64</a></li><li><a href="global.html#readFloat64Array">readFloat64Array</a></li><li><a href="global.html#readFloat64Matrix">readFloat64Matrix</a></li><li><a href="global.html#readInt8">readInt8</a></li><li><a href="global.html#readInt8Array">readInt8Array</a></li><li><a href="global.html#readInt8Matrix">readInt8Matrix</a></li><li><a href="global.html#readInt16">readInt16</a></li><li><a href="global.html#readInt16Array">readInt16Array</a></li><li><a href="global.html#readInt16Matrix">readInt16Matrix</a></li><li><a href="global.html#readInt32">readInt32</a></li><li><a href="global.html#readInt32Array">readInt32Array</a></li><li><a href="global.html#readInt32Matrix">readInt32Matrix</a></li><li><a href="global.html#readMatrix">readMatrix</a></li><li><a href="global.html#readUint8">readUint8</a></li><li><a href="global.html#readUint8Array">readUint8Array</a></li><li><a href="global.html#readUint8Matrix">readUint8Matrix</a></li><li><a href="global.html#readUint16">readUint16</a></li><li><a href="global.html#readUint16Array">readUint16Array</a></li><li><a href="global.html#readUint16Matrix">readUint16Matrix</a></li><li><a href="global.html#readUint32">readUint32</a></li><li><a href="global.html#readUint32Array">readUint32Array</a></li><li><a href="global.html#readUint32Matrix">readUint32Matrix</a></li><li><a href="global.html#readVector2">readVector2</a></li><li><a href="global.html#readVector3">readVector3</a></li><li><a href="global.html#readVector4">readVector4</a></li><li><a href="global.html#remaining">remaining</a></li><li><a href="global.html#seek">seek</a></li><li><a href="global.html#skip">skip</a></li><li><a href="global.html#tell">tell</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Sun Sep 28 2014 23:01:15 GMT+0300 (Jerusalem Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
