// Note: this file is automatically generated.

var SHADERS = {
	"vsbonetexture":"uniform sampler2D u_boneMap;\nuniform float u_matrix_size;\nuniform float u_texel_size;\n\nmat4 boneAtIndex(float index) {\n  float offset = index * u_matrix_size;\n  return mat4(texture2D(u_boneMap, vec2(offset, 0)), texture2D(u_boneMap, vec2(offset + u_texel_size, 0)), texture2D(u_boneMap, vec2(offset + u_texel_size * 2.0, 0)), texture2D(u_boneMap, vec2(offset + u_texel_size * 3.0, 0)));\n}",
	"decodefloat":"vec2 decodeFloat2(float f) {\n  vec2 v;\n  \n  v[1] = floor(f / 256.0);\n  v[0] = floor(f - v[1] * 256.0);\n  \n  return v;\n}\n\nvec3 decodeFloat3(float f) {\n  vec3 v;\n  \n  v[2] = floor(f / 65536.0);\n  v[1] = floor((f - v[2] * 65536.0) / 256.0);\n  v[0] = floor(f - v[2] * 65536.0 - v[1] * 256.0);\n  \n  return v;\n}",
	"vsworld":"uniform mat4 u_mvp;\nuniform vec2 u_uv_offset;\n\nattribute vec3 a_position;\nattribute vec2 a_uv;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  v_uv = a_uv + u_uv_offset;\n  \n  gl_Position = u_mvp * vec4(a_position, 1);\n}\n",
	"vswhite":"uniform mat4 u_mvp;\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = u_mvp * vec4(a_position, 1);\n}",
	"psworld":"uniform sampler2D u_texture;\nuniform float u_a;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_texture, v_uv).rgb, u_a);\n}\n",
	"pswhite":"void main() {\n  gl_FragColor = vec4(1);\n}",
	"pscolor":"uniform vec3 u_color;\n\nvoid main() {\n  gl_FragColor = vec4(u_color, 1);\n}\n",
	"wvsmain":"uniform mat4 u_mvp;\nuniform vec2 u_uv_offset;\n\nattribute vec3 a_position;\nattribute vec2 a_uv;\nattribute vec4 a_bones;\nattribute float a_bone_number;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  vec4 v = vec4(a_position, 1);\n  vec4 p = (boneAtIndex(a_bones[0]) * v + boneAtIndex(a_bones[1]) * v + boneAtIndex(a_bones[2]) * v + boneAtIndex(a_bones[3]) * v) / a_bone_number;\n  \n  v_uv = a_uv + u_uv_offset;\n  \n  gl_Position = u_mvp * p ;\n}",
	"wvsribbons":"uniform mat4 u_mvp;\nuniform vec2 u_uv_offset;\n\nattribute vec3 a_position;\nattribute vec2 a_uv;\n\nvarying vec2 v_uv;\n\nvoid main() {\n  v_uv = a_uv + u_uv_offset;\n    \n  gl_Position = u_mvp * vec4(a_position, 1);\n}",
	"wvsparticles":"uniform mat4 u_mvp;\nuniform vec2 u_dimensions;\n\nattribute vec3 a_position;\nattribute vec2 a_uva_rgb;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main() {\n  vec3 uva = decodeFloat3(a_uva_rgb[0]);\n  vec3 rgb = decodeFloat3(a_uva_rgb[1]);\n  \n  v_uv = uva.yx / u_dimensions;\n  v_color = vec4(rgb, uva.z) / 256.0;\n  \n  gl_Position = u_mvp * vec4(a_position, 1);\n}\n",
	"wvscolor":"uniform mat4 u_mvp;\n\nattribute vec3 a_position;\nattribute vec4 a_bones;\nattribute float a_bone_number;\n\nvoid main() {\n  vec4 v = vec4(a_position, 1);\n  vec4 p = (boneAtIndex(a_bones[0]) * v + boneAtIndex(a_bones[1]) * v + boneAtIndex(a_bones[2]) * v + boneAtIndex(a_bones[3]) * v) / a_bone_number;\n  \n  gl_Position = u_mvp * p ;\n}",
	"wpsmain":"uniform sampler2D u_texture;\nuniform bvec3 u_type;\nuniform vec4 u_modifier;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv;\n\nvoid main() {\n  vec4 texel = texture2D(u_texture, v_uv);\n  \n  if (u_type[0] && texel.a < 0.7) {\n    discard;\n  }\n  \n  if (u_type[1] && texel.r < 0.2 && texel.g < 0.2 && texel.b < 0.2) {\n    discard;\n  }\n  \n  if (u_type[2] && texel.r > .9 && texel.g > 0.9 && texel.b > 0.9) {\n    discard;\n  }\n  \n  gl_FragColor = texel * u_modifier;\n}\n",
	"wpsparticles":"uniform sampler2D u_texture;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = texture2D(u_texture, v_uv) * v_color;\n}\n",
	"svscommon":"vec3 TBN(vec3 vector, vec3 tangent, vec3 binormal, vec3 normal) {\n  vec3 transformed;\n  \n  transformed.x = dot(vector, tangent);\n  transformed.y = dot(vector, binormal);\n  transformed.z = dot(vector, normal);\n  \n  return transformed;\n}\n\nvec4 decodeVector(vec4 v) {\n  return ((v / 255.0) * 2.0) - 1.0;\n}",
	"svsstandard":"uniform mat4 u_mvp;\nuniform mat4 u_mv;\nuniform vec3 u_eyePos;\nuniform vec3 u_lightPos;\nuniform float u_firstBoneLookupIndex;\n\nattribute vec3 a_position;\nattribute vec4 a_normal;\nattribute vec2 a_uv0;\n\n#ifdef EXPLICITUV1\nattribute vec2 a_uv1;\n#endif\n#ifdef EXPLICITUV2\nattribute vec2 a_uv1;\nattribute vec2 a_uv2;\n#endif\n#ifdef EXPLICITUV3\nattribute vec2 a_uv1;\nattribute vec2 a_uv2;\nattribute vec2 a_uv3;\n#endif\n\nattribute vec4 a_tangent;\nattribute vec4 a_bones;\nattribute vec4 a_weights;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv[4];\nvarying vec3 v_lightDir;\nvarying vec3 v_eyeVec;\nvarying vec3 v_halfVec;\n\nvoid transform(vec3 inposition, vec3 innormal, vec3 intangent, vec4 bones, vec4 weights, out vec3 outposition, out vec3 outnormal, out vec3 outtangent) {\n  vec4 position = vec4(inposition, 1);\n  vec4 normal = vec4(innormal, 0);\n  vec4 tangent = vec4(intangent, 0);\n  vec4 temp;\n  \n  mat4 weightedBone0 = boneAtIndex(bones[0]) * weights[0];\n  mat4 weightedBone1 = boneAtIndex(bones[1]) * weights[1];\n  mat4 weightedBone2 = boneAtIndex(bones[2]) * weights[2];\n  mat4 weightedBone3 = boneAtIndex(bones[3]) * weights[3];\n  \n  temp = vec4(0);\n  temp += weightedBone0 * position;\n  temp += weightedBone1 * position;\n  temp += weightedBone2 * position;\n  temp += weightedBone3 * position;\n  outposition = vec3(temp);\n  \n  temp = vec4(0);\n  temp += weightedBone0 * normal;\n  temp += weightedBone1 * normal;\n  temp += weightedBone2 * normal;\n  temp += weightedBone3 * normal;\n  outnormal = normalize(vec3(temp));\n  \n  temp = vec4(0);\n  temp += weightedBone0 * tangent;\n  temp += weightedBone1 * tangent;\n  temp += weightedBone2 * tangent;\n  temp += weightedBone3 * tangent;\n  outtangent = normalize(vec3(temp));\n}\n\nvoid main() {\n  vec4 decodedNormal = decodeVector(a_normal);\n  vec4 decodedTangent = decodeVector(a_tangent);\n  vec3 position, normal, tangent;\n  \n  transform(a_position, vec3(decodedNormal), vec3(decodedTangent), a_bones + u_firstBoneLookupIndex, a_weights / 255.0, position, normal, tangent);\n  \n  mat3 mv = mat3(u_mv);\n  \n  vec3 position_mv = (u_mv * vec4(position, 1)).xyz;\n  \n  vec3 n = normalize(mv * normal);\n  vec3 t = normalize(mv * tangent);\n  vec3 b = normalize(cross(n, t) * decodedNormal.w);\n  \n  vec3 lightDir = normalize(u_lightPos - position_mv);\n  v_lightDir = normalize(TBN(lightDir, t, b, n));\n  \n  vec3 eyeVec = normalize(u_eyePos - position_mv);\n  vec3 halfVec = normalize(eyeVec - u_lightPos);\n  \n  v_eyeVec = TBN(eyeVec, t, b, n);\n  v_halfVec = TBN(halfVec, t, b, n);\n  \n  v_normal = n;\n  \n  v_uv[0] = a_uv0 / 2048.0;\n  \n  v_uv[1] = vec2(0);\n  v_uv[2] = vec2(0);\n  v_uv[3] = vec2(0);\n  \n  #ifdef EXPLICITUV1\n  v_uv[1] = a_uv1 / 2048.0;\n  #endif\n  #ifdef EXPLICITUV2\n  v_uv[1] = a_uv1 / 2048.0;\n  v_uv[2] = a_uv2 / 2048.0;\n  #endif\n  #ifdef EXPLICITUV3\n  v_uv[1] = a_uv1 / 2048.0;\n  v_uv[2] = a_uv2 / 2048.0;\n  v_uv[3] = a_uv3 / 2048.0;\n  #endif\n  \n  gl_Position = u_mvp * vec4(position, 1);\n}\n",
	"svscolor":"uniform mat4 u_mvp;\nuniform float u_firstBoneLookupIndex;\n\nattribute vec3 a_position;\nattribute vec4 a_bones;\nattribute vec4 a_weights;\n\nvoid transform(vec3 inposition, vec4 bones, vec4 weights, out vec3 outposition) {\n  vec4 position = vec4(inposition, 1);\n  vec4 temp;\n  \n  mat4 weightedBone0 = boneAtIndex(bones[0]) * weights[0];\n  mat4 weightedBone1 = boneAtIndex(bones[1]) * weights[1];\n  mat4 weightedBone2 = boneAtIndex(bones[2]) * weights[2];\n  mat4 weightedBone3 = boneAtIndex(bones[3]) * weights[3];\n  \n  temp = vec4(0);\n  temp += weightedBone0 * position;\n  temp += weightedBone1 * position;\n  temp += weightedBone2 * position;\n  temp += weightedBone3 * position;\n  outposition = vec3(temp);\n}\n\nvoid main() {\n  vec3 position;\n  \n  transform(a_position, a_bones + u_firstBoneLookupIndex, a_weights / 255.0, position);\n  \n  gl_Position = u_mvp * vec4(position * 100.0, 1);\n}\n",
	"spscommon":"uniform vec3 u_teamColor;\n\nvarying vec3 v_normal;\nvarying vec2 v_uv[4];\nvarying vec3 v_lightDir;\nvarying vec3 v_eyeVec;\nvarying vec3 v_halfVec;\n\nstruct LayerSettings {\n  bool enabled;\n  float op;\n  float channels;\n  float teamColorMode;\n  //vec3 multAddAlpha;\n  //bool useAlphaFactor;\n  bool invert;\n  //bool multColor;\n  //bool addColor;\n  bool clampResult;\n  //bool useConstantColor;\n  //vec4 constantColor;\n  //float uvSource;\n  float uvCoordinate;\n  //float fresnelMode;\n  //float fresnelTransformMode;\n  //mat4 fresnelTransform;\n  //bool fresnelClamp;\n  //vec3 fresnelExponentBiasScale;\n};\n\n#define SPECULAR_RGB 0.0\n#define SPECULAR_A_ONLY 1.0\n\n#define FRESNELMODE_NONE 0.0\n#define FRESNELMODE_STANDARD 1.0\n#define FRESNELMODE_INVERTED 2.0\n\n#define FRESNELTRANSFORM_NONE 0.0\n#define FRESNELTRANSFORM_SIMPLE 1.0\n#define FRESNELTRANSFORM_NORMALIZED 2.0\n\n#define UVMAP_EXPLICITUV0 0.0\n#define UVMAP_EXPLICITUV1 1.0\n#define UVMAP_REFLECT_CUBICENVIO 2.0\n#define UVMAP_REFLECT_SPHERICALENVIO 3.0\n#define UVMAP_PLANARLOCALZ 4.0\n#define UVMAP_PLANARWORLDZ 5.0\n#define UVMAP_PARTICLE_FLIPBOOK 6.0\n#define UVMAP_CUBICENVIO 7.0\n#define UVMAP_SPHERICALENVIO 8.0\n#define UVMAP_EXPLICITUV2 9.0\n#define UVMAP_EXPLICITUV3 10.0\n#define UVMAP_PLANARLOCALX 11.0\n#define UVMAP_PLANARLOCALY 12.0\n#define UVMAP_PLANARWORLDX 13.0\n#define UVMAP_PLANARWORLDY 14.0\n#define UVMAP_SCREENSPACE 15.0\n#define UVMAP_TRIPLANAR_LOCAL 16.0\n#define UVMAP_TRIPLANAR_WORLD 17.0\n#define UVMAP_TRIPLANAR_WORLD_LOCAL_Z 18.0\n\n#define CHANNELSELECT_RGB 0.0\n#define CHANNELSELECT_RGBA 1.0\n#define CHANNELSELECT_A 2.0\n#define CHANNELSELECT_R 3.0\n#define CHANNELSELECT_G 4.0\n#define CHANNELSELECT_B 5.0\n\n#define TEAMCOLOR_NONE 0.0\n#define TEAMCOLOR_DIFFUSE 1.0\n#define TEAMCOLOR_EMISSIVE 2.0\n\n#define LAYEROP_MOD 0.0\n#define LAYEROP_MOD2X 1.0\n#define LAYEROP_ADD 2.0\n#define LAYEROP_LERP 3.0\n#define LAYEROP_TEAMCOLOR_EMISSIVE_ADD 4.0\n#define LAYEROP_TEAMCOLOR_DIFFUSE_ADD 5.0\n#define LAYEROP_ADD_NO_ALPHA 6.0\n/*\nfloat calculateFresnelTerm(vec3 normal, vec3 eyeToVertex, float exponent, mat4 fresnelTransform, float fresnelTransformMode, bool fresnelClamp) {\n  vec3 fresnelDir = eyeToVertex;\n  float result;\n  \n  if (fresnelTransformMode != FRESNELTRANSFORM_NONE) {\n    fresnelDir = (fresnelTransform * vec4(fresnelDir, 1.0)).xyz;\n    \n    if (fresnelTransformMode == FRESNELTRANSFORM_NORMALIZED) {\n      fresnelDir = normalize(fresnelDir);\n    }\n  }\n  \n  if (fresnelClamp) {\n    result = 1.0 - clamp(-dot(normal, fresnelDir), 0.0, 1.0);\n  } else {\n    result = 1.0 - abs(dot(normal, fresnelDir));\n  }\n  \n  result = max(result, 0.0000001);\n  \n  return pow(result, exponent);\n}\n*/\nvec3 combineLayerColor(vec4 color, vec3 result, LayerSettings layerSettings) {\n  if (layerSettings.op == LAYEROP_MOD) {\n    result *= color.rgb;\n  } else if (layerSettings.op == LAYEROP_MOD2X) {\n    result *= color.rgb * 2.0;\n  } else if (layerSettings.op == LAYEROP_ADD) {\n    result += color.rgb * color.a;\n  } else if (layerSettings.op == LAYEROP_ADD_NO_ALPHA) {\n    result += color.rgb;\n  } else if (layerSettings.op == LAYEROP_LERP) {\n    result = mix(result, color.rgb, color.a);\n  } else if (layerSettings.op == LAYEROP_TEAMCOLOR_EMISSIVE_ADD) {\n    result += color.a * u_teamColor;\n  } else if (layerSettings.op == LAYEROP_TEAMCOLOR_DIFFUSE_ADD) {\n    result += color.a * u_teamColor;\n  }\n  \n  return result;\n}\n\nvec4 chooseChannel(float channel, vec4 texel) {\n  if (channel == CHANNELSELECT_R) {\n    texel = texel.rrrr;\n  } else if (channel == CHANNELSELECT_G) {\n    texel = texel.gggg;\n  } else if (channel == CHANNELSELECT_B) {\n    texel = texel.bbbb;\n  } else if (channel == CHANNELSELECT_A) {\n    texel = texel.aaaa;\n  } else if (channel == CHANNELSELECT_RGB) {\n    texel.a = 1.0;\n  }\n  \n  return texel;\n}\n\nvec2 getUV(LayerSettings layerSettings) {\n  if (layerSettings.uvCoordinate == 1.0) {\n    return v_uv[1];\n  } else if (layerSettings.uvCoordinate == 2.0) {\n    return v_uv[2];\n  } else if (layerSettings.uvCoordinate == 3.0) {\n    return v_uv[3];\n  }\n  \n  return v_uv[0];\n}\n\nvec4 sampleLayer(sampler2D layer, LayerSettings layerSettings) {\n  /*\n  if (layerSettings.useConstantColor && false) {\n    return layerSettings.constantColor;\n  }\n  */\n  return texture2D(layer, getUV(layerSettings));\n}\n\nvec4 computeLayerColor(sampler2D layer, LayerSettings layerSettings) {\n  vec4 texel = sampleLayer(layer, layerSettings);\n  vec4 result = chooseChannel(layerSettings.channels, texel);\n  /*\n  if (layerSettings.useAlphaFactor && false) {\n    result.a *= layerSettings.multAddAlpha.z;\n  }\n  */\n  if (layerSettings.teamColorMode == TEAMCOLOR_DIFFUSE) {\n    result = vec4(mix(u_teamColor, result.rgb, texel.a), 1);\n  } else if (layerSettings.teamColorMode == TEAMCOLOR_EMISSIVE) {\n    result = vec4(mix(u_teamColor, result.rgb, texel.a), 1);\n  }\n  \n  if (layerSettings.invert) {\n    result = vec4(1) - result;\n  }\n  /*\n  if (layerSettings.multColor && false) {\n    result *= layerSettings.multAddAlpha.x;\n  }\n  \n  if (layerSettings.addColor && false) {\n    result += layerSettings.multAddAlpha.y;\n  }\n  */\n  if (layerSettings.clampResult) {\n    result = clamp(result, 0.0, 1.0);\n  }\n  /*\n  if (layerSettings.fresnelMode != FRESNELMODE_NONE) {\n    float fresnelTerm = calculateFresnelTerm(v_normal, v_eyeVec, layerSettings.fresnelExponentBiasScale.x, layerSettings.fresnelTransform, layerSettings.fresnelTransformMode, layerSettings.fresnelClamp);\n    \n    if (layerSettings.fresnelMode == FRESNELMODE_INVERTED) {\n      fresnelTerm = 1.0 - fresnelTerm;\n    }\n    \n    fresnelTerm = clamp(fresnelTerm * layerSettings.fresnelExponentBiasScale.z + layerSettings.fresnelExponentBiasScale.y, 0.0, 1.0);\n    \n    result *= fresnelTerm;\n  }\n  */\n  return result;\n}\n\nvec3 decodeNormal(sampler2D map) {\n  vec4 texel = texture2D(map, v_uv[0]);\n  vec3 normal;\n  \n  normal.xy = 2.0 * texel.wy - 1.0;\n  normal.z = sqrt(max(0.0, 1.0 - dot(normal.xy, normal.xy)));\n  \n  return normal;\n}\n\nvec4 computeSpecular(sampler2D specularMap, LayerSettings layerSettings, float specularity, float specMult, vec3 normal) {\n  vec4 color;\n  \n  if (layerSettings.enabled) {\n    color = computeLayerColor(specularMap, layerSettings);\n  } else {\n    color = vec4(0);\n  }\n  \n  float factor = pow(max(-dot(v_halfVec, normal), 0.0), specularity) * specMult;\n  \n  return color * factor;\n}",
	"spsstandard":"uniform float u_specularity;\nuniform float u_specMult;\nuniform float u_emisMult;\nuniform vec4 u_lightAmbient;\n\nuniform LayerSettings u_diffuseLayerSettings;\nuniform sampler2D u_diffuseMap;\nuniform LayerSettings u_decalLayerSettings;\nuniform sampler2D u_decalMap;\nuniform LayerSettings u_specularLayerSettings;\nuniform sampler2D u_specularMap;\nuniform LayerSettings u_glossLayerSettings;\nuniform sampler2D u_glossMap;\nuniform LayerSettings u_emissiveLayerSettings;\nuniform sampler2D u_emissiveMap;\nuniform LayerSettings u_emissive2LayerSettings;\nuniform sampler2D u_emissive2Map;\nuniform LayerSettings u_evioLayerSettings;\nuniform sampler2D u_evioMap;\nuniform LayerSettings u_evioMaskLayerSettings;\nuniform sampler2D u_evioMaskMap;\nuniform LayerSettings u_alphaLayerSettings;\nuniform sampler2D u_alphaMap;\nuniform LayerSettings u_alphaMaskLayerSettings;\nuniform sampler2D u_alphaMaskMap;\nuniform LayerSettings u_normalLayerSettings;\nuniform sampler2D u_normalMap;\nuniform LayerSettings u_heightLayerSettings;\nuniform sampler2D u_heightMap;\nuniform LayerSettings u_lightMapLayerSettings;\nuniform sampler2D u_lightMapMap;\nuniform LayerSettings u_aoLayerSettings;\nuniform sampler2D u_aoMap;\n\nvoid main() {\n  vec3 color;\n  vec4 final = u_lightAmbient;\n  vec3 normal;\n  vec3 lightMapDiffuse;\n  \n  if (u_normalLayerSettings.enabled) {\n    normal = decodeNormal(u_normalMap);\n  } else {\n    normal = v_normal;\n  }\n\n  float lambertFactor = max(dot(normal, v_lightDir), 0.0);\n  \n  if (lambertFactor > 0.0) {\n    if (u_diffuseLayerSettings.enabled) {\n      vec4 diffuseColor = computeLayerColor(u_diffuseMap, u_diffuseLayerSettings);\n      \n      color = combineLayerColor(diffuseColor, color, u_diffuseLayerSettings);\n    }\n    \n    if (u_decalLayerSettings.enabled) {\n      vec4 decalColor = computeLayerColor(u_decalMap, u_decalLayerSettings);\n      \n      color = combineLayerColor(decalColor, color, u_decalLayerSettings);\n    }\n    \n    vec4 specularColor = computeSpecular(u_specularMap, u_specularLayerSettings, u_specularity, u_specMult, normal);\n    \n    if (u_lightMapLayerSettings.enabled) {\n      vec4 lightMapColor = computeLayerColor(u_lightMapMap, u_lightMapLayerSettings) * 2.0;\n      \n      lightMapDiffuse = lightMapColor.rgb;\n    }\n    \n    //final.rgb = color * lightMapDiffuse + specularColor.rgb;\n    final.rgb = (color + specularColor.rgb) * lambertFactor;\n    \n    bool addEmissive = false;\n    vec3 emissiveColor;\n    vec4 tempColor;\n    \n    if (u_emissiveLayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissiveMap, u_emissiveLayerSettings);\n      \n        if (u_emissiveLayerSettings.op == LAYEROP_MOD || u_emissiveLayerSettings.op == LAYEROP_MOD2X || u_emissiveLayerSettings.op == LAYEROP_LERP) {\n            final.rgb = combineLayerColor(tempColor, final.rgb, u_emissiveLayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissiveLayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (u_emissive2LayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissive2Map, u_emissive2LayerSettings);\n      \n        if (!addEmissive && (u_emissive2LayerSettings.op == LAYEROP_MOD || u_emissive2LayerSettings.op == LAYEROP_MOD2X || u_emissive2LayerSettings.op == LAYEROP_LERP)) {\n            final.rgb = combineLayerColor(tempColor, final.rgb, u_emissive2LayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissive2LayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (addEmissive) {\n        final.rgb += emissiveColor * u_emisMult;\n    }\n  }\n  \n  gl_FragColor = final;\n}",
	"spsspecialized":"#ifdef DIFFUSE_PASS\nuniform LayerSettings u_diffuseLayerSettings;\nuniform sampler2D u_diffuseMap;\n#endif\n#ifdef SPECULAR_PASS\nuniform LayerSettings u_specularLayerSettings;\nuniform sampler2D u_specularMap;\nuniform float u_specularity;\nuniform float u_specMult;\n#endif\n#ifdef HIGHRES_NORMALS\nuniform LayerSettings u_normalLayerSettings;\nuniform sampler2D u_normalMap;\n#endif\n#ifdef EMISSIVE_PASS\nuniform LayerSettings u_emissiveLayerSettings;\nuniform sampler2D u_emissiveMap;\nuniform LayerSettings u_emissive2LayerSettings;\nuniform sampler2D u_emissive2Map;\nuniform float u_emisMult;\n#endif\n#ifdef DECAL_PASS\nuniform LayerSettings u_decalLayerSettings;\nuniform sampler2D u_decalMap;\n#endif\n\nvoid main() {\n  vec4 color = vec4(0);\n  vec3 normal;\n  \n  #ifdef HIGHRES_NORMALS\n    normal = decodeNormal(u_normalMap);\n  #else\n    normal = v_normal;\n  #endif\n  \n  #ifdef DIFFUSE_PASS\n    color = computeLayerColor(u_diffuseMap, u_diffuseLayerSettings);\n  #endif\n  \n  #ifdef NORMALS_PASS\n    color = vec4(normal, 1);\n  #endif\n  \n  #ifdef SPECULAR_PASS\n    color = computeSpecular(u_specularMap, u_specularLayerSettings, u_specularity, u_specMult, normal);\n  #endif\n  \n  #ifdef EMISSIVE_PASS\n    bool addEmissive = false;\n    vec3 emissiveColor = vec3(0);\n    vec4 tempColor;\n    \n    if (u_emissiveLayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissiveMap, u_emissiveLayerSettings);\n      \n        if (u_emissiveLayerSettings.op == LAYEROP_MOD || u_emissiveLayerSettings.op == LAYEROP_MOD2X || u_emissiveLayerSettings.op == LAYEROP_LERP) {\n            color.rgb = combineLayerColor(tempColor, color.rgb, u_emissiveLayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissiveLayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (u_emissive2LayerSettings.enabled) {\n        tempColor = computeLayerColor(u_emissive2Map, u_emissive2LayerSettings);\n      \n        if (!addEmissive && (u_emissive2LayerSettings.op == LAYEROP_MOD || u_emissive2LayerSettings.op == LAYEROP_MOD2X || u_emissive2LayerSettings.op == LAYEROP_LERP)) {\n            color.rgb = combineLayerColor(tempColor, color.rgb, u_emissive2LayerSettings);\n        } else {\n            emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissive2LayerSettings);\n            addEmissive = true;\n        }\n    }\n    \n    if (addEmissive) {\n        color.rgb += emissiveColor.rgb * u_emisMult;\n    }\n  #endif\n  \n  #ifdef UNSHADED_PASS\n    float lambertFactor = max(dot(normal, v_lightDir), 0.0);\n    \n    color = vec4(lambertFactor, lambertFactor, lambertFactor, 1);\n  #endif\n  \n  #ifdef DECAL_PASS\n    if (u_decalLayerSettings.enabled) {\n      vec4 decalColor = computeLayerColor(u_decalMap, u_decalLayerSettings);\n      \n      color.rgb = combineLayerColor(decalColor, color.rgb, u_decalLayerSettings);\n      color.a = 1.0;\n    }\n  #endif\n  \n  gl_FragColor = color;\n}",
	"svsparticles":"uniform mat4 u_mvp;\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = u_mvp * vec4(a_position, 1);\n}\n",
	"spsparticles":"void main() {\n	gl_FragColor = vec4(1);\n}\n"
};